# Понятие потока

**Поток (Thread, Нить)** — это наименьшая единица планирования и исполнения в операционной системе. Поток существует в рамках процесса и делит с другими потоками этого процесса адресное пространство и системные ресурсы (файлы), но имеет собственный контекст выполнения: счетчик команд, регистры и стек. Потоки позволяют реализовать параллелизм внутри одного приложения.

---

## Вопрос 14: Причины создания потоков. Реализация сервера для обработки запросов через однопоточный процессы и множество потоков

### Причины создания потоков
Потоки (threads) были созданы для:
1.  **Модульности**: Возможность разбить приложение на логические последовательности действий.
2.  **Эффективности**: Потоки легче (дешевле) создавать и уничтожать, чем процессы. Переключение контекста между ними быстрее, так как не нужно переключать адресное пространство.
3.  **Параллелизма**: Возможность выполнять задачи одновременно на многоядерных процессорах.
4.  **Асинхронности**: Пока один поток ждет ввода-вывода (например, от диска или сети), другие могут продолжать вычисления.

### Реализация сервера

#### Однопоточный процесс
Сервер работает в бесконечном цикле в одном потоке:
1.  Ожидает запрос (`accept`).
2.  Получает запрос, обрабатывает его.
3.  Отправляет ответ.
4.  Возвращается к ожиданию следующего.
*   **Проблема**: Последовательная обработка. Если обработка одного клиента долгая, все остальные ждут в очереди. Не используется многоядерность.

#### Множество потоков (Multithreaded Server)
Сервер имеет главный поток (Dispatcher) и рабочие потоки (Workers):
1.  Главный поток ожидает запрос (`accept`).
2.  При получении запроса создает **новый поток** (или берет из пула) и передает ему соединение.
3.  Главный поток сразу возвращается к ожиданию новых запросов.
4.  Рабочий поток параллельно обрабатывает свой запрос и завершается.
*   **Преимущество**: Параллельная обработка множества клиентов. Блокировка одного потока (I/O) не останавливает сервер.

---

## Вопрос 15: Причины создания потоков. Объекты, относящиеся к процессам и потокам. Стратегии реализации потоков

### Объекты процесса и потока
В многопоточной среде процесс служит контейнером ресурсов, а поток — единицей исполнения.

*   **Объекты процесса (общие для всех потоков)**:
    *   Адресное пространство (код, глобальные данные, куча).
    *   Открытые файлы (дескрипторы).
    *   Дочерние процессы.
    *   Сигналы и обработчики сигналов.
    *   Учетная информация (UID, GID).

*   **Объекты потока (индивидуальные)**:
    *   Счетчик команд (PC).
    *   Регистры процессора.
    *   Стек (локальные переменные, цепочка вызовов).
    *   Состояние (готов, выполняется, блокирован).

### Стратегии реализации потоков

#### 1. Потоки уровня пользователя (User-Level Threads, ULT)
Реализуются библиотекой в пространстве пользователя (например, ранние Java, Green Threads). Ядро ОС видит только один процесс.
*   **Плюсы**: Очень быстрое переключение (не нужен системный вызов), свой планировщик.
*   **Минусы**: Блокирующий системный вызов одного потока блокирует весь процесс. Не используют многоядерность (ядро дает процессу только 1 квант времени).

#### 2. Потоки уровня ядра (Kernel-Level Threads, KLT)
Поддерживаются непосредственно ОС (Windows, Linux, macOS).
*   **Плюсы**: Истинный параллелизм на многоядерных CPU. Блокировка одного потока не влияет на другие.
*   **Минусы**: Переключение медленнее (требует перехода в режим ядра). Занимают ресурсы ядра.

#### 3. Гибридная реализация (M:N)
Мультиплексирование M пользовательских потоков на N потоков ядра. Сложна в реализации, сейчас используется редко (пример: Go goroutines).

---

## Вопрос 16: Параллельное программирование. Fork-and-Join модель

**Fork-and-Join** — модель параллельного выполнения, основанная на динамическом создании подзадач.
1.  **Fork (Разветвление)**: Родительский поток разделяет задачу на части и запускает дочерние потоки для их выполнения.
2.  **Join (Слияние)**: Родительский поток ожидает завершения всех дочерних потоков, после чего объединяет их результаты и продолжает работу.

Пример: Параллельная сортировка слиянием или обработка массива частями. Эффективность ограничивается законом Амдала (последовательной частью программы).

---

## Вопрос 17: Параллельное программирование. Понятие псевдопараллелизма

**Псевдопараллелизм (Конкурентность)** — режим выполнения на однопроцессорной (одноядерной) системе, при котором создается иллюзия одновременной работы нескольких потоков.
*   **Механизм**: Процессор быстро переключается между потоками (Time Sharing).
*   **Суть**: В любой конкретный момент времени выполняется только одна инструкция одного потока.
*   **Отличие от истинного параллелизма**: При истинном параллелизме (на многоядерных системах) инструкции разных потоков выполняются физически одновременно.

---

## Вопрос 18: Параллельное программирование. Ошибки в параллельном программировании. Гонка данных

### Ошибки параллельного программирования
1.  **Гонка данных (Data Race / Race Condition)**.
2.  **Взаимная блокировка (Deadlock)**: Два потока ждут ресурсы, захваченные друг другом.
3.  **Голодание (Starvation)**: Поток не получает доступ к ресурсам из-за низкого приоритета.
4.  **Livelock**: Потоки активны, меняют состояния, но не продвигаются вперед (бесполезная работа).

### Гонка данных (Race Condition)
Ситуация, когда поведение программы зависит от случайного порядка выполнения потоков. Возникает при одновременном доступе нескольких потоков к общим данным, где минимум один доступ — запись.
*   **Пример**: Два потока делают `x++`.
    1.  Поток А читает x (5).
    2.  Поток Б читает x (5).
    3.  Поток А пишет (6).
    4.  Поток Б пишет (6).
    *Итог*: 6 вместо 7. Информация потеряна.
*   **Решение**: Использование механизмов синхронизации (мьютексы, семафоры, атомарные операции).
