# Понятие взаимоблокировки (Deadlock)

## Вопрос 27: Условия возникновения. Моделирование взаимоблокировок. Способы борьбы со взаимоблокировками.

---

## 1. ОПРЕДЕЛЕНИЕ ВЗАИМОБЛОКИРОВКИ

**Взаимоблокировка (deadlock)** — это ситуация в многопроцессной среде, когда набор процессов (потоков) находится в состоянии ожидания, при котором каждый процесс ждет события, которое может быть вызвано только другим процессом из этого же набора.

**Формальное определение:** множество потоков находится в состоянии взаимоблокировки, когда каждый поток из этого множества ожидает события, которое может быть причинено только другим потоком из того же множества.

### Иллюстрация:
Закон штата Канзас начала XX века гласил: "Когда два поезда подъезжают друг к другу на пересечении, оба должны полностью остановиться, и ни один из них не должен возобновлять движение, пока другой не уехал". Если оба поезда следуют этому закону, они оба остановятся и останутся неподвижны навсегда — это идеальная иллюстрация взаимоблокировки.

---

## 2. ЧЕТЫРЕ НЕОБХОДИМЫХ УСЛОВИЯ ВОЗНИКНОВЕНИЯ ВЗАИМОБЛОКИРОВКИ

Взаимоблокировка может возникнуть, только если **одновременно выполняются все четыре условия**:

### 2.1 Условие 1: Взаимное исключение (Mutual Exclusion)

- **Суть:** Как минимум один ресурс должен находиться в несовместимом режиме, то есть только один поток в один момент времени может использовать ресурс.
- **Описание:** Если другой поток запросит этот ресурс, запрашивающий поток должен ждать до освобождения ресурса.
- **Примеры несовместимых ресурсов:**
  - Мьютексы (mutex locks)
  - Семафоры (semaphores)
  - Устройства ввода-вывода (принтеры, дисководы)
  - Блокировки на данные
- **Контрпример:** Совместимые ресурсы (например, файлы, открытые только для чтения) не могут участвовать в взаимоблокировке.

**Условие нельзя предотвратить в общем случае**, потому что некоторые ресурсы по природе несовместимы (например, мьютекс не может быть одновременно заблокирован несколькими потоками).

### 2.2 Условие 2: Удержание и Ожидание (Hold and Wait)

- **Суть:** Поток должен удерживать как минимум один ресурс и одновременно ожидать получение дополнительных ресурсов, которые в данный момент удерживаются другими потоками.
- **Механизм возникновения:** Поток получил ресурс A, но для выполнения своей работы ему нужен также ресурс B, который удерживает другой поток.
- **Характеристика:** Это активное удержание одного ресурса при ожидании другого.

**Пример на С (Pthreads):**
```c
// Поток 1
pthread_mutex_lock(&resource1);      // Получил первый ресурс
// Выполняет работу
pthread_mutex_lock(&resource2);      // Ждет второй ресурс (взаимоблокировка может возникнуть здесь)
// ...
pthread_mutex_unlock(&resource2);
pthread_mutex_unlock(&resource1);
```

### 2.3 Условие 3: Отсутствие Вытеснения (No Preemption)

- **Суть:** Ресурсы не могут быть вытеснены. Ресурс может быть освобожден только добровольно потоком, который его удерживает, после завершения его работы.
- **Следствие:** Операционная система не может принудительно забрать ресурс у потока, чтобы дать его другому потоку.
- **Почему это условие выполняется:** В большинстве систем вытеснение ресурсов невозможно (особенно для мьютексов и семафоров).

**Пример:** Если поток A держит мьютекс, система не может просто взять этот мьютекс и передать его потоку B, даже если потоку B он нужнее.

### 2.4 Условие 4: Циклическое Ожидание (Circular Wait)

- **Суть:** Должна существовать циклическая цепочка потоков {T₀, T₁, ..., Tₙ} такая, что:
  - T₀ ждет ресурс, удерживаемый T₁
  - T₁ ждет ресурс, удеживаемый T₂
  - ...
  - Tₙ ждет ресурс, удерживаемый T₀
  
- **Визуальное представление:** Граф ресурсов содержит цикл.

**Пример циклического ожидания:**
```
Поток A удерживает Ресурс 1 и ждет Ресурс 2
        ↓
Поток B удерживает Ресурс 2 и ждет Ресурс 1
        ↓
Цикл: A → R2 → B → R1 → A
```

### Взаимосвязь условий:

- **Все четыре условия необходимы:** Взаимоблокировка может произойти **только если ВСЕ четыре условия выполняются одновременно**.
- **Условие 4 подразумевает условие 2:** Циклическое ожидание автоматически означает удержание и ожидание.
- **Независимость:** Однако полезно рассматривать каждое условие отдельно, так как это позволяет разработать стратегии предотвращения.

---

## 3. МОДЕЛИРОВАНИЕ ВЗАИМОБЛОКИРОВОК

### 3.1 Граф Распределения Ресурсов (Resource-Allocation Graph)

**Определение:** Граф распределения ресурсов — это направленный граф, используемый для моделирования состояния системы с точки зрения распределения ресурсов между потоками.

**Компоненты графа:**
1. **Вершины (Vertices):**
   - Множество T = {T₁, T₂, ..., Tₙ} — все активные потоки в системе (обозначаются кругами)
   - Множество R = {R₁, R₂, ..., Rₘ} — все типы ресурсов в системе (обозначаются прямоугольниками)

2. **Ребра (Edges):**
   - **Ребро запроса (Request edge):** Tᵢ → Rⱼ означает, что поток Tᵢ запросил ресурс типа Rⱼ и в данный момент ожидает его.
   - **Ребро назначения (Assignment edge):** Rⱼ → Tᵢ означает, что экземпляр ресурса типа Rⱼ выделен потоку Tᵢ.

3. **Экземпляры ресурсов:**
   - Если тип ресурса Rⱼ имеет несколько экземпляров, каждый экземпляр изображается точкой внутри прямоугольника.
   - Ребро запроса указывает только на прямоугольник Rⱼ (общий для всех экземпляров).
   - Ребро назначения указывает на конкретную точку (экземпляр) в прямоугольнике.

### 3.2 Преобразования в графе

**Динамика графа:**
1. Когда поток Tᵢ запрашивает ресурс Rⱼ, в граф добавляется ребро запроса Tᵢ → Rⱼ.
2. Когда запрос может быть удовлетворен, ребро запроса мгновенно трансформируется в ребро назначения Rⱼ → Tᵢ.
3. Когда поток больше не нуждается в ресурсе, ребро назначения удаляется.

### 3.3 Циклы в графе и взаимоблокировка

**Фундаментальное правило:**

- **Если граф НЕ содержит циклов → НЕ существует взаимоблокировки в системе.**

- **Если граф содержит цикл:**
  - **Если каждый тип ресурса имеет ровно один экземпляр** → цикл означает, что существует взаимоблокировка (необходимое и достаточное условие).
  - **Если каждый тип ресурса имеет несколько экземпляров** → цикл необходим, но недостаточен для взаимоблокировки. Взаимоблокировка может или не может произойти.

### 3.4 Примеры графов

**Пример 1: Граф без цикла (нет взаимоблокировки)**

```
Ситуация:
- T₁ удерживает R₁ и ждет R₂
- T₂ удерживает R₂ и ждет R₃
- T₃ удерживает R₃

Граф:
T₁ → R₂ ← T₂ → R₃ ← T₃

Нет цикла, нет взаимоблокировки.
```

**Пример 2: Граф с циклом (может быть взаимоблокировка)**

```
Ситуация:
- T₁ удерживает R₂ и ждет R₁
- T₂ удерживает R₁ и ждет R₂

Граф:
  R₁ → T₂ → R₂ → T₁ → R₁

Цикл существует, взаимоблокировка вероятна!
```

### 3.5 Граф типов потоков (Wait-For Graph)

Для систем с одним экземпляром каждого ресурса используется упрощенный граф **граф ожидания (wait-for graph)**:
- Содержит только вершины потоков.
- Ребро Tᵢ → Tⱼ означает, что поток Tᵢ ждет ресурса, удерживаемого потоком Tⱼ.
- **Цикл в графе ожидания прямо указывает на взаимоблокировку.**

---

## 4. ПРИМЕР ВЗАИМОБЛОКИРОВКИ В МНОГОПОТОЧНОЙ ПРОГРАММЕ

### 4.1 Классический пример на Pthreads

```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t first_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t second_mutex = PTHREAD_MUTEX_INITIALIZER;

// Поток 1: Захватывает ресурсы в порядке 1, 2
void *thread_one(void *param) {
    pthread_mutex_lock(&first_mutex);          // Захватил first_mutex
    printf("Thread 1: locked first_mutex\n");
    
    sleep(1);  // Дает время потоку 2 захватить second_mutex
    
    pthread_mutex_lock(&second_mutex);         // Ждет second_mutex
    printf("Thread 1: locked second_mutex\n");
    
    // Выполняет работу
    
    pthread_mutex_unlock(&second_mutex);
    pthread_mutex_unlock(&first_mutex);
    pthread_exit(0);
}

// Поток 2: Захватывает ресурсы в порядке 2, 1
void *thread_two(void *param) {
    pthread_mutex_lock(&second_mutex);         // Захватил second_mutex
    printf("Thread 2: locked second_mutex\n");
    
    sleep(1);  // Дает время потоку 1 захватить first_mutex
    
    pthread_mutex_lock(&first_mutex);          // Ждет first_mutex
    printf("Thread 2: locked first_mutex\n");
    
    // Выполняет работу
    
    pthread_mutex_unlock(&first_mutex);
    pthread_mutex_unlock(&second_mutex);
    pthread_exit(0);
}

int main() {
    pthread_t tid1, tid2;
    
    pthread_create(&tid1, NULL, thread_one, NULL);
    pthread_create(&tid2, NULL, thread_two, NULL);
    
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    
    return 0;
}
```

**Сценарий взаимоблокировки:**
1. Поток 1 захватывает first_mutex
2. Поток 2 захватывает second_mutex
3. Поток 1 пытается захватить second_mutex → **ЖДЕТ**
4. Поток 2 пытается захватить first_mutex → **ЖДЕТ**
5. Оба потока ждут друг друга → **ВЗАИМОБЛОКИРОВКА**

### 4.2 Условия для возникновения

В приведенном примере:
1. ✓ **Взаимное исключение:** Каждый мьютекс может использоваться только одним потоком
2. ✓ **Удержание и ожидание:** Потоки удерживают один мьютекс и ждут другой
3. ✓ **Отсутствие вытеснения:** Мьютексы не могут быть вытеснены
4. ✓ **Циклическое ожидание:** Поток 1 → R2 → Поток 2 → R1 → Поток 1

**Важное замечание:** Взаимоблокировка может не произойти, если потоки захватывают мьютексы в разном порядке по времени, но опасность существует.

---

## 5. СПОСОБЫ БОРЬБЫ СО ВЗАИМОБЛОКИРОВКАМИ

Существует три основных подхода:

### Подход 1: Игнорирование (Ostrich Algorithm)
### Подход 2: Предотвращение/Избежание
### Подход 3: Обнаружение и Восстановление

---

## 5.1 ПРЕДОТВРАЩЕНИЕ ВЗАИМОБЛОКИРОВОК (Deadlock Prevention)

**Идея:** Обеспечить, чтобы **как минимум одно из четырех необходимых условий НЕ выполнялось**.

### 5.1.1 Отрицание условия 1: Взаимное исключение

**Метод:** Избегать несовместимых ресурсов или сделать ресурсы совместимыми.

**Практичность:** **НЕВОЗМОЖНО в большинстве случаев**, так как многие ресурсы по природе несовместимы (мьютексы, семафоры, устройства ввода-вывода).

**Где применимо:**
- Совместимые ресурсы (файлы только для чтения) не требуют взаимного исключения
- Но для критических ресурсов это неприменимо

### 5.1.2 Отрицание условия 2: Удержание и Ожидание

**Метод:** Гарантировать, что поток, запрашивающий ресурс, не удерживает никакие другие ресурсы.

**Две стратегии:**

**Стратегия A: Запросить все ресурсы сразу**
- Поток должен запросить все необходимые ему ресурсы перед началом выполнения
- Либо поток получает все ресурсы, либо не получает ничего

```c
// Правильный подход
void *thread_function(void *param) {
    // Запрашиваем оба ресурса одновременно
    acquire_all_locks(first_mutex, second_mutex);
    
    // Выполняем работу
    
    release_all_locks(first_mutex, second_mutex);
    pthread_exit(0);
}
```

**Стратегия B: Освободить все ресурсы перед запросом новых**
- Перед запросом дополнительного ресурса поток должен освободить все удерживаемые ресурсы
- Поток может запрашивать новые ресурсы только если не удерживает старые

```c
void *thread_function(void *param) {
    pthread_mutex_lock(&resource1);
    // Используем resource1
    pthread_mutex_unlock(&resource1);  // Освобождаем
    
    pthread_mutex_lock(&resource2);    // Только потом запрашиваем новый
    // Используем resource2
    pthread_mutex_unlock(&resource2);
}
```

**Недостатки обеих стратегий:**
- **Низкая утилизация ресурсов:** Ресурсы запрашиваются заранее, но используются позже
- **Возможность голодания (starvation):** Поток может ждать неопределенно долго, если часто используемый ресурс занят другими потоками

### 5.1.3 Отрицание условия 3: Отсутствие Вытеснения

**Метод:** Разрешить вытеснение ресурсов — если поток не может получить нужный ресурс, забрать у него все удерживаемые ресурсы.

**Протокол вытеснения:**
1. Если поток удерживает ресурсы и просит дополнительный ресурс, который недоступен, все его ресурсы вытесняются.
2. Вытесненные ресурсы добавляются к списку ресурсов, которые поток ждет.
3. Поток перезапускается только когда получит обратно все старые ресурсы и новые ресурсы.

**Практичность:** **ОГРАНИЧЕННАЯ**
- Хорошо работает для ресурсов, состояние которых легко сохранить и восстановить:
  - Регистры CPU
  - Транзакции БД
  - Память
  
- **НЕ работает** для мьютексов и семафоров (именно там взаимоблокировка возникает чаще всего)

### 5.1.4 Отрицание условия 4: Циклическое Ожидание ⭐ (Наиболее практичный метод)

**Метод:** Упорядочить все типы ресурсов и требовать, чтобы процессы запрашивали ресурсы в возрастающем порядке нумерации.

**Формальное определение:**
- Назначить каждому типу ресурса Rᵢ уникальный номер: F(Rᵢ) = i
- Каждый поток может запрашивать ресурсы ТОЛЬКО в порядке возрастания номеров
- **Правило:** Если поток удерживает ресурс Rᵢ и хочет Rⱼ, то F(Rᵢ) < F(Rⱼ)

**Пример упорядочения мьютексов:**
```c
// Присваиваем номера
F(first_mutex) = 1
F(second_mutex) = 5

// Правильный порядок (оба потока используют один порядок):
pthread_mutex_lock(&first_mutex);    // Номер 1, получаем первым
pthread_mutex_lock(&second_mutex);   // Номер 5, получаем вторым
```

**Доказательство отсутствия циклического ожидания:**
- Предположим существует цикл: T₀ → R₀ → T₁ → R₁ → ... → Tₙ → Rₙ → T₀
- Так как Tᵢ → Rᵢ, поток Tᵢ ждет ресурс Rᵢ
- Так как Tᵢ₊₁ → Rᵢ (удерживает), по правилу упорядочения должно быть F(Rᵢ) < F(Rᵢ₊₁) для всех i
- Но это означает F(R₀) < F(R₁) < ... < F(Rₙ) < F(R₀), что невозможно (противоречие!)
- **Значит, цикл не может существовать.**

**Практические аспекты:**

**Преимущества:**
- Наиболее практичный метод предотвращения
- Простой в реализации и понимании

**Недостатки:**
- Требует установления порядка для всех ресурсов в системе
- На системах с сотнями или тысячами блокировок сложно
- Предотвращение требует участия разработчиков (система не принуждает к порядку)
- Может быть неэффективно, если порядок не оптимален

**Инструменты для проверки:**
- **Linux lockdep:** Инструмент ядра Linux, который проверяет правильность порядка захвата блокировок в реальном времени
- **Java:** Разработчики часто используют System.identityHashCode(Object) для динамического упорядочения блокировок

**Проблема с динамическими блокировками:**

```c
// Проблемный пример: динамическое получение блокировок
void transfer(Account from, Account to, double amount) {
    mutex_t lock1 = get_lock(from);
    mutex_t lock2 = get_lock(to);
    
    acquire(lock1);
    acquire(lock2);
    
    withdraw(from, amount);
    deposit(to, amount);
    
    release(lock2);
    release(lock1);
}

// Поток A вызывает: transfer(checking, savings, 25)
// Поток B вызывает: transfer(savings, checking, 50)
// Порядок блокировок нарушается, возможна взаимоблокировка!
```

**Решение:** Упорядочить динамически

```c
void transfer(Account from, Account to, double amount) {
    mutex_t lock1, lock2;
    
    // Гарантируем порядок на основе ID аккаунта
    if (from.id < to.id) {
        lock1 = get_lock(from);
        lock2 = get_lock(to);
    } else {
        lock1 = get_lock(to);
        lock2 = get_lock(from);
    }
    
    acquire(lock1);
    acquire(lock2);
    
    withdraw(from, amount);
    deposit(to, amount);
    
    release(lock2);
    release(lock1);
}
```

---

## 5.2 ИЗБЕЖАНИЕ ВЗАИМОБЛОКИРОВОК (Deadlock Avoidance)

**Отличие от предотвращения:**
- **Предотвращение:** Ограничивает способ запроса ресурсов (структурные ограничения)
- **Избежание:** Отслеживает состояние и решает для каждого запроса, может ли он быть удовлетворен

**Идея:** Система должна иметь полную информацию о том, какие ресурсы каждому потоку когда-либо потребуются. На основе этой информации система принимает решение о выделении ресурса, чтобы избежать небезопасных состояний.

### 5.2.1 Безопасное состояние (Safe State)

**Определение:** Состояние системы **безопасно**, если существует последовательность потоков, в которой каждый поток может:
1. Получить все необходимые ему ресурсы
2. Выполнить свою работу
3. Освободить ресурсы
4. Позволить следующему потоку продолжить работу

**Формально:** Последовательность потоков T₁, T₂, ..., Tₙ является безопасной, если для каждого Tᵢ ресурсы, которые ему еще нужны, могут быть удовлетворены доступными ресурсами плюс ресурсы, удерживаемые потоками Tⱼ, где j < i.

**Пример безопасного состояния:**

```
Система: 12 ресурсов
T0: макс = 10, имеет = 5, нужно = 5
T1: макс = 4,  имеет = 2, нужно = 2
T2: макс = 9,  имеет = 2, нужно = 7

Свободно: 3 ресурса

Безопасная последовательность: T1, T0, T2
- T1 получает оставшиеся 2 ресурса, завершает, освобождает все 4 → свободно 5
- T0 получает оставшиеся 5 ресурсов, завершает, освобождает все 10 → свободно 10
- T2 получает оставшиеся 7 ресурсов, завершает → свободно 12

Состояние БЕЗОПАСНО!
```

**Связь с взаимоблокировкой:**
- Безопасное состояние → НЕ взаимоблокировки
- Небезопасное состояние → МОЖЕТ быть взаимоблокировка (но не гарантированно)

### 5.2.2 Алгоритм избежания: Алгоритм Банкира (Banker's Algorithm)

**Предпосылка:** Система знает максимальное количество ресурсов каждого типа, которое может потребоваться каждому потоку.

**Данные, которые система должна поддерживать:**

1. **Available:** Вектор длины m (количество типов ресурсов)
   - Available[j] = количество доступных экземпляров ресурса j

2. **Max:** Матрица n × m (n потоков, m типов ресурсов)
   - Max[i][j] = максимальное количество ресурса j, которое может потребоваться потоку i

3. **Allocation:** Матрица n × m
   - Allocation[i][j] = количество ресурса j, выделенное потоку i

4. **Need:** Матрица n × m
   - Need[i][j] = Max[i][j] - Allocation[i][j] = сколько еще ресурса j нужно потоку i

**Алгоритм проверки безопасности (Safety Algorithm):**

```
1. Work = Available, Finish[i] = false для всех i

2. Найти индекс i такой что:
   a) Finish[i] == false
   b) Need[i] <= Work

   Если такого i нет → идти на шаг 4

3. Work = Work + Allocation[i]
   Finish[i] = true
   Идти на шаг 2

4. Если Finish[i] == true для всех i → БЕЗОПАСНО
   Иначе → НЕБЕЗОПАСНО
```

**Алгоритм запроса ресурса (Resource Request Algorithm):**

Когда поток Tᵢ запрашивает Request[i]:

```
1. Если Request[i] > Need[i] → ОШИБКА (превышен максимум)

2. Если Request[i] > Available → поток ЖДЕТ

3. Условно выдать ресурсы потоку i:
   Available = Available - Request[i]
   Allocation[i] = Allocation[i] + Request[i]
   Need[i] = Need[i] - Request[i]
   
4. Запустить алгоритм безопасности:
   - Если результат БЕЗОПАСНО → выделить ресурсы (шаг 3 становится постоянным)
   - Если результат НЕБЕЗОПАСНО → отменить выделение (откатить шаг 3), поток ЖДЕТ
```

**Пример применения:**

```
Система:
Ресурс A: 10 экземпляров
Ресурс B: 5 экземпляров
Ресурс C: 7 экземпляров

Потоки:
       Max         Allocation     Need        Available
     A B C        A B C          A B C       A B C
T0   7 5 3       0 1 0          7 4 3       3 3 2
T1   3 2 2       2 0 0          1 2 2
T2   9 0 2       3 0 2          6 0 0
T3   2 2 2       2 1 1          0 1 1
T4   4 3 3       0 0 2          4 3 1

Безопасная последовательность: T1, T3, T4, T2, T0

T1 запрашивает (1,0,2):
- Check: (1,0,2) < Available (3,3,2) ✓
- Условно выделяем → Available становится (2,3,0)
- Проверяем безопасность → последовательность T1,T3,T4,T0,T2 работает ✓
- Выделение РАЗРЕШЕНО
```

**Преимущества:**
- Гарантирует безопасность (никогда не войдет в состояние взаимоблокировки)

**Недостатки:**
- Требует знания максимальных потребностей заранее
- Может быть консервативным (отказывает в выделении, даже если можно дать)
- Вычислительная сложность O(m*n²) на каждый запрос
- В реальных системах редко используется (разработчики предпочитают предотвращение или обнаружение)

---

## 5.3 ОБНАРУЖЕНИЕ И ВОССТАНОВЛЕНИЕ ОТ ВЗАИМОБЛОКИРОВОК (Detection & Recovery)

**Подход:** Позволить системе войти в состояние взаимоблокировки, затем обнаружить и восстановиться.

**Применение в:**
- Системах баз данных (СУБД)
- Системах, где производительность важнее надежности

### 5.3.1 Обнаружение взаимоблокировок

**Для систем с одним экземпляром каждого ресурса:**

Использовать **граф ожидания (Wait-For Graph)**:
- Содержит только вершины потоков
- Ребро Tᵢ → Tⱼ означает Tᵢ ждет Tⱼ
- **Цикл в графе ожидания = взаимоблокировка**
- Проверка цикла: O(n²) операций

**Алгоритм обнаружения для систем с несколькими экземплярами:**

```
1. Work = Available, Finish[i] = false для всех i

2. Найти индекс i такой что:
   a) Finish[i] == false
   b) Request[i] <= Work

   Если такого i нет → идти на шаг 4

3. Work = Work + Allocation[i]
   Finish[i] = true
   Идти на шаг 2

4. Если Finish[i] == false для какого-либо i → 
   Потоки с Finish[i] == false находятся в ВЗАИМОБЛОКИРОВКЕ
```

**Когда вызывать алгоритм:**
- При каждом невозможном выполнении запроса (дорого)
- Периодически (раз в час, когда утилизация CPU < 40%)
- Компромисс: между обнаружением и производительностью

### 5.3.2 Восстановление от взаимоблокировки

**Если взаимоблокировка обнаружена, есть два основных способа:**

#### Способ 1: Прерывание процессов

**Стратегия A: Прервать все взаимоблокированные процессы**
- Простой способ
- Отбрасывает все результаты вычислений
- Очень дорого по времени

**Стратегия B: Поочередно прерывать процессы**
- После прерывания каждого процесса запустить алгоритм обнаружения
- После каждого прерывания проверяем, разрешена ли взаимоблокировка
- Выбираем жертву по критерию стоимости:
  - Количество удерживаемых ресурсов
  - Время вычисления
  - Количество выполненной работы
  - Приоритет процесса

#### Способ 2: Вытеснение ресурсов

**Идея:** Забрать ресурсы у одного или нескольких процессов и дать другим.

**Три проблемы при вытеснении:**

1. **Выбор жертвы:** Какой процесс и какие ресурсы вытеснять?
   - Минимизировать стоимость вытеснения

2. **Откат (Rollback):** Что делать с прерванным процессом?
   - **Полный откат:** Прервать и перезапустить с начала (просто, но неэффективно)
   - **Частичный откат:** Откатить только до определенной точки (сложно, требует сохранения контрольных точек)

3. **Предотвращение голодания (Starvation):** Избежать ситуации, когда один процесс всегда выбирается жертвой
   - **Решение:** Включить количество откатов в стоимость выбора жертвы
   - Ограничить количество раз, когда процесс может быть жертвой (например, максимум 3 раза)

**Пример в базах данных:**
- СУБД периодически проверяют наличие взаимоблокировок между транзакциями
- При обнаружении выбирают одну транзакцию-жертву
- Откатывают (ROLLBACK) транзакцию
- Освобождают блокировки
- Другие транзакции могут продолжить работу
- Откатанная транзакция может быть переписана и выполнена снова

---

## 5.4 СРАВНЕНИЕ ПОДХОДОВ

| Подход | Предотвращение | Избежание | Обнаружение |
|--------|--------------|----------|------------|
| **Как работает** | Исключает одно из 4 условий | Анализирует состояние | Позволяет, затем восстанавливается |
| **Гарантии** | Полные (никогда не будет) | Полные (при известных max) | Частичные (может быть) |
| **Производительность** | Хорошая (структурные ограничения) | Может быть низкая (консервативно) | Может быть низкая (прерывание) |
| **Сложность** | Средняя (требует упорядочения) | Высокая (Banker's алгоритм) | Средняя (обнаружение цикла) |
| **Практичность** | Высокая (используется везде) | Низкая (редко на практике) | Высокая (БД) |
| **Требования информации** | Нет | Максимальные потребности | Текущее состояние |
| **Использование** | Многопроцессные ОС, приложения | Теоретические системы | Базы данных |

---

## 6. РЕАЛЬНЫЕ ПРИМЕРЫ И ИНСТРУМЕНТЫ

### 6.1 Linux lockdep

**lockdep** — это инструмент ядра Linux для обнаружения возможных взаимоблокировок:

**Возможности:**
- Отслеживает динамически порядок захвата блокировок
- Проверяет против правил упорядочения
- Обнаруживает проблемы с включением прерываний

**Пример использования:**
```bash
# Включить lockdep в ядре
# Запустить тест
# lockdep сообщит обо всех потенциальных взаимоблокировках
```

**Результаты:** За несколько лет использования (с 2006) количество взаимоблокировок в Linux уменьшилось на порядок.

### 6.2 Java Thread Dumps

**Java** предоставляет возможность анализа потоков:
```bash
# Генерировать дамп потоков
Ctrl+L (Unix/Linux/macOS)
Ctrl+Break (Windows)
```

JVM автоматически анализирует граф ожидания и сообщает о взаимоблокировках.

### 6.3 Базы данных (MySQL, PostgreSQL)

**СУБД используют обнаружение с восстановлением:**
- Периодически проверяют наличие циклов в графе ожидания
- При обнаружении выбирают жертву (транзакцию с минимальными изменениями)
- Откатывают транзакцию (ROLLBACK)
- Приложение должно быть готово к обработке ошибки deadlock

---

## 7. ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ

### 7.1 Как избежать взаимоблокировок в коде

1. **Упорядочивание ресурсов**
   ```c
   // ПРАВИЛЬНО
   if (resource1_id < resource2_id) {
       lock(resource1);
       lock(resource2);
   } else {
       lock(resource2);
       lock(resource1);
   }
   ```

2. **Минимизировать время удержания**
   ```c
   // ПРАВИЛЬНО: минимизировать критическую секцию
   lock(resource);
   critical_work();
   unlock(resource);
   ```

3. **Избегать вложенных блокировок**
   ```c
   // ПЛОХО
   lock(A);
   lock(B);
   
   // ХОРОШО
   acquire_all([A, B]);
   ```

4. **Использовать таймауты**
   ```c
   // С таймаутом можно обнаружить проблему
   if (pthread_mutex_timedlock(&mutex, &timeout) == ETIMEDOUT) {
       // Обработать таймаут
   }
   ```

### 7.2 Инструменты для отладки

- **Linux lockdep** — для ядра
- **Helgrind (Valgrind)** — для пользовательских приложений
- **ThreadSanitizer (TSan)** — для обнаружения race conditions и deadlocks
- **Java Thread Dump Analyzer** — для Java приложений

---

## ЗАКЛЮЧЕНИЕ

Взаимоблокировка — это критическая проблема в многопоточном и многопроцессном программировании. Четыре необходимых условия определяют возникновение взаимоблокировки. Система может использовать один из трех основных подходов:

1. **Предотвращение** — исключить одно из условий (практичнее всего упорядочить ресурсы)
2. **Избежание** — анализировать состояние (Алгоритм Банкира)
3. **Обнаружение и восстановление** — позволить, затем исправить (используется в БД)

Большинство современных ОС используют **предотвращение** (обычно упорядочение ресурсов), требуя от разработчиков соблюдения правил использования блокировок. Инструменты вроде **Linux lockdep** помогают обнаружить проблемы на этапе разработки.

---

## СПИСОК ИСТОЧНИКОВ

- Tanenbaum, A. S., & Bos, H. (2015). Современные операционные системы (4-е издание). Раздел 5.6 и 6 — Синхронизация и взаимоблокировки.
- Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). Operating System Concepts (10-е издание). Глава 8 — Deadlocks.
- Dijkstra, E. W. (1965). Cooperating Sequential Processes. Классическая работа о взаимоблокировках.
