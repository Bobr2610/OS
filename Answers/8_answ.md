# Управление памятью

**Управление памятью (Memory Management)** — это подсистема операционной системы, отвечающая за выделение оперативной памяти процессам, её освобождение, защиту памяти процессов друг от друга и организацию эффективного совместного использования ограниченного объема физической RAM.

---

## Вопрос 28: Адресные пространства. Понятие свопинга. Общий принцип управления памятью ОС. Распределитель памяти ядра

### Адресные пространства
**Виртуальное адресное пространство** — диапазон адресов, доступных процессу (от 0 до MAX). ОС отображает эти виртуальные адреса на физические через таблицы страниц.
*   **Изоляция**: Процесс не видит памяти других процессов.
*   **Защита**: Сегменты имеют права (R/W/X).

### Свопинг (Swapping / Paging)
Механизм, при котором ОС временно перемещает неактивные страницы памяти из RAM на жесткий диск (в swap-файл или раздел), освобождая место для активных процессов. При обращении к выгруженной странице происходит Page Fault, и она загружается обратно.

### Общий принцип управления памятью
ОС выполняет:

1.  **Трекинг**: Знает, какие части памяти свободны, а какие заняты.
2.  **Аллокация**: Выделяет память процессам по запросу (malloc/brk/mmap).
3.  **Освобождение**: Возвращает память в пул свободной.
4.  **Виртуализация**: Транслирует виртуальные адреса в физические (MMU).

### Распределитель памяти ядра (Kernel Allocator)
Отвечает за выделение небольших объектов внутри ядра (дескрипторы, структуры).
*   **Buddy System (Система двойников)**: Память делится на блоки размером $2^k$. При запросе блок делится пополам, пока не будет получен подходящий размер. Быстрое объединение при освобождении.
*   **Slab Allocator**: Кэширует объекты фиксированного размера (например, `task_struct`), чтобы избежать фрагментации и ускорить выделение.

### Оценка аллокаторов
*   **Внутренняя фрагментация**: Потери памяти внутри выделенного блока (запросили 10 байт, дали 16).
*   **Внешняя фрагментация**: Свободная память есть, но она разбита на мелкие куски, и нельзя выделить большой блок.
*   **Скорость**: Время выполнения malloc/free.

### Способы отслеживания свободной памяти
1.  **Битовые карты (Bitmaps)**: Память делится на блоки, каждому соответствует бит (0-свободно, 1-занято). Компактно, но медленный поиск.
2.  **Связанные списки (Linked Lists)**: Список свободных и занятых сегментов. Каждый элемент хранит размер и статус. Гибко, но сложнее объединять блоки.

---

## Вопрос 29: Адресные пространства. Memory mapping

### Memory Mapping (mmap)
Механизм отображения файла или устройства в виртуальное адресное пространство процесса.
*   Вместо чтения/записи файла через системные вызовы (`read`/`write`), процесс работает с файлом как с массивом в памяти.
*   **Ленивая загрузка**: Страницы файла загружаются в RAM только при обращении к ним (Page Fault).
*   **Разделяемая память**: Если несколько процессов делают mmap одного файла с флагом `MAP_SHARED`, они видят изменения друг друга и используют одни и те же физические страницы (экономия RAM).

---

## Вопрос 30: Адресные пространства. Загрузчик программ в ОС. Секции памяти программ

### Секции памяти (Сегменты)
Типичное адресное пространство процесса (снизу вверх):

1.  **Text (Code)**: Исполняемый код. Read-only, Execute.
2.  **Data**: Инициализированные глобальные переменные (`int x = 5;`). RW.
3.  **BSS**: Неинициализированные глобальные переменные (`int y;`). Заполняется нулями при запуске. Не занимает места в файле на диске.
4.  **Heap (Куча)**: Динамическая память (`malloc`). Растет вверх.
5.  **Memory Mapping Segment**: Загруженные библиотеки (.so / .dll), mmap-файлы.
6.  **Stack (Стек)**: Локальные переменные, адреса возврата. Растет вниз.

---

## Вопрос 31: Алгоритм загрузки программы (exec)

1.  **Проверка прав**: ОС проверяет, есть ли право на выполнение файла.
2.  **Чтение заголовка**: Чтение ELF/PE заголовка для определения типа файла и архитектуры.
3.  **Очистка**: Освобождение адресного пространства текущего процесса.
4.  **Создание сегментов**:
    *   Создание виртуальных сегментов (Text, Data, BSS) на основе заголовков программы.
    *   Файл программы отображается (mmap) в эти сегменты (ленивая загрузка).
5.  **Настройка стека**: Выделение стека, копирование аргументов командной строки (`argv`) и переменных окружения (`envp`) в стек.
6.  **Загрузка интерпретатора** (опционально): Если программа динамически слинкована, загружается динамический линковщик (`ld-linux.so`).
7.  **Запуск**: Установка счетчика команд (PC/RIP) на точку входа (`_start`), которая вызывает `main()`.

---

## Вопрос 32: Статическая и динамическая линковка. Достоинства и недостатки

### Статическая линковка
Весь код библиотек копируется в исполняемый файл на этапе компиляции.
*   **Плюсы**: Автономность (не нужны зависимости), немного быстрее запуск (нет резолвинга символов).
*   **Минусы**: Большой размер файла, дублирование кода в памяти (если 10 программ используют libc, будет 10 копий), сложно обновлять библиотеки (нужна перекомпиляция).

### Динамическая линковка
В файл помещаются только ссылки на библиотеки. Код подгружается при запуске.
*   **Плюсы**: Экономия диска и памяти (одна копия библиотеки в RAM для всех процессов), легкое обновление библиотек (security fixes).
*   **Минусы**: Dependency hell (нужны правильные версии .so/.dll), чуть медленнее запуск и работа (из-за косвенной адресации PLT/GOT).

### Динамическая загрузка (dlopen)
Программа сама просит ОС загрузить библиотеку в произвольный момент и получить адрес функции (`dlsym`). Используется для плагинов.

---

## Вопрос 33: Таблицы PLT и GOT

Механизм для вызова функций из динамических библиотек (где адреса неизвестны до запуска).
*   **GOT (Global Offset Table)**: Таблица в секции данных, где хранятся реальные (абсолютные) адреса функций. Заполняется динамическим загрузчиком при запуске (или при первом вызове - lazy binding).
*   **PLT (Procedure Linkage Table)**: Короткие заглушки в секции кода. Когда программа вызывает `printf`, она прыгает в `printf@plt`. Заглушка смотрит в GOT и прыгает по адресу оттуда.
    *   При первом вызове: адрес в GOT указывает обратно в загрузчик, который ищет реальную функцию, пишет адрес в GOT и вызывает её.
    *   При последующих: в GOT уже реальный адрес, происходит прямой переход.

---

## Вопрос 34: Позиционно-независимый код (PIC)

**PIC (Position Independent Code)** — код, который может работать будучи загруженным по любому адресу в памяти.
*   Необходим для разделяемых библиотек (.so), так как разные процессы могут загружать одну и ту же библиотеку в разные адреса виртуальной памяти.
*   Использует **относительную адресацию** (относительно PC/RIP) вместо абсолютной.
*   Для доступа к глобальным данным использует GOT.

---

## Вопрос 35: Общая память процессов для кооперации

**Shared Memory** — самый быстрый способ IPC (Inter-Process Communication).
*   ОС отображает одни и те же физические страницы памяти в виртуальные адресные пространства разных процессов.
*   Данные не копируются (Zero-copy).
*   **Проблема**: Гонка данных. Требуется синхронизация (семафоры, мьютексы), которые должны располагаться в этой же общей памяти или использоваться отдельно.
