# Управление памятью

Управление памятью - продолжи ... 

---

## ВОПРОС 28: Адресные пространства. Понятие свопинга. Общий принцип управления памятью операционной системой. Распределитель памяти ядра. Оценка аллокаторов. Способы отслеживания свободной памяти

### 28.1 Адресные пространства

**Адресное пространство** — это область памяти, которой может пользоваться процесс для своей работы. В современных ОС используется **виртуальное адресное пространство**.

**Виртуальная память** — это абстракция, позволяющая процессам использовать виртуальные адреса, которые ОС отображает на физические адреса в RAM или на диск. Основные свойства:

- **Защита**: Каждый процесс имеет своё адресное пространство, изолированное от других процессов
- **Переполнение**: Механизм overcommitment позволяет зарезервировать больше виртуальной памяти, чем физической RAM
- **Гибкость**: Данные могут находиться в RAM или на диске (swap), ОС прозрачно управляет этим
- **RWX права**: Каждая страница памяти может иметь права доступа (Read, Write, eXecute)

**Типовое распределение адресного пространства (x86-64 Linux)**:
- **Kernel Space** (верхние адреса): Ядро ОС, драйверы, VDSO
- **Стек** (0x7ffffffff000): Локальные переменные, параметры функций, адреса возврата
- **Heap** (растёт вверх): Динамически выделяемая память
- **Data/BSS** (статические данные): Инициализированные и неинициализированные глобальные переменные
- **Text** (код): Машинный код программы, обычно read-only
- **Адреса ввода-вывода** (нижние адреса): Для доступа к устройствам

### 28.2 Понятие свопинга

**Свопинг (Swapping)** — это механизм, позволяющий ОС выгружать неиспользуемые страницы памяти из оперативной памяти (RAM) на диск (swap file/partition) и загружать их обратно когда они снова потребуются.

**Необходимость свопинга**:
- Программа может требовать больше памяти, чем установлено в системе
- Позволяет запускать больше приложений, чем физически может вместить RAM
- Обеспечивает гибкость при работе с памятью

**Механизм работы**:
1. Когда процесс обращается к странице, которая была выгружена на диск, происходит **page fault** (аппаратное прерывание)
2. Ядро ОС перехватывает это прерывание
3. Если физическая память свободна, ядро загружает страницу с диска в RAM
4. Если физическая память занята, ядро выбирает жертву (victim page) и выгружает её на диск, освобождая место
5. Затем загружает нужную страницу
6. Процесс продолжает работу

**Недостатки**:
- Очень медленно (доступ к диску ~250 нс, к памяти ~100 нс, разница в 2500 раз)
- Может вызвать thrashing (бесконечная подкачка страниц)
- Снижает производительность системы

### 28.3 Общий принцип управления памятью ОС

**Задачи ОС при управлении памятью**:

1. **Выделение памяти**: Ядро должно выделить запрашиваемую область памяти процессу
2. **Защита**: Гарантировать, что процесс не может получить доступ к памяти других процессов
3. **Переадресация**: Преобразовать виртуальные адреса в физические адреса
4. **Подкачка**: Управлять выгрузкой/загрузкой страниц на диск
5. **Освобождение**: Вернуть память в пул доступной памяти, когда процесс завершается

**Основные уровни памяти, которыми управляет ОС**:

```
L1 Cache (3-4 цикла) ← управляет процессор
L2 Cache (10 циклов) ← управляет процессор
L3 Cache (50 циклов) ← управляет процессор
RAM (250 циклов) ← управляет ОС через MMU (Memory Management Unit)
Диск/Swap (миллионы циклов) ← управляет ОС через page faults
```

### 28.4 Распределитель памяти ядра (Kernel Allocator)

**Распределитель памяти ядра** — это компонент ядра ОС, который управляет физической памятью и выделяет её процессам и другим компонентам системы.

**Основные структуры данных**:

1. **Free List** (Список свободных блоков): Связный список блоков доступной памяти
2. **Bitmap** (Битовая карта): Каждый бит соответствует одной странице памяти
3. **Buddy System**: Память делится на блоки степеней 2, позволяет быстро найти подходящий размер

**Алгоритмы выделения памяти**:

- **First Fit**: Выделить первый найденный свободный блок подходящего размера (быстро, но фрагментация)
- **Best Fit**: Выделить наименьший свободный блок, подходящий по размеру (меньше фрагментация, но медленно)
- **Worst Fit**: Выделить самый большой свободный блок (фрагментация)
- **Next Fit**: Similar to First Fit, но начинает с позиции последнего выделения

**Buddy System** (часто используется в ядре Linux):
```
Физическая память разделена на блоки:
- Размер блока: 2^k страниц (k = 0, 1, 2, 3, ...)
- Блоки одного размера хранятся в отдельном free list
- При выделении: Найти smallest блок 2^k, который >= требуемого размера
- При освобождении: Объединить соседний блок того же размера (coalescence)
```

### 28.5 Оценка аллокаторов

**Критерии оценки эффективности аллокаторов**:

1. **Скорость выделения/освобождения**: Как быстро происходит malloc/free
2. **Внешняя фрагментация**: Разрывчивое распределение памяти между процессами
3. **Внутренняя фрагментация**: Неиспользованная память внутри выделенных блоков
4. **Пространственная локальность**: Близость выделяемых блоков в памяти
5. **Масштабируемость**: Эффективность на многоядерных системах

**Внешняя фрагментация** примеры:

```
До:   [Process1: 100KB][Free: 50KB][Process2: 100KB][Free: 50KB]
Нужно выделить 100KB, но есть только 50KB+50KB = 100KB свободной памяти
Невозможно выделить, хотя память есть → External Fragmentation

Best Fit помогает меньше
```

**Внутренняя фрагментация**:

```
Процесс запросил 33 байта, но выделили блок размером 64 байта
31 байт потерян → Internal Fragmentation
```

### 28.6 Способы отслеживания свободной памяти

**1. Свободный список (Free List)**
```c
struct FreeBlock {
    size_t size;
    struct FreeBlock *next;
};

// Выделение: пройти список, найти подходящий блок
// Освобождение: добавить блок в список (и возможно объединить с соседями)
```

Достоинства: Простота, гибкость
Недостатки: Медленный поиск (O(n)), фрагментация

**2. Битовая карта (Bitmap)**
```c
// Каждый бит = одна страница (или блок)
// 1 = занято, 0 = свободно
uint8_t bitmap[MEMORY_SIZE / 8];

// Выделение: найти первый 0-бит, установить его в 1
// Освобождение: установить соответствующий бит в 0
```

Достоинства: Быстрый поиск, простота
Недостатки: Большой размер для больших объёмов памяти

**3. Buddy System**
```
Память делится рекурсивно:
Всего 256KB
├── 128KB (занято)
└── 128KB
    ├── 64KB (свободно)
    └── 64KB
        ├── 32KB (занято)
        └── 32KB (свободно)

При выделении 32KB: берём готовый 32KB блок
При освобождении: пытаемся объединить с "buddy" блоком
```

Достоинства: Быстро находит подходящий размер, объединение (coalescence)
Недостатки: Ограничение степенями 2, внутренняя фрагментация

**4. Segregated Lists**
```c
// Разные свободные списки для разных размеров
FreeList small_blocks[32];  // для 32-64 байт
FreeList medium_blocks[32]; // для 64-128 байт
FreeList large_blocks[32];  // для > 128 байт

// При выделении: сразу знаем в какой список смотреть
```

Достоинства: Быстрое выделение, меньше фрагментация
Недостатки: Больше памяти на метаданные

**Пример из Linux ядра - использование Buddy System**:

```
В Linux используется page allocator (основан на buddy system) для выделения страниц памяти.
Существуют zone allocators для разных типов памяти (DMA, Normal, HighMem).
Также есть slub/slab allocators для выделения меньших объектов.
```

---

## ВОПРОС 29: Адресные пространства. Memory mapping

### 29.1 Концепция Memory Mapping

**Memory Mapping (Отображение в памяти)** — это техника ядра ОС, которая позволяет отобразить содержимое файла в виртуальное адресное пространство процесса, чтобы работать с ним как с обычной памятью.

**Основной принцип**:
```
Вместо использования read()/write() системных вызовов:
    char buffer[4096];
    read(fd, buffer, 4096);  // копирование данных в буфер

Можно отобразить файл в память:
    void *addr = mmap(NULL, file_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    // Теперь можно работать с данными как с массивом в памяти
    char *data = (char *)addr;
    printf("%c", data[0]);  // прямой доступ
```

### 29.2 Как работает mmap()

**Системный вызов mmap()**:
```c
void *mmap(void *addr,       // Желаемый адрес (может быть NULL)
           size_t length,    // Сколько байт отобразить
           int prot,         // Права доступа (PROT_READ, PROT_WRITE, PROT_EXEC)
           int flags,        // Флаги (MAP_SHARED, MAP_PRIVATE, MAP_ANONYMOUS)
           int fd,           // Дескриптор файла (-1 для анонимной памяти)
           off_t offset);    // Смещение внутри файла
```

**Права доступа (prot)**:
- `PROT_READ`: Разрешить чтение из отображённой памяти
- `PROT_WRITE`: Разрешить запись в отображённую память
- `PROT_EXEC`: Разрешить выполнение кода из памяти

**Флаги (flags)**:
- `MAP_SHARED`: Изменения в памяти отображаются в файл на диск (и видны другим процессам)
- `MAP_PRIVATE`: Изменения видны только этому процессу (Copy-on-Write)
- `MAP_ANONYMOUS`: Не связано с файлом, просто выделить память

### 29.3 Механизм работы

**Этап 1: Выделение виртуальной памяти**
- ОС выделяет диапазон виртуальных адресов (от `addr` до `addr + length`)
- Эти адреса связываются с файлом на диске

**Этап 2: Ленивая загрузка (Lazy Loading)**
```
При mmap() данные НЕ загружаются сразу в RAM!
Вместо этого:
1. Виртуальные адреса помечаются как "не в памяти" (page table entries показывают на диск)
2. Когда процесс обращается к адресу:
   - Происходит page fault
   - ОС загружает нужную страницу с диска в RAM
   - Процесс продолжает работу
3. Если памяти мало, ОС может выгрузить другие страницы на диск
```

**Этап 3: Синхронизация с диском**
- При `MAP_SHARED`: Изменения в памяти автоматически отражаются в файле (или через явный `msync()`)
- При `MAP_PRIVATE`: Изменения остаются в памяти, файл не меняется

**Этап 4: Освобождение**
```c
int munmap(void *addr, size_t length);  // Отменить отображение
```

### 29.4 Достоинства Memory Mapping

1. **Эффективность**: Нет необходимости копировать данные из буфера ядра в пользовательское пространство
2. **Ленивость**: Данные загружаются по мере необходимости
3. **Общая память**: Несколько процессов могут отобразить один файл и работать с общей копией
4. **Производительность**: Особенно эффективно для больших файлов
5. **Прозрачность**: Работает как обычный массив в памяти

### 29.5 Недостатки Memory Mapping

1. **Усложнение кода**: Нужно обрабатывать page faults, выравнивание адресов
2. **Несинхронность**: При `MAP_SHARED` изменения не сразу на диске (нужен `msync()`)
3. **Ограничения**: Нельзя отобразить часть файла больше, чем адресное пространство
4. **Сложность отладки**: Page faults могут быть неочевидны для программиста

### 29.6 Использование в ОС

**Примеры использования mmap() в системе**:

1. **Загрузка исполняемых файлов и библиотек**:
   ```
   При exec() ядро использует mmap() для загрузки:
   - .text секция (код) с PROT_READ|PROT_EXEC, MAP_SHARED
   - .data секция (данные) с PROT_READ|PROT_WRITE, MAP_PRIVATE
   ```

2. **Работа с большими файлами** (БД, видео):
   ```
   Вместо загрузки всего файла в RAM, отобразить его в память
   и работать как с массивом
   ```

3. **Общая память между процессами**:
   ```c
   // Процесс 1
   int fd = open("/tmp/shared_file", O_RDWR | O_CREAT);
   void *addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
   
   // Процесс 2
   int fd = open("/tmp/shared_file", O_RDWR);
   void *addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
   // Оба процесса видят одни и те же данные
   ```

---

## ВОПРОС 30: Адресные пространства. Загрузчик программ в ОС. Секции памяти программ

### 30.1 Структура ELF-файла (Executable and Linkable Format)

**ELF (Executable and Linkable Format)** — стандартный формат исполняемых файлов в Linux и других UNIX-системах.

**Структура ELF-файла**:

```
┌─────────────────────────────────────┐
│   ELF Header                        │ (заголовок)
├─────────────────────────────────────┤
│   Program Headers (Segment Table)   │ (для exec())
├─────────────────────────────────────┤
│   .text (код)                       │ ← Segment 1
├─────────────────────────────────────┤
│   .data (инициализированные данные) │ ← Segment 2
├─────────────────────────────────────┤
│   .rodata (read-only данные)        │
├─────────────────────────────────────┤
│   .bss (неинициализированные данные)│ (не в файле, разворачивается при загрузке)
├─────────────────────────────────────┤
│   .symtab (таблица символов)        │ (для линковки)
├─────────────────────────────────────┤
│   .strtab (таблица строк)           │ (имена символов)
├─────────────────────────────────────┤
│   Section Headers (Section Table)   │ (для линковщика)
└─────────────────────────────────────┘
```

**ELF заголовок** содержит:
- Магическое число: `0x7F 'E' 'L' 'F'`
- Архитектура (x86-64, ARM, MIPS, и т.д.)
- Тип (исполняемый файл, разделяемый объект, core dump)
- Точка входа (entry point) — адрес, с которого начинает выполняться код
- Позиция Program Headers

### 30.2 Секции памяти программы

**Program Segments** (используются при выполнении):

#### **1. Text Segment (.text)**
- Содержит машинный код программы
- **Права**: READ + EXECUTE (PROT_READ | PROT_EXEC)
- **Размер**: Фиксирован (не меняется во время выполнения)
- **Sharing**: Может быть shared между несколькими процессами для экономии памяти
- **Загрузка**: Отображается в память (mmap с MAP_SHARED)

```c
int foo() {
    return 42;
}
// Это будет в .text
```

#### **2. Data Segment (.data)**
- Содержит инициализированные глобальные и статические переменные
- **Права**: READ + WRITE (PROT_READ | PROT_WRITE)
- **Размер**: Фиксирован в файле
- **Sharing**: MAP_PRIVATE с Copy-on-Write
- **Загрузка**: Отображается в память (mmap с MAP_PRIVATE)

```c
int global_var = 42;          // в .data (инициализирована)
char *static_str = "hello";   // в .data
```

#### **3. BSS Segment (.bss)**
- Содержит неинициализированные глобальные и статические переменные
- **Права**: READ + WRITE
- **Размер**: НЕ хранится в файле (описание размера в заголовке)
- **Загрузка**: Выделяется в памяти при загрузке и инициализируется нулями
- **Экономия**: Сэкономливает место в файле (нули не хранятся)

```c
int uninitialized_var;  // в .bss (неинициализирована, будет 0)
static char buffer[1000000];  // в .bss (занимает место в памяти, но не в файле)
```

**Пример разницы BSS**:
```
.data segment в файле: может быть 10 KB
.bss: может быть 1000 KB, но занимает 0 байт в файле!

Размер файла = размер .text + размер .data + другие секции
На диске экономия = размер .bss
```

#### **4. Read-only Data (.rodata)**
- Строковые литералы, константы
- **Права**: READ ONLY
- **Загрузка**: MAP_SHARED (безопасно для совместного использования)

```c
const char *str = "Hello, World!";  // в .rodata
const int PI = 314159;              // в .rodata
```

#### **5. Stack (стек)**
- Локальные переменные, параметры функций, адреса возврата
- **Права**: READ + WRITE
- **Размер**: Растёт при каждом вызове функции (вниз по адресам на x86)
- **Выделение**: ОС выделяет обычно 8 MB (на Linux)

```c
void func() {
    int local_var = 100;  // в стеке
    char buffer[256];     // в стеке
}
```

#### **6. Heap (куча)**
- Динамически выделяемая память (malloc, new)
- **Права**: READ + WRITE
- **Размер**: Растёт при каждом malloc (вверх по адресам)
- **Управление**: Распределитель памяти (malloc allocator)

```c
int *ptr = malloc(sizeof(int) * 100);  // в heap
```

### 30.3 Типовое распределение адресного пространства

**На x86-64 Linux** (снизу вверх):

```
0x0000000000000000 ├─── Text Segment (.text)
                   │
0x0000000000500000 ├─── Data Segment (.data)
                   ├─── BSS Segment (.bss)
                   │
0x0000000000600000 ├─── Heap (растёт вверх →)
                   │
                   │ ... неиспользуемая область ...
                   │
0x00007fffffff0000 ├─── Stack (растёт вниз ←)
                   │
0x00007fffff000000 ├─── VDSO (Virtual Dynamic Shared Object)
                   │
0xffffffff80000000 ├─── Kernel Space
```

**Конфликты**:
- Если heap и stack встретятся → stack overflow
- Если процесс запрашивает слишком много памяти для stack или heap

---

## ВОПРОС 31: Адресные пространства. Загрузчик программ в ОС. Алгоритм загрузки программы в память и начало исполнения с точки входа

### 31.1 Системный вызов exec()

**exec()** — это системный вызов, который заменяет образ текущего процесса на новую программу.

**Основные функции exec**:
```c
// Самая используемая форма
int execve(const char *filename,        // путь к программе
           char *const argv[],          // аргументы командной строки
           char *const envp[]);         // переменные окружения

// Другие варианты (обёртки)
int execv(const char *pathname, char *const argv[]);
int execl(const char *pathname, const char *arg, ..., (char *) NULL);
int execlp(const char *file, const char *arg, ..., (char *) NULL);
```

### 31.2 Алгоритм загрузки программы (пошагово)

**Шаг 1: Проверка формата файла**

```c
// ОС читает первые 4 байта файла и проверяет магическое число
uint32_t magic = *(uint32_t*)file_data;
if (magic == 0x464C457F) {  // 0x7F 'E' 'L' 'F'
    // ELF файл
} else if (magic & 0xFFFFFF == 0x236F23) {  // #! (шебанг)
    // Скрипт, запустить интерпретатор
    // Например: #!/bin/bash → найти /bin/bash и запустить его со скриптом
} else if (magic == ...) {
    // Другие форматы (a.out, COFF)
} else {
    // Ошибка
    return ENOEXEC;
}
```

**Шаг 2: Парсинг ELF заголовка**

```c
struct ELF_Header {
    uint8_t magic[4];           // 0x7F 'E' 'L' 'F'
    uint8_t ei_class;           // 32-bit или 64-bit
    uint8_t ei_data;            // little-endian или big-endian
    uint8_t ei_version;         // версия
    uint8_t ei_osabi;           // ОС
    uint32_t e_type;            // ET_EXEC (2), ET_DYN (3) — динамический
    uint32_t e_machine;         // x86-64, ARM, MIPS, ...
    uint64_t e_entry;           // entry point (точка входа)
    uint64_t e_phoff;           // смещение Program Headers
    uint64_t e_shoff;           // смещение Section Headers
};
```

**Шаг 3: Очистка адресного пространства процесса**

```c
// ОС удаляет все страницы текущего процесса (кроме метаданных)
flush_old_address_space(current_process);
// Сохраняются: PID, PPID, файловые дескрипторы, сигнальные обработчики
```

**Шаг 4: Выделение нового адресного пространства и отображение сегментов**

```
ОС читает Program Headers и для каждого LOAD сегмента:

1. Выделить виртуальное пространство: mmap()
2. Установить права доступа (PROT_READ | PROT_WRITE | PROT_EXEC)
3. Отобразить части файла в память

Примеры:
- .text: PROT_READ | PROT_EXEC, MAP_SHARED, read-only
- .data: PROT_READ | PROT_WRITE, MAP_PRIVATE (CoW)
- .bss: Выделить память, инициализировать нулями
```

**Пример вызова mmap для каждого сегмента**:

```c
// Для .text (исполняемый код)
mmap(text_vaddr,           // виртуальный адрес из ELF
     text_size,            // размер
     PROT_READ | PROT_EXEC,
     MAP_PRIVATE | MAP_FIXED,
     fd,                   // дескриптор файла
     file_offset);         // смещение в файле

// Для .data (инициализированные данные)
mmap(data_vaddr,
     data_size,
     PROT_READ | PROT_WRITE,
     MAP_PRIVATE | MAP_FIXED,
     fd,
     file_offset);

// Для .bss (неинициализированные данные)
// Используется mmap с MAP_ANONYMOUS (без файла)
mmap(bss_vaddr,
     bss_size,
     PROT_READ | PROT_WRITE,
     MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED,
     -1,                   // нет файла
     0);
// Или просто выделить страницы памяти и очистить их нулями
```

**Шаг 5: Выделение стека**

```c
// ОС выделяет стек в верхней части адресного пространства
// На x86-64 обычно 8 MB (может меняться)
void *stack_base = 0x7ffffffff000;
int stack_size = 8 * 1024 * 1024;

mmap(stack_base - stack_size,
     stack_size,
     PROT_READ | PROT_WRITE,
     MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED,
     -1,
     0);

// Указатель стека устанавливается на вершину (конец) стека
rsp = stack_base;  // на x86-64 стек растёт вниз
```

**Шаг 6: Размещение аргументов и окружения на стеке**

```c
// На стеке размещаются (сверху вниз):
// Сначала на стеке:
//   argv[n]     ← указатель на argv[n]
//   ...
//   argv[0]     ← указатель на argv[0]
//   argc        ← количество аргументов
//   envp[m]     ← указатель на envp[m]
//   ...
//   envp[0]     ← указатель на envp[0]
//   NULL        ← конец envp
//   auxv[...]   ← auxiliary vector (для системной информации)

// Затем сами строки:
//   "/path/to/program\0"
//   "arg1\0"
//   "arg2\0"
//   "PATH=/usr/bin\0"
//   "HOME=/root\0"

// Указатели регистров:
// rdi = argc           (на x86-64)
// rsi = argv указатель
// rdx = envp указатель
```

**Шаг 7: Загрузка динамического загрузчика (если нужен)**

```c
// Если программа динамически скомпонована:

// В ELF заголовке есть поле .interp, которое указывает на загрузчик:
// Обычно "/lib64/ld-linux-x86-64.so.2"

// ОС загружает этот файл как исполняемый образ (тоже через mmap):
void *ld_base = mmap(..., "/lib64/ld-linux-x86-64.so.2");

// Точка входа будет установлена на _start функцию из загрузчика,
// а не на main программы!

// Загрузчик будет:
// 1. Найти и загрузить все нужные .so библиотеки (libc.so, и т.д.)
// 2. Разрешить символы (заполнить GOT таблицы)
// 3. Вызвать конструкторы (порядок: загрузчик → библиотеки → программа)
// 4. Передать управление на main() программы
```

**Шаг 8: Установка точки входа**

```c
// Если статическая компоновка:
entry_point = e_entry;  // точка входа из заголовка

// Если динамическая компоновка:
entry_point = ld_start;  // точка входа в загрузчик

// Установить PC (program counter) на entry_point
rip = entry_point;  // на x86-64

// Другие регистры инициализируются:
// rax = auxv указатель
// rbx = 0
// rbp = 0
```

**Шаг 9: Настройка сигналов и других параметров процесса**

```c
// Очистить обработчики сигналов (наследуются от родителя, но очищаются)
clear_signal_handlers();

// Настроить umask (маска прав файлов)
// Установить текущий рабочий каталог
// Установить пользователя и группу (если нужны специальные права)
```

**Шаг 10: Переход в пользовательский режим и начало выполнения**

```c
// ОС выполняет iret (return from exception) для перехода в user mode
// Управление передаётся программе
// Программа начинает выполнять код с entry_point

// На x86-64 обычно это:
// .../crt0.o:_start()
// ↓
// __libc_start_main()
// ↓
// Конструкторы
// ↓
// main()
```

### 31.3 Цепочка вызовов от _start до main

```c
// Файл crt0.c (C RunTime, часть libc)

// Точка входа программы
void _start(void) {
    // rsp указывает на стек с argc и argv
    
    // Получить argc из стека
    int argc = *(int *)rsp;
    
    // Получить указатель на argv
    char **argv = (char **)(rsp + 8);  // +8 для argc (8 байт на x86-64)
    
    // Получить указатель на envp
    char **envp = argv + argc + 1;      // +1 для NULL terminator
    
    // Вызвать __libc_start_main (инициализация libc)
    exit(__libc_start_main(
        (int (*)(int, char **, char **))main,  // указатель на main
        argc,                                   // количество аргументов
        argv,                                   // аргументы
        // ... другие параметры ...
        envp                                    // переменные окружения
    ));
}

// Файл libc
int __libc_start_main(
    int (*main)(int, char **, char **),
    int argc,
    char **argv,
    // ...
    char **envp)
{
    // Инициализировать библиотеку libc
    
    // Вызвать конструкторы глобальных объектов
    _init();
    
    // Вызвать main программы
    int exit_code = main(argc, argv);
    
    // Вызвать деструкторы и очистку
    _fini();
    
    // Выход
    exit(exit_code);
}
```

### 31.4 ASLR (Address Space Layout Randomization)

**ASLR** — техника безопасности, которая рандомизирует адреса различных сегментов программы, затрудняя атаки типа return-to-libc.

```
Без ASLR (предсказуемые адреса):
main: 0x0000000000400000
heap: 0x0000000000600000
libc: 0x00007ffff7a00000

С ASLR (рандомизированные адреса):
main: 0x0000555555554000 (случайная смещение)
heap: 0x0000555555757000
libc: 0x00007ffff7bcf000

Ядро выбирает случайное смещение для каждого процесса!
```

---

## ВОПРОС 32: Статическая и динамическая линковка. Динамическая загрузка библиотек. Достоинства и недостатки подходов

### 32.1 Статическая линковка

**Статическая линковка** — это процесс объединения объектных файлов в один исполняемый файл на этапе компоновки (link time), с полным разрешением всех символов.

**Процесс статической линковки**:

```
Исходный код:
└── program.c
    ├── func.c
    └── lib.c
    
         ↓ (компиляция)

Объектные файлы:
└── program.o (содержит вызовы func, lib функций)
└── func.o    (содержит определение func)
└── lib.o     (содержит определение lib)

         ↓ (статическая линковка)

Исполняемый файл:
└── program (содержит весь код: program, func, lib)
```

**Как работает линковщик (linker)**:

1. **Сбор всех объектных файлов**: program.o, func.o, lib.o
2. **Создание таблицы символов**: Найти все определённые (defined) и используемые (referenced) символы
3. **Разрешение символов**: Для каждого использования символа найти его определение
4. **Вычисление адресов**: Определить финальные адреса для каждого символа
5. **Подстановка адресов**: В машинном коде заменить плейсхолдеры на финальные адреса
6. **Объединение сегментов**: Объединить все .text, .data, .bss сегменты в один файл

**Пример с инструкциями**:

```c
// program.c
extern int add(int a, int b);  // объявление (declaration), определение в func.o

int main() {
    int result = add(5, 3);    // вызов функции add
    return 0;
}

// func.c
int add(int a, int b) {
    return a + b;
}
```

После компиляции program.o:
```
Относительный адрес    Инструкция
0x1000                 mov rdi, 5           # rdi = 5
0x1007                 mov rsi, 3           # rsi = 3
0x100e                 call <add>           # вызов (адрес неизвестен!)
                                           # Здесь стоит плейсхолдер 0x000000
0x1013                 ret
```

После линковки:
```
Абсолютный адрес    Инструкция
0x400000            mov rdi, 5
0x400007            mov rsi, 3
0x40000e            call 0x401000         # Теперь известен адрес add!
0x400013            ret

Функция add расположена по адресу 0x401000
```

**Достоинства статической линковки**:
- ✅ Высокая производительность (нет runtime разрешения символов)
- ✅ Автономность (не нужны .so библиотеки при запуске)
- ✅ Упрощённое распределение (просто скопировать исполняемый файл)
- ✅ Предсказуемость (все адреса известны на этапе компоновки)

**Недостатки статической линковки**:
- ❌ Размер файла (весь код всех библиотек встроен)
- ❌ Дублирование кода (если несколько программ используют libc, код libc скопирован N раз)
- ❌ Нерентабельность памяти (каждый процесс имеет свою копию libc)
- ❌ Сложность обновлений (чтобы обновить libc, нужно перекомпилировать всё)

### 32.2 Динамическая линковка

**Динамическая линковка** — это процесс разрешения символов во время выполнения программы (runtime), с использованием отдельных разделяемых объектов (.so файлы).

**Процесс динамической линковки**:

```
Исходный код:
└── program.c
    ├── func.c ↓ создать .so библиотеку
    └── lib.c

         ↓ (компиляция)

Объектные файлы:
└── program.o
└── func.o
└── lib.o

         ↓ (создание .so)

Разделяемый объект:
└── libfunc.so (содержит func и lib, готовый к разделению)

         ↓ (динамическая линковка)

Исполняемый файл:
└── program (содержит только program код + метаданные о зависимостях)

         ↓ (загрузка)

Память процесса:
├── program (код)
├── libfunc.so (отображается в памяти, разделяется между процессами)
└── libc.so (отображается в памяти, разделяется между процессами)
```

**Как создать разделяемый объект**:

```bash
# Компилировать с флагом -fPIC (Position Independent Code)
gcc -c -fPIC func.c -o func.o
gcc -c -fPIC lib.c -o lib.o

# Создать .so библиотеку
gcc -shared -o libfunc.so func.o lib.o
   ^^^^^^^^^               ^^^^^^
   создать .so             объектные файлы

# Скомпоновать программу с динамической линковкой
gcc -o program program.c -L. -lfunc
                              ^^^^^^
                              указывает на libfunc.so
```

**Процесс динамической загрузки (.so)**:

```
1. Выполнить программу:
   $ ./program

2. ОС выполняет exec():
   ├─ Читает ELF заголовок
   ├─ Находит .interp секцию → "/lib64/ld-linux-x86-64.so.2"
   └─ Загружает динамический загрузчик (ld.so)

3. ld.so анализирует program:
   ├─ Читает .dynamic секцию
   ├─ Находит список зависимостей: libfunc.so, libc.so
   └─ Определяет места поиска библиотек (LD_LIBRARY_PATH, /lib, /usr/lib)

4. ld.so загружает все .so библиотеки:
   ├─ mmap(libfunc.so)
   │  ├─ Загружает .text с PROT_READ | PROT_EXEC
   │  ├─ Загружает .data с PROT_READ | PROT_WRITE (MAP_PRIVATE)
   │  └─ Загружает .bss
   └─ mmap(libc.so)

5. ld.so разрешает символы (relocations):
   ├─ Для каждого использования внешнего символа
   ├─ Найти определение в загруженных библиотеках
   └─ Обновить таблицы PLT/GOT

6. ld.so передаёт управление программе:
   └─ Программа начинает выполняться как обычно
```

**Достоинства динамической линковки**:
- ✅ Компактность (библиотеки не встроены в исполняемый файл)
- ✅ Разделение памяти (все процессы используют одну копию libc в памяти)
- ✅ Обновления (обновить libc без перекомпиляции программ)
- ✅ Гибкость (можно выбирать библиотеки при запуске через LD_LIBRARY_PATH)

**Недостатки динамической линковки**:
- ❌ Сложность (нужно управлять .so файлами и LD_LIBRARY_PATH)
- ❌ Зависимости (если libfunc.so отсутствует, программа не запустится)
- ❌ Производительность (разрешение символов добавляет overhead)
- ❌ Нестабильность (изменение .so может сломать несовместимые программы)

### 32.3 Сравнение статической и динамической линковки

| Аспект | Статическая | Динамическая |
|--------|------------|-----------|
| **Размер файла** | Большой (весь код встроен) | Маленький (только ссылки) |
| **Производительность** | Быстрая (no runtime overhead) | Медленнее (разрешение символов) |
| **Разделение памяти** | Нет (каждый процесс имеет копию) | Да (все процессы share одну копию) |
| **Обновления** | Нужно перекомпилировать | Просто обновить .so |
| **Зависимости** | Нет (автономный файл) | Да (нужны .so файлы) |
| **Совместимость** | Лучше (нет dependency hell) | Хуже (версионирование) |

### 32.4 Динамическая загрузка библиотек (Runtime Loading)

**Динамическая загрузка** — загрузка .so библиотеки прямо во время выполнения программы (не только при старте).

**Функции dlopen/dlsym**:

```c
#include <dlfcn.h>

// Загрузить .so библиотеку в адресное пространство процесса
void *handle = dlopen("./libcustom.so",    // путь к библиотеке
                      RTLD_LAZY |          // ленивое разрешение символов
                      RTLD_LOCAL);         // не экспортировать символы

if (handle == NULL) {
    fprintf(stderr, "Ошибка загрузки: %s\n", dlerror());
    return -1;
}

// Получить указатель на функцию из библиотеки
typedef float (*custom_func_t)(float x);  // определить тип функции

custom_func_t my_func = (custom_func_t)dlsym(handle,           // handle .so
                                             "custom_function");  // имя функции

if (my_func == NULL) {
    fprintf(stderr, "Функция не найдена: %s\n", dlerror());
    dlclose(handle);
    return -1;
}

// Использовать функцию
float result = my_func(3.14);

// Освободить библиотеку
dlclose(handle);
```

**Флаги dlopen**:
- `RTLD_LAZY`: Разрешить символы при их использовании (ленивое разрешение)
- `RTLD_NOW`: Разрешить все символы сразу при dlopen
- `RTLD_LOCAL`: Символы из библиотеки недоступны другим dlopened библиотекам
- `RTLD_GLOBAL`: Символы из библиотеки видны всем

---

## ВОПРОС 33: Статическая и динамическая линковка. Динамическая загрузка библиотек. Таблицы PLT и GOT

### 33.1 Проблема: как вызывать функции из динамических библиотек?

**Проблема**:
1. Адреса функций в библиотеках неизвестны до загрузки (.so может быть загружен на разные адреса)
2. Секция .text открыта только на чтение (PROT_READ | PROT_EXEC), нельзя её модифицировать
3. Нужно как-то привязать вызовы функций к их фактическим адресам во время выполнения

**Решение**: Использовать два уровня косвенности — таблицы **PLT** и **GOT**

### 33.2 PLT (Procedure Linkage Table)

**PLT (Procedure Linkage Table)** — таблица в .text секции, которая содержит  "заглушки" для вызовов внешних функций.

**Структура PLT**:

```
PLT таблица в памяти процесса:

PLT[0]: (система)
    push [GOT[1]]        # Сохранить ID DLL на стеке
    jmp [GOT[2]]         # Прыгнуть на динамический загрузчик (ld.so)

PLT[1]: (для функции printf)
    jmp [GOT[3]]         # Первый раз: адрес в ld.so
                         # Позже: адрес реальной printf
    
    Затем ld.so подставляет в GOT[3] реальный адрес printf

PLT[2]: (для функции malloc)
    jmp [GOT[4]]         # Первый раз: адрес в ld.so
                         # Позже: адрес реальной malloc
    
    Затем ld.so подставляет в GOT[4] реальный адрес malloc

...
```

**Как создаёт компилятор**:

```asm
; программа вызывает: printf("Hello")

0x400000    mov rdi, 0x600b00      ; rdi = адрес строки
0x400007    call 0x400020          ; call printf (адрес PLT[1])

PLT[1] в памяти:
0x400020    jmp qword [rip + 0x1fe] ; jmp [0x402024]
                                      ; rip + 0x1fe = 0x402024
                                      ; GOT[3] находится по адресу 0x402024
```

**Важно**: Код в .text не меняется, используется косвенный прыжок через GOT!

### 33.3 GOT (Global Offset Table)

**GOT (Global Offset Table)** — таблица в .data секции, которая хранит абсолютные адреса функций и глобальных переменных.

**Структура GOT**:

```
GOT таблица в памяти процесса:

GOT[0]: адрес .dynamic (информация о динамических зависимостях)
GOT[1]: адрес link_map (информация о загруженных модулях)
GOT[2]: адрес _dl_runtime_resolve (функция в ld.so для разрешения символов)

GOT[3]: адрес printf (или адрес заглушки в ld.so до первого вызова)
GOT[4]: адрес malloc
GOT[5]: адрес strlen
...

После первого вызова printf:
GOT[3]: 0x7ffff7a4d000 (реальный адрес printf в libc.so)
```

**Содержимое GOT в ELF файле**:
- На этапе компоновки GOT содержит нули или адреса из .data сегмента
- На этапе загрузки динамический загрузчик заполняет GOT реальными адресами

### 33.4 Процесс ленивого разрешения символов (Lazy Binding)

**Ленивое разрешение (Lazy Binding)** — разрешение адреса функции происходит только при её первом вызове, не при загрузке библиотеки.

**Шаг 1: Программа вызывает функцию**

```c
int result = printf("Hello %d\n", 42);
// Компилятор генерирует:
//   call PLT[1]
```

**Шаг 2: Прыжок через PLT**

```asm
PLT[1]:
    jmp [GOT[3]]    ; на первый раз GOT[3] = адрес следующей инструкции в ld.so
    push <index>    ; index = 3 (или вычисляется из PLT индекса)
    jmp PLT[0]
```

**Шаг 3: Вызов динамического загрузчика**

```asm
PLT[0]:
    push [GOT[1]]           ; push link_map
    jmp [GOT[2]]            ; jmp _dl_runtime_resolve
    
; ld.so._dl_runtime_resolve() получает:
;   - адрес на стеке: GOT[1] (link_map)
;   - индекс функции (на стеке)
; и должна найти реальный адрес printf
```

**Шаг 4: Разрешение символа и обновление GOT**

```c
// В ld.so:
void *_dl_runtime_resolve(struct link_map *l, unsigned long index) {
    // Найти символ printf в libc.so
    void *printf_addr = find_symbol("printf", libc_so);
    
    // Обновить GOT[3] на реальный адрес
    GOT[index] = printf_addr;  // GOT[3] = 0x7ffff7a4d000
    
    // Вернуть адрес функции
    return printf_addr;
}
```

**Шаг 5: Следующий вызов функции**

```asm
; Второй раз при вызове printf:
call PLT[1]

PLT[1]:
    jmp [GOT[3]]    ; теперь GOT[3] уже содержит адрес printf!
                    ; прямой прыжок без ld.so
```

**Диаграмма процесса**:

```
Первый вызов printf:
┌──────────────┐
│ call printf  │
└───────┬──────┘
        ↓
┌──────────────┐
│  PLT[1]      │
│  jmp GOT[3]  │
└───────┬──────┘
        ↓
┌──────────────────────┐
│  GOT[3] (нулевой)    │
│  → ld.so разрешение  │
└───────┬──────────────┘
        ↓
┌──────────────────────┐
│  ld.so находит       │
│  printf в libc       │
│  адрес: 0x7fff...d   │
└───────┬──────────────┘
        ↓
┌──────────────────────┐
│  Обновить GOT[3]     │
│  GOT[3] = 0x7fff...d │
└───────┬──────────────┘
        ↓
┌──────────────┐
│  printf()    │
│  выполняется │
└──────────────┘

Второй и последующие вызовы printf:
┌──────────────┐
│ call printf  │
└───────┬──────┘
        ↓
┌──────────────┐
│  PLT[1]      │
│  jmp GOT[3]  │
└───────┬──────┘
        ↓
┌──────────────────────┐
│  GOT[3] (заполнена)  │
│  0x7fff...d →        │
│  printf() напрямую   │
└──────────────────────┘
```

### 33.5 Информация в ELF для PLT/GOT

**Секция .dynamic** (описание динамических зависимостей):

```c
// Содержится в бинарном файле, парсится ld.so
Dyn entry {
    DT_NEEDED "libc.so.6"      // зависимость от libc
    DT_INIT 0x400500           // адрес инициализации
    DT_FINI 0x400600           // адрес финализации
    DT_SYMTAB 0x400800         // адрес таблицы символов
    DT_STRTAB 0x401000         // адрес таблицы строк
    DT_PLTGOT 0x600ff0         // адрес GOT
    DT_PLTREL DT_RELA          // тип релокаций PLT
    DT_PLTRELSZ 288            // размер релокаций PLT
    ...
};
```

**Секция .rel.plt** (релокации для PLT):

```
Для каждого вызова внешней функции есть запись:
  offset: адрес в GOT
  symbol: имя функции (индекс в .symtab)
  type: тип релокации (R_X86_64_JUMP_SLOT)
  addend: дополнительное смещение

Примеры:
  offset: 0x601000   symbol: printf   type: JUMP_SLOT
  offset: 0x601008   symbol: malloc   type: JUMP_SLOT
  offset: 0x601010   symbol: strlen   type: JUMP_SLOT
```

---

## ВОПРОС 34: Статическая и динамическая линковка. Динамическая загрузка библиотек. Позиционно-независимый код (PIC)

### 34.1 Проблема: почему нужен PIC?

**Проблема**:

При статической компоновке адреса всех символов известны на compile-time и встраиваются в код:

```asm
; Статически скомпилированный код (NO PIC)
mov rax, 0x400000      ; абсолютный адрес global_var
mov rbx, 0x400500      ; абсолютный адрес another_function
call rbx
```

Но при динамической загрузке адреса библиотек не предсказуемы (ASLR):

```
Первый запуск:  libc загружена по адресу 0x7fff00000000
Второй запуск:  libc загружена по адресу 0x7fff12345678
                все встроенные абсолютные адреса стали неправильными!
```

**Решение**: Использовать **PIC (Position Independent Code)** — код, который работает независимо от того, где он загружен в памяти.

### 34.2 Позиционно-независимый код (PIC)

**PIC** — это метод компиляции, при котором код не содержит жестких абсолютных адресов, а вместо этого использует относительные адреса (RIP-relative) или косвенные обращения через таблицы (GOT).

**Создание PIC кода**:

```bash
gcc -fPIC -shared -o libexample.so example.c
         ^^^^^^^
         Position Independent Code
```

**Примеры PIC кода на x86-64**:

**NO PIC (абсолютные адреса)**:
```asm
; Неправильно для .so библиотеки
mov rax, global_var      ; embed absolute address 0x400000
add rax, 1
mov global_var, rax
```

**PIC (RIP-relative адреса)**:
```asm
; Правильно для .so библиотеки
lea rax, [rip + global_var]   ; load address relative to RIP
                              ; RIP + offset = адрес global_var
mov rbx, [rax]                ; dereferece address
add rbx, 1
mov [rax], rbx
```

**RIP-relative (Relative Instruction Pointer)**:

```
На x86-64 адреса кодируются относительно текущей инструкции (RIP).

Пример:
┌─────────────────────────────────────┐
│ Адрес в памяти  │ Инструкция        │
├─────────────────────────────────────┤
│ 0x7fff1000      │ lea rax, [rip+100]│
│                 │ RIP = 0x7fff1000  │
│                 │ адрес = 0x7fff1000 + 100 + длина инструкции
│                 │ адрес = 0x7fff1064 (примерно)
└─────────────────────────────────────┘

Важно: если код переместится (например, с 0x1000 на 0x2000),
адреса вычисляются на основе новых адресов RIP!
```

### 34.3 PLT и GOT в PIC коде

**Доступ к функции через PLT**:

```asm
; Вызов printf из PIC кода
call printf@plt          ; обращение к PLT (относительное!)
; компилятор генерирует:
; call 0x400020  (относительный адрес PLT[1])

; PLT[1] в памяти:
; 0x400020: jmp [rip + offset]  ; offset указывает на GOT[3]
; 0x400022: push 3              ; index
; 0x400027: jmp [rip + offset]  ; offset указывает на PLT[0]
```

**Доступ к глобальной переменной через GOT**:

```c
// example.c
int global_var = 42;

void func() {
    global_var = 100;
}
```

Компилируется в (с -fPIC):
```asm
; Вычислить адрес GOT
lea rax, [rip + GOT@offset]     ; load address of GOT relative to RIP
; Получить адрес global_var из GOT
mov rbx, [rax + global_var@offset]
; Установить значение
mov [rbx], 0x64                 ; 0x64 = 100
```

### 34.4 Флаг -fPIC при компиляции

**Почему -fPIC нужен при создании .so**:

```bash
# Без -fPIC (ошибка)
gcc -shared -o libfunc.so func.c
# Предупреждение:
# Warning: relocation needs to be generated for symbol "_ZN..."
# But this symbol is not in the dynamic symbol table

# С -fPIC (правильно)
gcc -fPIC -shared -o libfunc.so func.c
# Успешно
```

**Что делает -fPIC**:

1. Генерирует RIP-relative обращения вместо абсолютных адресов
2. Создаёт секцию .got.plt для PLT/GOT таблиц
3. Использует индирекцию через GOT для глобальных переменных
4. Позволяет ядру отобразить код по любому адресу

### 34.5 Copy-on-Write (CoW) в контексте PIC

**Почему MAP_PRIVATE важен**:

```
.so загружается с MAP_PRIVATE, что означает:

1. Сегмент .text (код) отображается как MAP_SHARED
   - Все процессы видят одну копию в памяти
   - Экономия памяти

2. Сегмент .data отображается как MAP_PRIVATE
   - Каждый процесс имеет свою копию глобальных переменных
   - При записи в переменную происходит CoW (копирование страницы)
```

**Пример**:

```
libc.so загружена по адресу 0x7fff00000000 для 3 процессов

.text (код):
┌──────────────┐
│ libc .text   │ ← SHARED, одна копия в памяти, все процессы видят
└──────────────┘

.data (данные):
Процесс 1:
┌──────────────┐
│ libc .data   │ ← первоначально SHARED
└──────────────┘
              ↓ (процесс 1 пишет в глобальную переменную)
              CoW: создать частную копию

Процесс 1:           Процесс 2:            Процесс 3:
┌──────────────┐   ┌──────────────┐      ┌──────────────┐
│ libc .data 1 │   │ libc .data 2 │      │ libc .data 3 │
│ (копия)      │   │ (SHARED)     │      │ (SHARED)     │
└──────────────┘   └──────────────┘      └──────────────┘
```

### 34.6 Отличия PIC от Non-PIC

| Аспект | Non-PIC | PIC |
|--------|---------|-----|
| **Абсолютные адреса** | Встроены в код | Вычисляются относительно RIP |
| **Использование в .so** | Невозможно | Стандартный способ |
| **Производительность** | Быстрее (прямые адреса) | Медленнее (косвенные обращения) |
| **ASLR** | Не совместимо | Полностью совместимо |
| **Размер кода** | Меньше | Больше (больше инструкций) |
| **Флаг компилятора** | (default, или -fno-PIC) | -fPIC |

---

## ВОПРОС 35: Общая память процессов для кооперации

### 35.1 Концепция общей памяти

**Общая память (Shared Memory)** — это механизм IPC (Inter-Process Communication), который позволяет нескольким процессам обращаться к одной и той же области памяти, обеспечивая быстрый обмен данными.

**Зачем нужна общая память**:
- Быстрый обмен между процессами (не нужны syscall для read/write)
- Синхронизация процессов (общая память + примитивы синхронизации)
- Кэширование (несколько процессов работают с одними данными)

### 35.2 Способы создания общей памяти

#### **Способ 1: POSIX Shared Memory (SHM)**

```c
#include <sys/mman.h>
#include <fcntl.h>

// Процесс 1: Создатель
int fd = shm_open("/my_shared_mem",           // имя
                   O_CREAT | O_RDWR,          // флаги
                   0666);                     // права доступа

if (fd == -1) {
    perror("shm_open");
    return -1;
}

// Установить размер
if (ftruncate(fd, 4096) == -1) {  // 4096 bytes
    perror("ftruncate");
    return -1;
}

// Отобразить в память текущего процесса
void *shared_mem = mmap(NULL,                 // адрес (auto)
                        4096,                 // размер
                        PROT_READ | PROT_WRITE,
                        MAP_SHARED,           // SHARED - видно другим
                        fd,                   // файловый дескриптор SHM
                        0);                   // смещение

if (shared_mem == MAP_FAILED) {
    perror("mmap");
    return -1;
}

// Теперь можно писать в shared_mem
sprintf((char *)shared_mem, "Hello from process 1");

// ...

// Освободить
munmap(shared_mem, 4096);
close(fd);
```

```c
// Процесс 2: Подключаемый
int fd = shm_open("/my_shared_mem",  // то же имя!
                   O_RDWR,            // только открыть
                   0);

void *shared_mem = mmap(NULL,
                        4096,
                        PROT_READ | PROT_WRITE,
                        MAP_SHARED,
                        fd,
                        0);

// Прочитать данные от процесса 1
printf("Received: %s\n", (char *)shared_mem);  // "Hello from process 1"
```

**Компиляция**:
```bash
gcc -o process1 process1.c -lrt
gcc -o process2 process2.c -lrt
                      ^^^^
                      librt (real-time) для shm_open
```

#### **Способ 2: System V IPC (shmget/shmat)**

```c
#include <sys/ipc.h>
#include <sys/shm.h>

// Процесс 1: Создатель
int shmid = shmget(IPC_PRIVATE,     // или создать с key = ftok("file", 'a')
                   4096,            // размер
                   IPC_CREAT | 0666); // создать и права

if (shmid == -1) {
    perror("shmget");
    return -1;
}

// Подключить к адресному пространству
void *shared_mem = shmat(shmid,     // идентификатор SHM
                         NULL,      // адрес (auto)
                         0);        // флаги

if (shared_mem == (void *)-1) {
    perror("shmat");
    return -1;
}

// Использовать общую память
*(int *)shared_mem = 42;

// ...

// Отключить от адресного пространства
shmdt(shared_mem);

// Удалить SHM (опционально)
shmctl(shmid, IPC_RMID, NULL);
```

```c
// Процесс 2: Подключаемый
int shmid = shmget(key,   // то же значение key!
                   4096,
                   0);    // только подключить

void *shared_mem = shmat(shmid, NULL, 0);

// Прочитать
printf("Value: %d\n", *(int *)shared_mem);  // 42
```

**Отличие от POSIX SHM**:
- Более старый стандарт (но всё ещё используется)
- Использует systemwide IPC key вместо имени
- Более сложный для отладки (требует ipcs, ipcrm)

#### **Способ 3: Memory Mapping файла (файл на диске)**

```c
#include <sys/mman.h>
#include <fcntl.h>

// Процесс 1: Создатель
int fd = open("shared_file.dat",           // файл на диске
              O_RDWR | O_CREAT | O_TRUNC,
              0666);

// Записать данные в файл
char initial_data[4096] = "Initial data";
write(fd, initial_data, 4096);

// Отобразить в память
void *shared_mem = mmap(NULL,
                        4096,
                        PROT_READ | PROT_WRITE,
                        MAP_SHARED,         // SHARED - видно другим!
                        fd,
                        0);

// Изменить данные
sprintf((char *)shared_mem, "Modified by process 1");

// Синхронизировать с диском
msync(shared_mem, 4096, MS_SYNC);
```

```c
// Процесс 2: Использует тот же файл
int fd = open("shared_file.dat", O_RDWR);

void *shared_mem = mmap(NULL,
                        4096,
                        PROT_READ | PROT_WRITE,
                        MAP_SHARED,         // SHARED - видно изменения!
                        fd,
                        0);

// Видит изменения от процесса 1
printf("Data: %s\n", (char *)shared_mem);  // "Modified by process 1"
```

**Достоинства использования файла**:
- Данные сохраняются на диск
- Не требует удаления SHM при сбое
- Проще отладка (файл доступен через ls, cat)

### 35.3 Синхронизация доступа к общей памяти

**Проблема**: Когда несколько процессов обращаются к одной памяти, могут быть race conditions.

**Решение**: Использовать примитивы синхронизации (mutex, semaphore)

#### **С использованием POSIX мьютекса**:

```c
#include <pthread.h>
#include <sys/mman.h>

// Структура в общей памяти
typedef struct {
    pthread_mutex_t mutex;   // мьютекс (должен быть PTHREAD_PROCESS_SHARED)
    int counter;
    char message[256];
} SharedData;

// Процесс 1: Инициализация
SharedData *shared = (SharedData *)mmap(...);

// ВАЖНО: Инициализировать мьютекс для межпроцессного использования
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
pthread_mutex_init(&shared->mutex, &attr);
pthread_mutexattr_destroy(&attr);

// Использование
pthread_mutex_lock(&shared->mutex);
{
    shared->counter++;
    sprintf(shared->message, "Counter: %d", shared->counter);
}
pthread_mutex_unlock(&shared->mutex);
```

```c
// Процесс 2: Чтение
SharedData *shared = (SharedData *)mmap(...);

// Прочитать с защитой мьютекса
pthread_mutex_lock(&shared->mutex);
{
    printf("Counter: %d\n", shared->counter);
    printf("Message: %s\n", shared->message);
}
pthread_mutex_unlock(&shared->mutex);
```

#### **С использованием POSIX семафора**:

```c
#include <semaphore.h>

// Процесс 1: Создание семафора
sem_t *sem = sem_open("/my_semaphore",
                      O_CREAT,
                      0666,
                      1);  // начальное значение

// Захватить семафор (ждать, если занят)
sem_wait(sem);
{
    // критическая секция
    // обращение к общей памяти
}
// Освободить семафор
sem_post(sem);
```

```c
// Процесс 2: Использование
sem_t *sem = sem_open("/my_semaphore", 0);

sem_wait(sem);
{
    // критическая секция
}
sem_post(sem);

sem_close(sem);
sem_unlink("/my_semaphore");  // удалить семафор
```

### 35.4 Практический пример: Продюсер-Консьюмер

```c
// shared.h
#ifndef __SHARED_H__
#define __SHARED_H__

#include <pthread.h>

typedef struct {
    pthread_mutex_t lock;          // мьютекс для защиты данных
    pthread_cond_t data_ready;     // условная переменная (данные готовы)
    pthread_cond_t space_available; // условная переменная (место в буфере)
    
    int buffer[100];               // буфер
    int count;                      // количество элементов
    int head, tail;                // индексы head и tail
} SharedBuffer;

#endif
```

```c
// producer.c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include "shared.h"

int main() {
    // Создать и инициализировать общую память
    int fd = shm_open("/buffer_shm", O_CREAT | O_RDWR, 0666);
    ftruncate(fd, sizeof(SharedBuffer));
    
    SharedBuffer *buf = (SharedBuffer *)mmap(NULL, sizeof(SharedBuffer),
                                             PROT_READ | PROT_WRITE,
                                             MAP_SHARED, fd, 0);
    
    // Инициализировать мьютекс и условные переменные
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&buf->lock, &attr);
    
    pthread_condattr_t cattr;
    pthread_condattr_init(&cattr);
    pthread_condattr_setpshared(&cattr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&buf->data_ready, &cattr);
    pthread_cond_init(&buf->space_available, &cattr);
    
    buf->count = 0;
    buf->head = 0;
    buf->tail = 0;
    
    // Производить данные
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&buf->lock);
        
        // Ждать, если буфер полон
        while (buf->count >= 100) {
            pthread_cond_wait(&buf->space_available, &buf->lock);
        }
        
        // Добавить данные
        buf->buffer[buf->tail] = i;
        buf->tail = (buf->tail + 1) % 100;
        buf->count++;
        
        printf("Produced: %d (buffer: %d items)\n", i, buf->count);
        
        // Оповестить потребителя
        pthread_cond_signal(&buf->data_ready);
        pthread_mutex_unlock(&buf->lock);
    }
    
    // Очистка
    munmap(buf, sizeof(SharedBuffer));
    shm_unlink("/buffer_shm");
    
    return 0;
}
```

```c
// consumer.c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include "shared.h"

int main() {
    // Открыть существующую общую память
    int fd = shm_open("/buffer_shm", O_RDWR, 0);
    
    SharedBuffer *buf = (SharedBuffer *)mmap(NULL, sizeof(SharedBuffer),
                                             PROT_READ | PROT_WRITE,
                                             MAP_SHARED, fd, 0);
    
    // Потреблять данные
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&buf->lock);
        
        // Ждать, если буфер пуст
        while (buf->count == 0) {
            pthread_cond_wait(&buf->data_ready, &buf->lock);
        }
        
        // Получить данные
        int value = buf->buffer[buf->head];
        buf->head = (buf->head + 1) % 100;
        buf->count--;
        
        printf("Consumed: %d (buffer: %d items)\n", value, buf->count);
        
        // Оповестить производителя
        pthread_cond_signal(&buf->space_available);
        pthread_mutex_unlock(&buf->lock);
        
        usleep(100);  // имитировать обработку
    }
    
    // Очистка
    munmap(buf, sizeof(SharedBuffer));
    
    return 0;
}
```

**Компиляция и запуск**:
```bash
gcc -o producer producer.c -lrt -lpthread
gcc -o consumer consumer.c -lrt -lpthread

# В одном терминале
./producer

# В другом терминале
./consumer
```

### 35.5 Сравнение методов общей памяти

| Аспект | POSIX SHM | System V IPC | Memory Mapping |
|--------|-----------|--------------|---|
| **Имя** | строка ("/name") | целое число (key) | путь файла |
| **Сохранение** | нет (RAM) | нет (RAM) | да (диск) |
| **Удаление** | автоматическое | требует IPC_RMID | автоматическое |
| **Простота** | средняя | сложнее | простая |
| **Стандарт** | POSIX (новый) | System V (старый) | POSIX/Unix |
| **Кроссплатформность** | Linux, BSD, macOS | Linux, Unix | везде |

**Рекомендация**: Использовать **POSIX SHM** для новых проектов (более современный и переносимый).

---

# ИТОГОВОЕ РЕЗЮМЕ

## Ключевые концепции управления памятью:

1. **Адресные пространства**: Виртуальная память обеспечивает абстракцию и изоляцию процессов
2. **Свопинг**: Механизм выгрузки неиспользуемых страниц на диск
3. **Аллокаторы**: Buddy system, free lists, segregated lists для управления свободной памятью
4. **Memory Mapping**: Отображение файлов в память для эффективного доступа
5. **ELF загрузка**: Сложный процесс подготовки программы к выполнению
6. **Статическая линковка**: Встроение всех библиотек в исполняемый файл
7. **Динамическая линковка**: Загрузка библиотек при запуске программы
8. **PLT/GOT**: Механизм для вызова функций из динамических библиотек
9. **PIC**: Позиционно-независимый код для возможности загрузки по любому адресу
10. **Общая память**: Механизм IPC для быстрого обмена между процессами

Все эти концепции объединяются для создания гибкой, защищённой и эффективной системы управления памятью в современных операционных системах.