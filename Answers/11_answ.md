# Сетевое программирование

Сетевое программирование - продолжи ... 

---

## Вопрос 48: Понятие сокета. Именное пространство в сети. Виды установления соединения и передачи данных. Порядок байтов, передаваемых по сети

### 48.1 Понятие сокета

#### Определение

**Сокет** (от англ. *socket* — розетка, гнездо) — это абстрактный объект в операционной системе, представляющий собой **конечную точку сетевого соединения** или канал связи между двумя процессами (локально или удаленно). Сокет служит интерфейсом между приложением и сетевым протоколом ядра операционной системы.

#### Природа сокета

Сокет можно рассматривать с нескольких точек зрения:

1. **Как канал связи** между двумя процессами (TCP-соединение или UDP-датаграмма)
2. **Как точка подключения** к сетевому стеку протоколов (TCP/IP)
3. **Как виртуальное устройство**, к которому применимы операции чтения и записи (файловые дескрипторы)
4. **Как абстракция над сетевыми протоколами**, скрывающая сложность низкоуровневых операций

#### Основные характеристики сокета

- **Дескриптор (File Descriptor):** Каждому сокету присваивается уникальный целочисленный дескриптор в таблице файловых дескрипторов процесса. Благодаря этому сокеты можно использовать с теми же операциями, что и обычные файлы (read, write, close).

- **Семейство адресов (Address Family):** Сокет связан с определённым семейством адресов:
  - `AF_INET` — IPv4
  - `AF_INET6` — IPv6
  - `AF_UNIX` — локальные Unix сокеты (Inter-process communication)
  - `AF_PACKET` — доступ к данным канального уровня (только на Linux)

- **Тип сокета (Socket Type):** Определяет модель взаимодействия:
  - `SOCK_STREAM` — потоковый сокет (TCP), надёжный, упорядоченный, ориентированный на соединение
  - `SOCK_DGRAM` — датаграммный сокет (UDP), ненадёжный, без соединения
  - `SOCK_RAW` — сырой сокет, доступ на уровне IP протокола

- **Протокол (Protocol):** Конкретный протокол (IPPROTO_TCP, IPPROTO_UDP) работающий поверх выбранного семейства адресов

- **Состояние:** Сокет находится в одном из состояний:
  - **CLOSED** — сокет только что создан, не привязан ни к чему
  - **LISTEN** — сокет ожидает входящих соединений (режим сервера)
  - **ESTABLISHED** — активное соединение, возможна передача данных
  - **TIME_WAIT** — соединение закрыто, ожидание очистки ресурсов

#### Жизненный цикл сокета

```
Создание (socket)
    ↓
Привязка (bind) — для сервера
    ↓
Прослушивание (listen) — для сервера
    ↓
Подключение (connect) — для клиента
ИЛИ
Приём соединения (accept) — для сервера
    ↓
Обмен данными (read/write)
    ↓
Закрытие (close)
```

---

### 48.2 Именное пространство в сети (Network Address Spaces)

В сетевых коммуникациях используются различные пространства адресации, образующие иерархию уровней модели TCP/IP. Эта иерархия необходима для маршрутизации пакетов через интернет и локальные сети.

#### 48.2.1 Уровень канала передачи данных (Link Layer, Layer 2)

**MAC-адреса (Media Access Control)**

- **Длина:** 48 бит (6 байт)
- **Представление:** Шесть пар шестнадцатеричных цифр, разделённых двоеточиями или дефисами
  - Пример: `00:1A:2B:3C:4D:5E` или `00-1A-2B-3C-4D-5E`

- **Структура:**
  - Первые 3 байта (24 бита): **OUI** (Organizationally Unique Identifier) — идентификатор производителя (нужен для регистрации в IEEE)
  - Последние 3 байта: Уникальный номер устройства у этого производителя

- **Область применения:** 
  - Локальные сети (LAN)
  - Коммутаторы (switches) для пересылки кадров
  - Мосты (bridges)
  - ARP (Address Resolution Protocol) — преобразование IP адресов в MAC адреса

- **Протоколы с MAC адресами:** Ethernet, Wi-Fi (802.11), Bluetooth, PPP

**Пример использования:**
```
Компьютер A (MAC: 00:11:22:33:44:55) на локальной сети
хочет отправить пакет компьютеру B (MAC: AA:BB:CC:DD:EE:FF)
→ Используется MAC адрес для доставки в пределах подсети
```

#### 48.2.2 Уровень Интернета (Internet Layer, Layer 3)

**IPv4-адреса (Internet Protocol version 4)**

- **Длина:** 32 бита (4 байта)
- **Представление:** Четыре десятичных числа, разделённые точками (dotted decimal notation)
  - Пример: `192.168.1.100`
  - Диапазон каждого октета: 0–255

- **Назначение:** Маршрутизация пакетов в глобальной сети (Интернете)

- **Структура адреса:**
  - **Сетевая часть (Network part):** Определяет подсеть
  - **Хостовая часть (Host part):** Определяет конкретный узел в подсети
  - Разделение определяется маской сети (netmask), например: `255.255.255.0` (/24 в CIDR нотации)

- **Особые адреса:**
  - `0.0.0.0` — адрес "по умолчанию"
  - `127.0.0.1` — localhost (петля, для локального тестирования)
  - `255.255.255.255` — broadcast адрес (для всей сети)
  - `224.0.0.0 – 239.255.255.255` — multicast адреса

- **Проблема:** Исчерпание адресного пространства (только ~4.3 млрд адресов)

**IPv6-адреса (Internet Protocol version 6)**

- **Длина:** 128 бит (16 байт)
- **Представление:** Восемь групп из четырёх шестнадцатеричных цифр, разделённых двоеточиями
  - Пример: `2a02:6b82:2422:0000:0000:0000:0000:0001`
  - Сокращённая запись: `2a02:6b82:2422::1` (нули могут быть опущены)

- **Преимущества над IPv4:**
  - Гораздо большее адресное пространство (~340 триллионов адресов)
  - Встроенная поддержка IPsec (криптографическая защита)
  - Упрощённая маршрутизация
  - Автоконфигурация адресов (автоматическое назначение)
  - Лучшая поддержка multicast и anycast

- **Переход:** Dual-stack системы поддерживают как IPv4, так и IPv6 одновременно

#### 48.2.3 Уровень транспорта (Transport Layer, Layer 4)

**TCP/UDP Порты**

- **Длина:** 16 бит
- **Диапазон:** 0–65535

- **Назначение:** Идентификация конкретного процесса/сервиса на хосте. Позволяет одному хосту одновременно предоставлять несколько сервисов на одном IP адресе.

- **Распределение портов:**

  | Диапазон | Название | Назначение |
  |----------|----------|-----------|
  | 0–1023 | Well-known ports | Зарезервированные системные порты, требуют root (администратор) |
  | 1024–49151 | Registered ports | Могут регистрироваться для конкретных сервисов, требуют прав в некоторых ОС |
  | 49152–65535 | Dynamic/Private ports | Динамические порты, выделяются клиентам ОС автоматически |

- **Примеры well-known портов:**
  - `20, 21` — FTP (File Transfer Protocol)
  - `22` — SSH (Secure Shell)
  - `25` — SMTP (электронная почта)
  - `53` — DNS (Domain Name System)
  - `80` — HTTP (Hypertext Transfer Protocol)
  - `443` — HTTPS (зашифрованный HTTP)
  - `3306` — MySQL
  - `5432` — PostgreSQL
  - `8080` — HTTP (альтернативный порт)

- **Пара (IP адрес + порт):** Называется **socket address** и уникально идентифицирует конечную точку сетевого соединения

#### 48.2.4 Уровень приложения (Application Layer, Layer 7)

**URI/URL адреса**

- **Используются в:** HTTP, FTP, RTMP и других протоколах приложения
- **Примеры:**
  - `http://example.com/path`
  - `ftp://user:password@ftp.example.com/file.txt`
  - `https://secure.example.com:8443/app`

- **Компоненты URL:**
  - **Схема (Scheme):** `http`, `https`, `ftp`, `file`, и т.д.
  - **Хост (Host):** Доменное имя или IP адрес
  - **Порт (Port):** Необязательно, используется по умолчанию для каждой схемы
  - **Путь (Path):** Ресурс на сервере
  - **Параметры запроса (Query):** Дополнительные данные

---

### 48.3 Виды установления соединения и передачи данных

#### 48.3.1 По способу установления соединения

**1. Connection-Oriented (Ориентированные на соединение)**

**Характеристики:**
- Перед передачей данных необходимо **явно установить соединение** между клиентом и сервером
- Используется **трёхфазный процесс** (three-way handshake):
  1. **SYN:** Клиент отправляет запрос на соединение с начальным номером последовательности
  2. **SYN-ACK:** Сервер отправляет подтверждение и свой номер последовательности
  3. **ACK:** Клиент подтверждает получение SYN от сервера

- После установления соединения данные передаются по **надёжному упорядоченному каналу**
- Соединение закрывается **явно** четырёхфазным процессом (FIN-ACK-FIN-ACK)
- Гарантирует доставку данных в правильном порядке

**Пример:** **TCP (Transmission Control Protocol)**

**Диаграмма:**
```
Клиент              Сервер
  |                  |
  |---- SYN ------->|
  |                  | (создаёт состояние соединения)
  |<--- SYN-ACK ----|
  | (знает, что сервер ответит)
  |---- ACK ------->|
  |                  |
  |<= ESTABLISHED =>|  (обе стороны готовы)
  |                  |
```

**Преимущества:**
- Надёжная доставка
- Гарантированный порядок
- Контроль потока и перегрузки

**Недостатки:**
- Задержка из-за handshake
- Больше памяти для состояния соединения

---

**2. Connectionless (Без установления соединения)**

**Характеристики:**
- Данные передаются **немедленно без предварительной подготовки**
- **Каждый пакет независим** и содержит всю необходимую информацию об отправителе и получателе
- **Нет гарантии доставки** — пакеты могут быть потеряны, дублированы или доставлены не в порядке
- Используется для передачи **независимых сообщений**
- Низкая задержка, высокая скорость

**Пример:** **UDP (User Datagram Protocol), ICMP**

**Диаграмма:**
```
Клиент              Сервер
  |                  |
  |---- Данные ----->|  (сразу, без подготовки)
  |                  |
  |---- Данные ----->|  (ещё один пакет)
  |                  |
```

**Преимущества:**
- Очень низкая задержка
- Минимальные ресурсы
- Простота реализации

**Недостатки:**
- Ненадёжность
- Нет гарантии порядка
- Требует обработки ошибок на приложении

---

#### 48.3.2 По гарантиям доставки

**1. Надёжная передача (Reliable)**

- **Гарантия:** Каждый отправленный байт доставляется ровно один раз (exactly-once semantics)
- **Механизм:** Номера последовательности, подтверждения (ACK), переиспользование потерянных пакетов
- **Проверка целостности:** Контрольные суммы обнаруживают повреждение данных
- **Пример:** TCP

**Как это работает:**
```
Отправитель                 Получатель
    |                           |
    |-- Данные (seq=1) -------->|
    |  (начинает таймер)       |
    |                           | (проверяет целостность)
    |<----- ACK (ack=101) ------|
    |  (подтверждение получено)|
    |                           |
    |-- Данные (seq=101) ------>|
    |                           |
    |  (таймер истёк)          |
    |-- Повтор (seq=1) -------->|
    |  (переиспользование)     |
    |                           |
```

---

**2. Ненадёжная передача (Unreliable)**

- **Отсутствие гарантии:** Пакеты могут быть потеряны, дублированы или доставлены не в порядке
- **Отсутствие переиспользования:** Потеря пакета означает потерю данных для приложения
- **Проверка целостности:** Может быть (на канальном уровне), но не на транспортном
- **Используется когда:** Скорость важнее надёжности (потоковое видео, аудио, игры)
- **Пример:** UDP

**Когда приемлемо:**
- Потоковое видео (потеря нескольких кадров незаметна)
- VoIP (потеря пакета ~ потеря нескольких миллисекунд аудио)
- Онлайн игры (состояние обновляется часто)
- DNS запросы (можно повторить на приложении)

---

#### 48.3.3 По режиму передачи данных

**1. Unicast (Одноадресная передача)**

- **Направление:** От одного отправителя к одному получателю
- **IP адреса:** Обычные адреса (192.168.1.1, и т.д.)
- **Использование:** Большинство интернет-приложений (веб, почта, SSH и т.д.)
- **Характеристика:** Наиболее распространённый режим

**Пример:**
```
Клиент: 192.168.1.100:45678  →  Сервер: 192.168.1.1:8080
(один-к-одному)
```

---

**2. Broadcast (Широковещание)**

- **Направление:** От одного отправителя ко всем узлам в локальной сети
- **IP адрес:** Broadcast адрес (последний адрес в подсети, обычно x.x.x.255)
- **Область:** Работает только в локальной сети (LAN), не маршрутизируется в Интернет
- **Использование:**
  - DHCP (автоматическое получение IP адреса)
  - ARP (поиск MAC адреса по IP)
  - Wake-on-LAN (пробуждение спящего компьютера)
  - Обнаружение устройств в сети

**Пример:**
```
Адрес подсети: 192.168.1.0/24
Broadcast адрес: 192.168.1.255
Отправитель: 192.168.1.100 → Broadcast: 192.168.1.255
(Все устройства в подсети получают пакет)
```

---

**3. Multicast (Групповая передача)**

- **Направление:** От одного отправителя к группе заинтересованных узлов
- **IP адреса (IPv4):** 224.0.0.0 – 239.255.255.255 (Class D)
- **IP адреса (IPv6):** ff00::/8
- **Динамическое членство:** Узлы могут присоединяться и отделяться от групп во время работы
- **Маршрутизация:** Маршрутизируется в сети (в отличие от broadcast)
- **Использование:**
  - Потоковое видео и аудио (например, IPTV)
  - Аудиоконференции (распределённые системы)
  - Системы мониторинга и логирования
  - Онлайн игры (распределение обновления состояния)

**Пример:**
```
Multicast группа: 224.1.1.1:5000
Отправитель: Отправляет видео на 224.1.1.1:5000
Слушатели: Узлы A, B, C присоединились к группе
→ Видео получают только A, B, C (не весь сегмент сети)
```

**Протокол IGMP (Internet Group Management Protocol):**
- Используется для управления членством в multicast группах
- Позволяет маршрутизаторам узнать, какие узлы в сети заинтересованы в конкретной группе

---

### 48.4 Порядок байтов при передаче по сети (Network Byte Order)

#### 48.4.1 Концепция и определение

**Порядок байтов (Endianness)** определяет, в каком порядке многобайтовые числа хранятся в памяти и передаются по сети.

**Проблема:** Разные процессоры используют разные порядки байтов. Это может привести к неправильной интерпретации данных при передаче между разными архитектурами.

**Пример проблемы:**

Передаём 32-битное число `0x12345678` (в десятичной: 305419896):

| Архитектура | Хранение в памяти | Интерпретация |
|---|---|---|
| Big-Endian | `12 34 56 78` | Правильно: `0x12345678` |
| Little-Endian | `78 56 34 12` | Неправильно: `0x78563412` |

**Решение:** Стандартизация на **Network Byte Order** = **Big-Endian**

---

#### 48.4.2 Две основные схемы

**1. Big-Endian (Большеуважаемый конец, сетевой порядок)**

- **MSB (Most Significant Byte)** находится первым (в младшем адресе памяти)
- **Представление:** Как мы обычно пишем числа (слева направо)
- **Пример:** `0x12345678` в памяти: `12 34 56 78`

- **Использование:**
  - TCP/IP протоколы (сетевой стандарт)
  - Многие RISC процессоры (PowerPC, SPARC, MIPS)
  - Java Virtual Machine (JVM)
  - Сетевые пакеты (всегда Big-Endian)

- **Преимущество:** Более интуитивен для человека при чтении шестнадцатеричных дампов сетевых пакетов

---

**2. Little-Endian (Малоуважаемый конец)**

- **LSB (Least Significant Byte)** находится первым (в младшем адресе памяти)
- **Представление:** Обратный порядок нашему письму
- **Пример:** `0x12345678` в памяти: `78 56 34 12`

- **Использование:**
  - Intel x86 и x86-64 процессоры (подавляющее большинство персональных компьютеров)
  - ARM процессоры (может быть конфигурируемо)
  - Большинство операционных систем на ПК (Windows, Linux на x86)

- **Исторически:** Intel выбрал Little-Endian для своих процессоров, и это стало де-факто стандартом в ПК индустрии

---

#### 48.4.3 Преобразование порядка байтов

При передаче данных по сети используется **Network Byte Order** (Big-Endian) **независимо от архитектуры хоста**. Это означает, что:

- На Big-Endian системе преобразование — это no-op (никакой операции)
- На Little-Endian системе нужно инвертировать порядок байтов

**Стандартные функции преобразования в Unix/Linux:**

```c
#include <arpa/inet.h>

// Host To Network — преобразование из хостового порядка в сетевой
uint32_t htonl(uint32_t hostlong);    // 32-битное число (обычно для IP адреса)
uint16_t htons(uint16_t hostshort);   // 16-битное число (обычно для портов)

// Network To Host — преобразование из сетевого порядка в хостовый
uint32_t ntohl(uint32_t netlong);     // 32-битное число
uint16_t ntohs(uint16_t netshort);    // 16-битное число
```

**Примеры функций для преобразования строк:**

```c
// Строка IP адреса → бинарный формат (с определением семейства)
int inet_pton(int af, const char *src, void *dst);
// Возвращает: 1 (успех), 0 (неверный формат), -1 (ошибка)
// Пример: inet_pton(AF_INET, "192.168.1.1", &addr.sin_addr);

// Бинарный формат → строка IP адреса
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
// Возвращает: указатель на результат, NULL при ошибке
// Пример: inet_ntop(AF_INET, &addr.sin_addr, ip_str, INET_ADDRSTRLEN);

// Старые функции (НЕ РЕКОМЕНДУЮТСЯ, deprecated):
unsigned long inet_addr(const char *cp);           // Строка → uint32_t
char *inet_ntoa(struct in_addr in);                // uint32_t → строка (НЕБЕЗОПАСНО!)
```

---

#### 48.4.4 Примеры преобразования

**Пример 1: Установка порта в структуре sockaddr_in**

```c
struct sockaddr_in server_addr;

// Неправильно (ошибка):
server_addr.sin_port = 8080;  // ❌ Очень плохо! Это Little-Endian на x86

// Правильно:
server_addr.sin_port = htons(8080);  // ✓ Правильно!
// На x86: 8080 (0x1F90) → 0x901F (в памяти: 0x1F, 0x90)
// На Big-Endian: 0x1F90 → 0x1F90 (никакого изменения)
```

**Пример 2: Преобразование IP адреса**

```c
struct sockaddr_in server_addr;

// Метод 1: inet_pton (рекомендуется, безопасен)
inet_pton(AF_INET, "192.168.1.100", &server_addr.sin_addr);
// Внутри inet_pton уже происходит преобразование в сетевой порядок!

// Метод 2: inet_addr (старый, но учебный)
server_addr.sin_addr.s_addr = inet_addr("192.168.1.100");
// Также преобразует в сетевой порядок

// Неправильно:
// server_addr.sin_addr.s_addr = 192 * 256*256*256 + 168 * 256*256 + 1 * 256 + 100;
// ❌ Это Little-Endian зависимо!
```

**Пример 3: Проверка архитектуры**

```c
uint32_t value = 0x12345678;
unsigned char *bytes = (unsigned char *)&value;

if (bytes[0] == 0x12) {
    printf("Big-Endian система\n");
} else if (bytes[0] == 0x78) {
    printf("Little-Endian система\n");
}

// Или используя встроенные макросы:
#include <endian.h>

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    printf("Little-Endian\n");
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    printf("Big-Endian\n");
#endif
```

---

#### 48.4.5 Практическое значение

**Критично для:**

- **Правильной работы с IP адресами и портами:** Все числовые значения в структурах сокетов (IPv4 адреса, порты) ВСЕГДА должны быть преобразованы в сетевой порядок перед отправкой и преобразованы обратно при получении.

- **Интеграции систем на разных архитектурах:** Когда x86 система общается с PowerPC системой, нужно убедиться, что оба преобразуют значения правильно.

- **Низкоуровневого анализа сетевых пакетов:** При анализе pcap файлов или дампов с помощью tcpdump нужно помнить, что данные в сети всегда Big-Endian.

- **Отладки сетевых приложений:** Если приложение получает неправильные данные, одна из первых проблем — неправильное преобразование порядка байтов.

---

## Вопрос 49: Протоколы TCP и UDP. Достоинства и недостатки

### 49.1 TCP (Transmission Control Protocol)

#### 49.1.1 Определение и назначение

**TCP** (Transmission Control Protocol — Протокол управления передачей) — это **основной протокол транспортного уровня (Layer 4)** модели TCP/IP. TCP обеспечивает **надёжную, упорядоченную и полнодуплексную передачу потока байтов** между двумя приложениями через Интернет.

**Место в стеке:**
```
Приложение
    ↓
   TCP (Layer 4 — Transport)
    ↓
    IP (Layer 3 — Internet)
    ↓
Ethernet (Layer 2 — Link)
    ↓
Физический уровень (Layer 1)
```

TCP реализуется как часть ядра операционной системы и работает поверх IP протокола (что иногда называют TCP over IP или TCP/IP).

#### 49.1.2 Основные характеристики TCP

**1. Надёжность доставки (Reliability)**

- **Гарантия:** Каждый отправленный байт доставляется получателю ровно один раз и целым (exactly-once, in-order semantics)
- **Механизм подтверждения (ACK):**
  - Отправитель отправляет данные с **номером последовательности (sequence number)**
  - Получатель отправляет **подтверждение (ACK)** с номером следующего ожидаемого байта
  - Если подтверждение не получено в течение **таймаута** (обычно несколько сотен миллисекунд), данные **автоматически переиспользуются (retransmitted)**

- **Контрольные суммы:** Каждый TCP сегмент содержит контрольную сумму для обнаружения ошибок на канальном уровне

**Диаграмма:**
```
Отправитель                  Получатель
    |                            |
    |-- Данные [seq=1000] ------>|
    |  (запускает таймер)       |
    |                            | (проверяет целостность)
    |<----- ACK [ack=1100] ------|
    | (100 байт получено)       |
    |                            |
    |-- Данные [seq=1100] ------>|
    |                            |
    | (таймер истёк!)           |
    |-- Данные [seq=1000] ------>| (повторно)
    |                            |
    |<----- ACK [ack=1100] ------|
```

---

**2. Ориентация на соединение (Connection-Oriented)**

- **Установление соединения:** Перед передачей данных необходимо установить соединение
- **Трёхфазный handshake (SYN-SYN/ACK-ACK):**
  1. Клиент отправляет **SYN** с начальным номером последовательности
  2. Сервер отправляет **SYN-ACK** с подтверждением и своим номером
  3. Клиент отправляет **ACK**, подтверждая получение

- **Поддержание соединения:** Соединение поддерживается на протяжении всего взаимодействия

- **Закрытие соединения:** Соединение закрывается явно четырёхфазным процессом (FIN-ACK-FIN-ACK)

**Преимущество:** Гарантирует, что обе стороны готовы к обмену данными и синхронизирует начальные номера последовательности

---

**3. Управление потоком (Flow Control)**

- **Окно управления (Window Size):** Получатель сообщает отправителю, сколько байтов он может буферизировать
- **Механизм:** Отправитель не может отправить больше данных, чем текущий размер окна получателя
- **Динамическое окно:** Получатель может изменять размер окна в зависимости от своего буфера

**Пример:**
```
Получатель: "Я готов получить 65535 байт (window size = 65535)"
Отправитель: "OK, буду отправлять не более 65535 байт без подтверждения"
Получатель получил 30000 байт: "Теперь я могу получить ещё 35535 байт"
```

**Назначение:** Предотвращает переполнение буфера получателя и регулирует скорость передачи

---

**4. Контроль перегрузки (Congestion Control)**

- **Проблема:** Если все отправители будут отправлять на максимальной скорости, сетевое оборудование (маршрутизаторы, коммутаторы) может перегрузиться

- **Решение:** TCP отправитель адаптирует размер окна (congestion window) в зависимости от состояния сети

- **Индикатор перегрузки:** Потеря пакета интерпретируется как признак перегрузки

- **Алгоритмы:**
  - **Slow Start:** Экспоненциальное увеличение окна в начале
  - **Congestion Avoidance:** Линейное увеличение окна после достижения порога
  - **Fast Retransmit:** Повторная передача при получении трёх дублированных ACK (раньше таймаута)
  - **Fast Recovery:** Восстановление после потери без полного сброса

**Результат:** Гарантирует стабильную работу сети, предотвращает её деградацию при множественных соединениях

---

**5. Полнодуплексность (Full-Duplex Communication)**

- **Двусторонность:** Данные могут передаваться одновременно в обе стороны
- **Независимость:** Каждая сторона может отправлять и получать независимо
- **Пример:** Во время загрузки файла клиент может отправлять команды серверу

---

**6. Порядок сегментов (In-Order Delivery)**

- **Номера последовательности:** Каждый сегмент TCP содержит номер последовательности
- **Переупорядочение:** Если пакеты придут не в порядке, получатель переупорядочивает их в правильный порядок перед передачей приложению
- **Дополнительная сложность:** Требует хранения "дырявых" сегментов в памяти, пока не придут недостающие

---

#### 49.1.3 TCP Handshake (Трёхфазное рукопожатие)

Процесс установления соединения (state transition from CLOSED to ESTABLISHED):

```
КЛИЕНТ                                  СЕРВЕР
(CLOSED)                               (LISTEN)
  |                                      |
  |-- SYN (seq=x) ---->               |
  | (переходит в SYN_SENT)           |
  |                                  | (переходит в SYN_RCVD)
  |                   <--- SYN-ACK (seq=y, ack=x+1) --|
  |  (SYN_SENT)                       |
  |                                      |
  |-- ACK (seq=x+1, ack=y+1) ----->  |
  | (переходит в ESTABLISHED)        | (переходит в ESTABLISHED)
  |                                      |
  |<========== СОЕДИНЕНИЕ ОТКРЫТО ==========>|
  |                                      |
```

**Шаги детально:**

1. **SYN (Synchronization) — Клиент → Сервер**
   - Флаги: `SYN=1, ACK=0`
   - Данные: 
     - `SEQ = x` (начальный номер последовательности клиента, случайное 32-битное число)
     - `MSS` (Maximum Segment Size, обычно 1460 байт для Ethernet)
     - `Window Size` (размер буфера приёма, обычно 65535)
     - Опции: scale factor для больших окон, SACK, и т.д.
   - Состояние клиента: переходит в **SYN_SENT**
   - Состояние сервера: переходит в **SYN_RCVD** (создаёт временную структуру в SYN queue)

2. **SYN-ACK (Synchronization Acknowledgement) — Сервер → Клиент**
   - Флаги: `SYN=1, ACK=1`
   - Данные:
     - `SEQ = y` (начальный номер последовательности сервера, случайное число)
     - `ACK = x+1` (подтверждение получения SYN от клиента)
     - MSS и параметры сервера
   - Состояние: сервер остаётся в **SYN_RCVD**, запускает таймер
   - Если клиент не ответит через ~60 сек, соединение будет отброшено

3. **ACK (Acknowledgement) — Клиент → Сервер**
   - Флаги: `SYN=0, ACK=1`
   - Данные:
     - `SEQ = x+1` (продолжение нумерации клиента)
     - `ACK = y+1` (подтверждение получения SYN+ACK от сервера)
   - Состояние клиента: переходит в **ESTABLISHED**
   - Состояние сервера: переходит в **ESTABLISHED**, соединение перемещается из SYN queue в Accept queue (готово для accept())
   - Важно: В этом пакете **можно уже отправлять данные приложения** (piggyback)

**Общее время:** ~2 RTT (round-trip time) от инициации до возможности передавать данные

---

#### 49.1.4 TCP Connection Termination (Четырёхфазное закрытие)

Процесс закрытия соединения:

```
КЛИЕНТ                      СЕРВЕР
  |                           |
  |-- FIN (fin=1) ----->     |
  | (FIN_WAIT_1)            | (CLOSE_WAIT)
  |                           |
  |<------ ACK (ack=1) -------|
  | (FIN_WAIT_2)              |
  |                           |
  |<------ FIN (fin=1) -------|
  | (TIME_WAIT)              | (LAST_ACK)
  |                           |
  |-- ACK (ack=1) ----->     |
  | (2 мин ожидание)         | (CLOSED)
  |                           |
  | (CLOSED)                 |
```

**Шаги:**
1. **Первая сторона отправляет FIN** — означает "я не буду больше отправлять данные"
2. **Вторая сторона отправляет ACK** — подтверждает получение FIN
3. **Вторая сторона отправляет свой FIN** — она тоже готова к закрытию
4. **Первая сторона отправляет ACK** — подтверждает получение FIN от второй стороны

**Состояние TIME_WAIT:**
- Первая сторона ждёт 2 мин (2MSL — Maximum Segment Lifetime) перед полным закрытием
- **Причина:** Гарантирует, что последний ACK доставлен (если потерян, вторая сторона может переиспользовать FIN и получить ACK)
- Это может быть проблемой при быстром перезапуске сервера (порт "занят")
- **Решение:** Использовать опцию `SO_REUSEADDR`

---

#### 49.1.5 Достоинства TCP

| Достоинство | Объяснение |
|---|---|
| **Надёжность** | Гарантирует доставку всех данных. Самовосстанавливается при потере пакетов. Идеален для критичных приложений (электронная почта, банковские транзакции, передача файлов) |
| **Упорядоченность** | Данные доставляются в правильном порядке. Приложению не требуется дополнительная обработка переупорядочения |
| **Управление потоком** | Автоматически предотвращает переполнение буфера получателя. Регулирует скорость передачи |
| **Контроль перегрузки** | Адаптирует скорость передачи к состоянию сети. Предотвращает деградацию сети |
| **Проверка ошибок** | Встроенные контрольные суммы обнаруживают повреждение данных. Автоматическое переиспользование |
| **Стандартизирован** | Широко поддерживается всеми ОС и сетевым оборудованием. Множество инструментов для отладки |
| **Безопасность соединения** | Известные адреса обеих сторон, сложнее спуфировать (подделать) соединение |

---

#### 49.1.6 Недостатки TCP

| Недостаток | Объяснение |
|---|---|
| **Более высокая задержка (Latency)** | Обработка подтверждений, переиспользование и контроль потока добавляют задержку. Трёхфазный handshake требует 1.5 RTT перед первой передачей данных. Непригоден для приложений реального времени (видеоконференции, онлайн игры требуют <100ms) |
| **Выше потребление ресурсов** | Требует больше памяти для буферизации и отслеживания состояния соединения. Каждое соединение требует отдельный процесс/поток (без мультиплексирования). Установление соединения требует вычислительных ресурсов |
| **Большие заголовки** | Заголовок TCP составляет 20-60 байт (с опциями). Высокий оверхед для небольших сообщений (например, DNS запрос ~100 байт, из них ~40 байт заголовок) |
| **Head-of-Line Blocking** | Если одного сегмента отсутствует, все последующие данные остаются в буфере до его получения. Может привести к значительной задержке при наличии потерь |
| **Сложность реализации** | TCP имеет 11+ состояний в машине состояний. Требует соответствия RFC 793 и множеству современных расширений (SACK, Window Scaling, и т.д.) |
| **Невозможность broadcast/multicast** | TCP не поддерживает отправку данных нескольким получателям одновременно |
| **Сложность коммунникации в мобильных сетях** | При смене точки доступа (handover) соединение может быть потеряно (хотя MPTCP пытается решить эту проблему) |

---

### 49.2 UDP (User Datagram Protocol)

#### 49.2.1 Определение и назначение

**UDP** (User Datagram Protocol — Протокол пользовательских датаграмм) — это **простой, ненадёжный протокол транспортного уровня**, обеспечивающий отправку **отдельных сообщений (датаграмм) без установления соединения**.

UDP используется в приложениях, где **скорость и низкая задержка важнее надёжности доставки**.

**Место в стеке:** Такое же как TCP (Layer 4), но работает "рядом" с TCP, не под ним.

#### 49.2.2 Основные характеристики UDP

**1. Отсутствие установления соединения (Connectionless)**

- **Немедленная отправка:** Данные отправляются немедленно без трёхфазного handshake
- **Каждая датаграмма независима:** Не требуется состояние соединения
- **Минимизирует начальную задержку:** Нет overhead на установление

**Пример:**
```
Клиент: "Отправить пакет на 192.168.1.1:53"
→ Отправляется немедленно (без подготовки)
```

---

**2. Ненадёжная доставка (Unreliable)**

- **Отсутствие гарантии:** Пакеты могут быть потеряны, дублированы, или доставлены не в порядке
- **Отсутствие переиспользования:** Потеря пакета означает потерю данных для приложения (приложение должно повторить запрос)
- **Отсутствие управления потоком:** Отправитель может перегрузить получателя или сеть

**Когда приемлемо:**
- Потоковое видео (потеря нескольких кадров незаметна пользователю)
- Потоковое аудио (потеря <100ms аудио незаметна)
- Онлайн игры (состояние обновляется часто, потеря одного пакета некритична)

---

**3. Неупорядоченность (No Ordering Guarantee)**

- **Пакеты могут прибыть в другом порядке:** Не существует механизма переупорядочения, как в TCP
- **Приложение отвечает за порядок:** Нужно добавить номера пакетов в приложении

**Пример:**
```
Отправлено: Пакет 1, Пакет 2, Пакет 3
Получено: Пакет 3, Пакет 1, Пакет 2  (или другой порядок)
Приложение должно обработать это
```

---

**4. Минимальный оверхед (Minimal Overhead)**

- **Заголовок UDP:** Всего **8 байт** (очень мало!)
  - Source Port (2 байта)
  - Destination Port (2 байта)
  - Length (2 байта)
  - Checksum (2 байта)

- Сравнение: TCP заголовок = 20-60 байт

- **Минимальная накладность:** На надёжность и управление потоком

**Пример с маленьким сообщением:**
```
DNS запрос: ~60 байт данных + 8 байт UDP + 20 байт IP = 88 байт
TCP версия: ~60 байт + 20 байт TCP + 20 байт IP + потребление памяти
```

---

**5. Поддержка Broadcast и Multicast (Broadcasting Support)**

- **UDP может отправлять данные всем узлам в подсети (broadcast)**
  - Адрес назначения: `x.x.x.255`
  - Используется: DHCP, ARP, Wake-on-LAN

- **UDP может отправлять группе узлов (multicast)**
  - Адреса: `224.0.0.0 – 239.255.255.255`
  - Используется: потоковое видео, аудио, системы мониторинга

- **TCP этого не поддерживает** (только unicast)

---

**6. Полнодуплексность (Full-Duplex)**

- Данные могут передаваться одновременно в обе стороны
- На одном порту можно одновременно отправлять и получать

---

#### 49.2.3 Структура UDP датаграммы

```
0        7 8       15 16      23 24      31
+--------+--------+--------+--------+
|     Source Port | Dest Port       |  (4 байта)
+--------+--------+--------+--------+
| Length | Checksum               |  (4 байта)
+--------+--------+--------+--------+
|          Данные (Payload)       |  (0-65535 байт)
|          ...                    |
+--------+--------+--------+--------+
```

**Поля:**
- **Source Port (16 бит):** Порт отправителя. Может быть 0 для простых запросов (типа DNS)
- **Destination Port (16 бит):** Порт получателя (обязателен)
- **Length (16 бит):** Длина датаграммы включая заголовок (минимум 8 байт)
- **Checksum (16 бит):** Контрольная сумма для проверки целостности (опциональна для IPv4, когда все 0 — не проверяется)
- **Payload:** Данные приложения, могут быть от 0 до 65535 байт

**Максимальный размер:**
- Теоретически: 65535 байт (из 16-битного поля Length)
- Практически: обычно ограничено MTU (Maximum Transmission Unit) сетевого интерфейса
  - Ethernet MTU = 1500 байт
  - После вычитания IP заголовка (20 байт) и UDP заголовка (8 байт) остаётся 1472 байта
  - Если датаграмма больше, ОС фрагментирует на IP уровне (опасно, может привести к потерям)

---

#### 49.2.4 Достоинства UDP

| Достоинство | Объяснение |
|---|---|
| **Низкая задержка (Low Latency)** | Отсутствие handshake — данные отправляются немедленно. Минимальная обработка в ядре ОС. RTT близко к одному сегменту времени передачи. Критично для приложений реального времени (VoIP требует <150ms latency, видеоконференции <200ms, игры <100ms) |
| **Минимальный оверхед** | Заголовок всего 8 байт (против 20+ у TCP). Меньше использование памяти (нет состояния соединения). Меньше использование CPU для обработки |
| **Поддержка Broadcast и Multicast** | Позволяет эффективно отправлять данные множеству узлов. Используется для: обнаружения сервисов (mDNS, DHCP), распределённого вещания (IPTV), систем мониторинга (Syslog, SNMP) |
| **Простота реализации** | Простая машина состояний (практически её нет). Меньше кода в ядре ОС. Проще для имплементации в embedded системах и микроконтроллерах |
| **Масштабируемость на сервере** | Сервер может обслуживать множество клиентов на одном сокете. Не требует создания отдельного процесса/потока для каждого клиента. Гораздо более эффективно при большом количестве одновременных клиентов (10000+) |
| **Без Head-of-Line Blocking** | Потеря одного пакета не влияет на доставку других. Каждая датаграмма независима |
| **Полнодуплексность** | Данные могут передаваться одновременно в обе стороны на одном сокете |

---

#### 49.2.5 Недостатки UDP

| Недостаток | Объяснение |
|---|---|
| **Ненадёжность доставки** | Нет гарантии доставки датаграмм. Потеря пакетов в сети означает потерю данных для приложения. Требует сложной обработки на уровне приложения для надёжности |
| **Неупорядоченность** | Датаграммы могут прибыть в другом порядке. Приложение должно отслеживать порядок пакетов (нужны номера последовательности в приложении). Усложняет протокол приложения |
| **Отсутствие управления потоком** | Отправитель может перегрузить получателя/сеть. Ничего не замедляет отправителя при слабом соединении. Может привести к потере пакетов и сетевой перегрузке |
| **Ограничение на размер датаграммы** | Maximum datagram size: 65535 байт (из 16-битного поля Length). На практике часто ограничено 1472 байта (из-за MTU Ethernet = 1500 - 20 IP - 8 UDP). Если данные больше, приложение должно фрагментировать и переиспользовать каждый фрагмент |
| **Требует обработки на приложении** | Приложение должно реализовать: проверку целостности данных (если нужна), переиспользование потерянных пакетов (если нужна надёжность), управление временем ожидания, упорядочение пакетов. Усложняет разработку надёжных приложений |
| **Отсутствие контроля перегрузки сети** | UDP не снижает скорость передачи при перегрузке сети. Может способствовать деградации сети для других пользователей. Требует контроля на уровне приложения |
| **Отсутствие синхронизации** | Нет механизма синхронизации начальных номеров последовательности (как в TCP handshake). Усложняет реализацию надёжного приложения |

---

### 49.3 Сравнительная таблица TCP vs UDP

| Характеристика | TCP | UDP |
|---|---|---|
| **Надёжность** | Надёжная | Ненадёжная |
| **Соединение** | Ориентирован на соединение (требует handshake) | Без соединения (отправить и забыть) |
| **Порядок пакетов** | Гарантирован (переупорядочение в ядре) | Не гарантирован (может прибыть в другом порядке) |
| **Скорость** | Медленнее (из-за надёжности и handshake) | Быстрее (минимум операций) |
| **Размер заголовка** | 20-60 байт | 8 байт |
| **Broadcast/Multicast** | Не поддерживает | Поддерживает |
| **Управление потоком** | Есть (адаптивное окно) | Нет |
| **Контроль перегрузки** | Есть (Slow Start, AIMD) | Нет (приложение отвечает) |
| **Handshake** | Требуется (3-фаза, 1.5 RTT) | Не требуется (0 RTT) |
| **Применение** | Точность и порядок > скорость | Скорость > точность |
| **Примеры** | HTTP, HTTPS, FTP, SSH, SMTP, POP3, Email | DNS, DHCP, NTP, VoIP, Video Streaming, Online Games, SNMP, Syslog |
| **Типичная задержка** | 50-200 ms (из-за handshake и retransmit) | 5-50 ms (зависит от маршрута) |
| **Масштабируемость сервера** | Хуже (соединение per client) | Лучше (один сокет для множества) |
| **Надёжность соединения** | Восстанавливается при сбоях | Потеря пакета — потеря данных |

---

### 49.4 Гибридные подходы

**Некоторые современные протоколы комбинируют лучшие черты TCP и UDP:**

- **QUIC (Quick UDP Internet Connections):**
  - Построен поверх UDP (низкая задержка)
  - Реализует надёжность, управление потоком, контроль перегрузки на уровне приложения (поверх UDP)
  - Используется в HTTP/3
  - Адрес: потоковые видео платформы (YouTube), веб-браузеры

- **SCTP (Stream Control Transmission Protocol):**
  - Ориентирован на сообщения (как UDP), но с надёжностью (как TCP)
  - Поддерживает множественные потоки и адреса
  - Используется в телекоммуникациях (3GPP)

- **DCCP (Datagram Congestion Control Protocol):**
  - Датаграммы (как UDP) с контролем перегрузки (как TCP)
  - Меньше задержка, чем TCP, но более надёжно, чем UDP
  - Используется редко

### 49.5 Выбор между TCP и UDP

**Использовать TCP когда:**
- Критична полнота и точность данных (электронная почта, банкинг, веб-приложения, передача файлов)
- Приложение требует упорядоченных данных
- Нужна защита от перегрузки сети (не хотим быть "плохим соседом")
- Требуется обрабатывать сложные сценарии надёжности

**Использовать UDP когда:**
- Критична низкая задержка (видеоконференции, онлайн-игры, VoIP, потоковое видео)
- Потеря нескольких пакетов приемлема
- Требуется Broadcast или Multicast (обнаружение сервисов, системы мониторинга)
- Высокая пропускная способность важнее надёжности (потоковое видео)
- Приложение может обработать ненадёжность (повтор на уровне приложения)
- Нужна масштабируемость на сервере для множественных клиентов

---

## Вопрос 50: Мультиплексирование. Использование fork для обработки клиентских соединений

### 50.1 Понятие мультиплексирования

#### 50.1.1 Определение

**Мультиплексирование** в контексте сетевого программирования — это метод **обработки множественных одновременных сетевых соединений одним потоком/процессом управления** без использования отдельного потока или процесса для каждого соединения.

**Проблема, которую решает мультиплексирование:**
- Как один сервер может обслуживать **1000+ одновременных клиентов** с ограниченными ресурсами?
- Создание процесса/потока для каждого клиента требует большой памяти
- Переключение контекста между процессами дорого для CPU

**Решение:** Один процесс мониторит множество сокетов и реагирует на события

---

#### 50.1.2 Типы мультиплексирования

**1. Пространственное мультиплексирование (Spatial Multiplexing)**

- Один процесс/поток обрабатывает **несколько соединений параллельно**
- Использует системные вызовы **select()**, **poll()**, **epoll()** для мониторинга нескольких сокетов
- При наступлении события (данные доступны, сокет готов для записи) управление передаётся соответствующему обработчику
- Процесс переходит между сокетами быстро (асинхронно)

**Пример:** Один веб-сервер обслуживает 10000 соединений, переключаясь между ними

---

**2. Временное мультиплексирование (Temporal Multiplexing)**

- Несколько соединений обрабатываются в **быстрой последовательности одним потоком**
- Похоже на временное разделение на мультипроцессорных системах (time-sharing)
- Используется в **асинхронных I/O моделях** (async/await в Python, JavaScript)

**Пример:** В Node.js один event loop обслуживает множество соединений, переключаясь между ними

---

#### 50.1.3 Преимущества мультиплексирования

| Преимущество | Объяснение |
|---|---|
| **Эффективность ресурсов** | Один процесс может обслуживать 100s-1000s одновременных соединений. Против подхода "один процесс на соединение", где требуется 1000+ процессов |
| **Сниженное потребление памяти** | Каждый процесс имеет собственное адресное пространство (1-10 MB на современных системах). С мультиплексированием: один процесс с буферами для множества соединений |
| **Меньше контекстных переключений** | ОС не нужно переключаться между 1000 процессов на CPU. CPU может потратить больше времени на полезную работу вместо переключения контекста |
| **Проще синхронизация** | Все соединения обрабатываются одним потоком, нет конфликтов доступа к общим данным. Не требуется мьютексы и другие примитивы синхронизации |
| **Лучшая масштабируемость** | Может обслуживать 10,000+ одновременных соединений с предсказуемой производительностью |
| **Лучше локальность данных** | Кэш CPU остаётся "горячим" для обработки событий, меньше кэш-промахов |

---

### 50.2 Модель "один процесс на соединение" с использованием fork()

#### 50.2.1 Концепция

Этот подход также называется **"Process-per-connection"** или **"Forking servers"** или **"Traditional server model"**.

**Принцип:**
- При каждом новом подключении клиента **родительский процесс (сервер) создаёт новый дочерний процесс** через вызов **fork()**
- **Дочерний процесс обслуживает этого конкретного клиента** (read/write на дочернем сокете)
- **Родитель продолжает слушать** и принимает новые соединения
- Дочерние процессы работают **независимо и параллельно**

**Преимущества:**
- Простой и понятный алгоритм
- Хорошо работает для малого-среднего числа клиентов

**Недостатки:**
- Потребление памяти (каждый процесс требует ~8 MB)
- Потребление CPU (контекстные переключения)
- Ограничение ОС (~1000 процессов обычно)

---

#### 50.2.2 Жизненный цикл

```
Сервер запущен
  |
  +-- Слушает на порте (listen)
  |
  |-- accept() ← ← ← Клиент #1 подключается
  |   (получаем сокет client_fd)
  |
  |   fork() → Дочерний процесс #1
  |   |
  |   |   (дочерний)
  |   |   ├─ close(server_fd) ← не нужен слушающий сокет
  |   |   ├─ read/write(client_fd) ← обслуживаем клиента #1
  |   |   └─ close(client_fd)
  |   |       exit(0) ← завершаем
  |   |
  |   (родитель)
  |   ├─ close(client_fd) ← не нужен этот сокет
  |   └─ accept() ← продолжаем слушать
  |       ↓
  |-- Клиент #2 подключается
  |   fork() → Дочерний процесс #2
  |   |
  |   | (обслуживает клиента #2 параллельно с #1)
  |   |
  |   └─ (параллельная обработка)
  |
  +-- Периодически вызываем waitpid() для очистки зомби процессов
```

---

#### 50.2.3 Типичный алгоритм с fork()

```pseudocode
// РОДИТЕЛЬСКИЙ ПРОЦЕСС (сервер)

1. socket() ← Создать сокет
2. bind() ← Привязать к адресу:порту  
3. listen() ← Начать слушать
4. signal(SIGCHLD, sigchld_handler) ← Установить обработчик сигнала

5. БЕСКОНЕЧНЫЙ ЦИКЛ (accept loop):
   a. accept() ← Ожидать клиента (БЛОКИРУЕТ)
   b. pid = fork()
   
      ЕСЛИ pid == 0 (дочерний процесс):
         close(server_fd) ← не нужен
         read/write(client_fd) ← обслужить клиента
         close(client_fd)
         exit(0) ← завершить
      
      ИНАЧЕ (родитель):
         close(client_fd) ← не нужен (используется в дочернем)
         ПРОДОЛЖИТЬ цикл (слушать новых клиентов)

6. close(server_fd)
```

---

#### 50.2.4 Пример реализации (C)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <signal.h>

#define PORT 8080
#define BACKLOG 5
#define BUFFER_SIZE 1024

// Обработчик сигнала SIGCHLD для очистки зомби процессов
void sigchld_handler(int sig) {
    // Неблокирующий waitpid для всех завершённых дочерних процессов
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len;
    pid_t child_pid;
    char buffer[BUFFER_SIZE];
    
    // 1. Создать сокет TCP
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket() failed");
        exit(1);
    }
    
    // 2. Настроить адрес сервера (IPv4, любой интерфейс, порт 8080)
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 0.0.0.0
    server_addr.sin_port = htons(PORT);
    
    // Позволить повторно использовать порт после перезапуска
    int reuse = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
    
    // 3. Привязать сокет (bind)
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind() failed");
        close(server_fd);
        exit(1);
    }
    
    // 4. Начать слушать (listen)
    if (listen(server_fd, BACKLOG) < 0) {
        perror("listen() failed");
        close(server_fd);
        exit(1);
    }
    
    printf("Сервер запущен на порте %d\n", PORT);
    printf("Ожидание входящих соединений...\n");
    
    // 5. Установить обработчик сигнала SIGCHLD
    signal(SIGCHLD, sigchld_handler);
    
    // 6. Основной цикл приёма соединений
    while (1) {
        client_addr_len = sizeof(client_addr);
        
        // Ожидать подключение клиента (БЛОКИРУЕТ)
        client_fd = accept(server_fd, (struct sockaddr *)&client_addr, 
                          &client_addr_len);
        
        if (client_fd < 0) {
            if (errno == EINTR) {
                // Прерван сигналом, попробуем снова
                continue;
            }
            perror("accept() failed");
            continue;
        }
        
        // Логирование входящего соединения
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        printf("[PARENT %d] Новое соединение: %s:%d\n", 
               getpid(), client_ip, ntohs(client_addr.sin_port));
        
        // Создать дочерний процесс для обслуживания клиента
        child_pid = fork();
        
        if (child_pid < 0) {
            perror("fork() failed");
            close(client_fd);
            continue;
        } 
        else if (child_pid == 0) {
            // ═══════════════════════════════════════════════
            // ДОЧЕРНИЙ ПРОЦЕСС — обслуживаем клиента
            // ═══════════════════════════════════════════════
            
            close(server_fd);  // Дочерний не слушает
            
            printf("[CHILD %d] Обслуживаю клиента %s:%d\n", 
                   getpid(), client_ip, ntohs(client_addr.sin_port));
            
            // Прочитать данные от клиента
            memset(buffer, 0, sizeof(buffer));
            ssize_t n = read(client_fd, buffer, sizeof(buffer) - 1);
            
            if (n > 0) {
                printf("[CHILD %d] Получено %ld байт: %s\n", 
                       getpid(), n, buffer);
                
                // Отправить ответ
                const char *response = "HTTP/1.0 200 OK\r\n\r\nСпасибо!\n";
                write(client_fd, response, strlen(response));
            } 
            else if (n == 0) {
                printf("[CHILD %d] Клиент закрыл соединение\n", getpid());
            } 
            else {
                perror("read() failed");
            }
            
            close(client_fd);
            printf("[CHILD %d] Завершаюсь\n", getpid());
            exit(0);  // Завершить дочерний процесс
        } 
        else {
            // ═══════════════════════════════════════════════
            // РОДИТЕЛЬСКИЙ ПРОЦЕСС — продолжаем слушать
            // ═══════════════════════════════════════════════
            
            close(client_fd);  // Родитель не работает с этим сокетом
            printf("[PARENT %d] Дочерний процесс создан: %d\n", 
                   getpid(), child_pid);
        }
    }
    
    // Очистка (редко достигается)
    close(server_fd);
    return 0;
}
```

**Компиляция и запуск:**
```bash
gcc -o fork_server fork_server.c
./fork_server

# В другом терминале:
telnet localhost 8080
# или
curl http://localhost:8080
```

---

#### 50.2.5 Проблемы с fork-based подходом

**1. Зомби процессы (Zombie Processes)**

**Что такое зомби?**
- Когда дочерний процесс завершается (exit), его статус остаётся в таблице процессов ядра
- Ожидается, что родитель прочитает этот статус (вызовом waitpid или wait)
- Если родитель не вызывает waitpid, процесс остаётся в состоянии "зомби" (undead)

**Проблемы:**
- Зомби процессы занимают место в таблице процессов
- Таблица может переполниться, сервер не сможет принять новые соединения
- В ps они показываются как `<defunct>`

**Решение:**
```c
// Способ 1: Обработчик сигнала SIGCHLD
void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);  // Собираем всех зомби
}
signal(SIGCHLD, sigchld_handler);

// Способ 2: Проверка в основном цикле
while (waitpid(-1, NULL, WNOHANG) > 0);  // Периодически очищать

// Способ 3: Игнорировать SIGCHLD (ОС сам очистит)
signal(SIGCHLD, SIG_IGN);
```

---

**2. Потребление ресурсов (Resource Consumption)**

- **Память:** Каждый процесс требует ~8 MB памяти (stack, kernel structures)
- **При 1000 клиентов:** ~8 GB памяти только на стеки процессов
- **На современном сервере:** Может быть приемлемо, но не масштабируется

**Пример:**
```
1 000 000 соединений × 8 MB = 8 ТБ памяти
(практически невозможно)
```

---

**3. Контекстные переключения (Context Switches)**

- **Дорого:** Переключение контекста требует ~1000 циклов CPU (на современных системах ~0.5 мкс)
- **При 10000 процессов:** ОС постоянно переключается, CPU тратит 30-50% на само переключение
- **Результат:** Низкая производительность при большом числе соединений

---

**4. Сложность синхронизации (Synchronization Complexity)**

- **Общие данные:** Если нужна глобальная информация (счётчики, состояние), требуется IPC (Inter-Process Communication)
- **Дочерние процессы:** Имеют **отдельные адресные пространства**, не могут просто обновить переменную родителя
- **Решение:** Использовать файлы, pipes, shared memory, или сокеты

**Пример проблемы:**
```c
int counter = 0;  // Глобальный счётчик

fork();
if (child) {
    counter++;  // Увеличивает копию в дочернем процессе
}
// В родителе counter всё ещё 0 ✗
```

---

**5. Ограничения ОС (OS Limits)**

- **Максимальное число процессов:** Обычно 1000-10000 (зависит от ОС и RAM)
- **Таблица файловых дескрипторов:** Ограничена (обычно 1024 файлов на процесс)
- **Проверить:** `ulimit -n` (файловые дескрипторы), `ulimit -u` (процессы)

```bash
# Увеличить лимиты на Linux
ulimit -n 65536  # 65536 файловых дескрипторов
ulimit -u 100000 # 100000 процессов
```

---

#### 50.2.6 Когда fork-based подход работает хорошо

- **Малое число одновременных соединений (<100):** Хорошая производительность
- **Долгоживущие соединения:** Когда клиент долго подключён (долгие задачи)
- **Простая логика обслуживания:** Без глобального состояния
- **Надёжность:** Crash дочернего процесса не влияет на сервер
- **Чистота кода:** Каждый процесс имеет свой стек/контекст

**Примеры серверов, использующих fork:**
- Apache (prefork MPM — до недавно)
- Traditional FTP servers
- Some mail servers

---

### 50.3 Сравнение fork-подхода с мультиплексированием

| Параметр | Fork-based | Multiplexing (select/poll/epoll) |
|---|---|---|
| **Макс соединений** | ~1000 | ~10,000-100,000+ |
| **Потребление памяти** | High (8MB per процесс) | Low (основной процесс + буферы) |
| **Контекстные переключения** | High (O(n) переключений) | Low (O(1) на событие) |
| **Сложность реализации** | Простая (привычный стиль) | Сложнее (асинхронный стиль) |
| **Синхронизация** | Автоматическая (разные процессы) | Требует внимания (один поток) |
| **Отладка** | Легче (можно использовать debugger) | Сложнее (асинхронный код) |
| **Отказоустойчивость** | Crash клиента не влияет на сервер | Crash влияет на всех клиентов |
| **Подходит для** | <100 клиентов, долгоживущие соединения | 1000+ клиентов, короткие запросы |
| **Примеры** | Apache prefork, traditional servers | Nginx, Node.js, Libevent-based servers |
| **CPU использование** | ~30-50% на переключения (при 10000 процессов) | ~1-2% на процессы (сам обработчик ~10-20%) |

---

### 50.4 Заключение fork-подхода

Fork-based approach исторически был первым и стандартным способом обработки множественных соединений на Unix (1970s-1990s). Это был правильный выбор, когда:
- Было только несколько десятков соединений на сервер
- Память была дорогой
- Многопроцессность была основным примитивом

**Однако, в эру Интернета (2000s+):**
- Веб-серверы должны обслуживать 10,000-1,000,000 одновременных соединений
- Память дешева, но контекстные переключения дорого
- Эффективность CPU критична

**Современные серверы используют мультиплексирование** (особенно epoll на Linux) для обслуживания десятков тысяч клиентов с минимальным расходом ресурсов.

---

## Вопрос 51: Мультиплексирование. Системные вызовы select, poll, epoll

### 51.1 Введение в мультиплексирование

Мультиплексирование — это механизм, позволяющий **одному процессу одновременно мониторить несколько сокетов** и реагировать на события (читаемость, записываемость, ошибки) **без блокирования**.

Три основных системных вызова реализуют мультиплексирование:
1. **select()** — портативный, работает на всех POSIX системах, ограничен ~1024 дескрипторами
2. **poll()** — улучшение select(), работает на Unix-like системах, нет ограничения на количество
3. **epoll()** — Linux-специфичный, высокопроизводительный, O(1) сложность

---

### 51.2 select()

#### 51.2.1 Синтаксис и назначение

```c
#include <sys/select.h>

int select(int nfds, 
           fd_set *restrict readfds,
           fd_set *restrict writefds,
           fd_set *restrict exceptfds,
           struct timeval *restrict timeout);
```

**Назначение:** Мониторить до ~1024 файловых дескрипторов на событие и вернуть, когда какой-нибудь из них готов.

**Параметры:**

| Параметр | Объяснение |
|---|---|
| **nfds** | Наибольший файловый дескриптор + 1. select() проверяет дескрипторы от 0 до nfds-1. Обычно: `max_fd + 1` |
| **readfds** | Указатель на набор дескрипторов для проверки на **читаемость** (данные доступны для чтения). Может быть NULL. Результат содержит только готовые дескрипторы |
| **writefds** | Указатель на набор дескрипторов для проверки на **записываемость** (буфер готов к записи). Может быть NULL. Результат содержит только готовые дескрипторы |
| **exceptfds** | Указатель на набор дескрипторов для проверки на **исключительные условия** (например, срочные данные OOB). Редко используется. Может быть NULL |
| **timeout** | Максимальное время ожидания:<br>• NULL: ждать бесконечно (блокирующий режим)<br>• {0, 0}: не ждать, немедленно вернуться (polling)<br>• {N, M}: ждать N секунд и M микросекунд |

**Возвращаемое значение:**

| Значение | Смысл |
|---|---|
| **> 0** | Количество дескрипторов, готовых для операции (сумма по всем трём набором) |
| **= 0** | Timeout истёк, никакие дескрипторы не готовы |
| **< 0 (ошибка)** | Ошибка (errno установлен). Обычно EINTR (прерван сигналом) |

---

#### 51.2.2 Работа с fd_set (набор дескрипторов)

**fd_set** — это битовое множество дескрипторов (обычно массив из 32 целых чисел, поддерживает до ~1024 дескрипторов).

```c
#include <sys/select.h>

// Макросы для работы с fd_set
void FD_ZERO(fd_set *set);           // Очистить набор (все биты в 0)
void FD_SET(int fd, fd_set *set);    // Добавить дескриптор fd в набор
void FD_CLR(int fd, fd_set *set);    // Удалить дескриптор fd из набора
int  FD_ISSET(int fd, fd_set *set);  // Проверить, есть ли fd в наборе (!=0 если есть)
```

**Важно:** fd_set **модифицируется** функцией select()! Она устанавливает биты только готовых дескрипторов и очищает остальные.

---

#### 51.2.3 Структура таймаута

```c
#include <sys/time.h>

struct timeval {
    time_t tv_sec;          // Секунды
    suseconds_t tv_usec;    // Микросекунды (0-999999)
};

// Примеры:
struct timeval tv;

// Ждать 5 секунд
tv.tv_sec = 5;
tv.tv_usec = 0;

// Ждать 100 миллисекунд
tv.tv_sec = 0;
tv.tv_usec = 100000;  // 100 ms = 100000 µs

// Ждать 1 микросекунду
tv.tv_sec = 0;
tv.tv_usec = 1;

// Немедленно вернуться (polling без ожидания)
tv.tv_sec = 0;
tv.tv_usec = 0;
```

**Опасность:** На некоторых системах `timeval` модифицируется select() (остаточное время). Лучше переинициализировать перед каждым вызовом.

---

#### 51.2.4 Типичный паттерн использования select()

```c
#include <stdio.h>
#include <sys/select.h>
#include <unistd.h>

int main() {
    int max_fd = 10;  // Наибольший fd + 1
    fd_set readfds, writefds;
    struct timeval timeout;
    int activity;
    
    while (1) {
        // 1. Очистить наборы
        FD_ZERO(&readfds);
        FD_ZERO(&writefds);
        
        // 2. Добавить интересующие дескрипторы
        FD_SET(0, &readfds);       // stdin
        FD_SET(server_fd, &readfds);  // слушающий сокет
        FD_SET(client_fd, &readfds);  // клиентский сокет
        
        // 3. Установить таймаут
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        
        // 4. Вызвать select()
        activity = select(max_fd + 1, &readfds, &writefds, NULL, &timeout);
        
        if (activity < 0) {
            if (errno == EINTR) {
                continue;  // Прерван сигналом, повторить
            }
            perror("select() failed");
            break;
        }
        
        if (activity == 0) {
            printf("Timeout: нет активности\n");
            continue;
        }
        
        // 5. Проверить, какие дескрипторы готовы
        if (FD_ISSET(0, &readfds)) {
            printf("stdin готов для чтения\n");
            // handle stdin
        }
        
        if (FD_ISSET(server_fd, &readfds)) {
            printf("Входящее соединение\n");
            // accept()
        }
        
        if (FD_ISSET(client_fd, &readfds)) {
            printf("Данные от клиента\n");
            // read()
        }
    }
    
    return 0;
}
```

---

#### 51.2.5 Достоинства select()

| Достоинство | Объяснение |
|---|---|
| **Портативность** | Стандарт POSIX, работает на всех Unix-like системах (Linux, BSD, macOS, Solaris, и т.д.) и также Windows |
| **Простота использования** | Прямолинейный API, легко понять логику. Макросы FD_* просты для использования |
| **Микросекундная точность** | Структура timeval позволяет задавать таймауты с микросекундной точностью (хотя ОС может не гарантировать эту точность) |
| **Универсальность** | Работает не только с сокетами, но и с обычными файловыми дескрипторами (pipes, файлы, и т.д.) |
| **Стабильность** | Долго используется, хорошо изучена, мало проблем |

---

#### 51.2.6 Недостатки select()

| Недостаток | Объяснение |
|---|---|
| **Ограничение на количество дескрипторов** | На многих системах максимум ~1024 дескрипторов (определяется FD_SETSIZE, обычно 1024). Нельзя проверить дескрипторы с номерами >=1024, даже если ОС их поддерживает. Это было большой проблемой в эру высоконагруженных серверов |
| **Неэффективность при большом числе дескрипторов** | O(n) алгоритм: ядро должно проверить **все** дескрипторы в наборе каждый раз, даже если события на малой части. Если мониторим 1000 дескрипторов, select() проверит все 1000 каждый раз |
| **Модификация аргументов** | fd_set наборы модифицируются select() — содержат только готовые дескрипторы. Нужно **восстанавливать наборы перед каждым вызовом** (FD_ZERO и FD_SET). Легко забыть, и тогда приложение сломается |
| **Отсутствие приоритетов** | Нельзя указать приоритет между дескрипторами — нет гарантии порядка обработки событий |
| **Сложность масштабирования** | Использование select() на дескрипторах с большими номерами (например, 10000) приводит к переполнению памяти (fd_set очень большая) и медленной работе |

---

### 51.3 poll()

#### 51.3.1 Синтаксис и назначение

```c
#include <poll.h>

int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd {
    int fd;           // Файловый дескриптор для проверки (-1 чтобы игнорировать)
    short events;     // События для проверки (маска битов)
    short revents;    // События, которые произошли (результат)
};
```

**Назначение:** Мониторить произвольное количество файловых дескрипторов (нет ограничения как в select()).

**Преимущество над select():**
- Нет ограничения на количество дескрипторов
- revents отделены от events (не нужно восстанавливать)
- Миллисекундная точность таймаута (вместо микросекундной, но проще)

**Параметры:**

| Параметр | Объяснение |
|---|---|
| **fds** | Массив структур pollfd, каждая описывает один дескриптор |
| **nfds** | Количество элементов в массиве |
| **timeout** | Максимальное время ожидания в **миллисекундах**:<br>• -1 = ждать бесконечно<br>• 0 = не ждать (polling)<br>• N > 0 = ждать N миллисекунд |

**Возвращаемое значение:**
- **> 0:** Количество структур, у которых revents != 0
- **= 0:** Timeout истёк
- **< 0:** Ошибка

---

#### 51.3.2 События (маски)

```c
// События для поля events (что мониторить):

POLLIN      // Данные доступны для чтения (или EOF)
POLLPRI     // Срочные данные доступны для чтения (OOB)
POLLOUT     // Сокет готов для записи (буфер не заполнен)
POLLERR     // Ошибка на дескрипторе (не нужно указывать в events, автоматически отслеживается)
POLLHUP     // Закрытие соединения с другой стороны (hang-up, EOF)
POLLNVAL    // Недействительный дескриптор

// Примеры использования:
pollfd[0].events = POLLIN;              // Проверить готовность к чтению
pollfd[1].events = POLLOUT;             // Проверить готовность к записи
pollfd[2].events = POLLIN | POLLOUT;    // Проверить оба события
pollfd[3].events = 0;                   // Не проверять события (но revents может быть POLLERR)
```

---

#### 51.3.3 Примеры использования poll()

```c
#include <stdio.h>
#include <poll.h>
#include <stdlib.h>

#define MAX_CLIENTS 100
#define BUFFER_SIZE 1024

int main() {
    struct pollfd fds[MAX_CLIENTS];
    int num_fds = 0;
    char buffer[BUFFER_SIZE];
    
    // Инициализировать слушающий сокет
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    bind(server_fd, ...);
    listen(server_fd, 5);
    
    // Добавить слушающий сокет в массив
    fds[0].fd = server_fd;
    fds[0].events = POLLIN;  // Мониторить входящие соединения
    num_fds = 1;
    
    while (1) {
        // Подождать события (2 секунды timeout)
        int activity = poll(fds, num_fds, 2000);
        
        if (activity < 0) {
            perror("poll() failed");
            break;
        }
        
        if (activity == 0) {
            printf("Timeout: нет активности\n");
            continue;
        }
        
        // Проверить каждый дескриптор
        for (int i = 0; i < num_fds; i++) {
            if (fds[i].revents == 0) continue;  // Нет событий на этом fd
            
            // ПОЛИНВАРИ входящего соединения
            if (i == 0 && (fds[i].revents & POLLIN)) {
                int client_fd = accept(server_fd, ...);
                
                if (num_fds < MAX_CLIENTS) {
                    fds[num_fds].fd = client_fd;
                    fds[num_fds].events = POLLIN | POLLOUT;
                    num_fds++;
                    printf("Клиент подключился, всего: %d\n", num_fds - 1);
                }
            }
            // ОБРАБОТКА данных от клиента
            else if (fds[i].revents & POLLIN) {
                ssize_t n = read(fds[i].fd, buffer, sizeof(buffer) - 1);
                
                if (n <= 0) {
                    // Соединение закрыто
                    printf("Клиент отключился\n");
                    close(fds[i].fd);
                    // Переместить последний элемент сюда
                    if (i < num_fds - 1) {
                        fds[i] = fds[num_fds - 1];
                    }
                    num_fds--;
                    i--;  // Переработать этот индекс
                } else {
                    printf("Получено: %s", buffer);
                    write(fds[i].fd, "OK\n", 3);
                }
            }
            
            // ОБРАБОТКА ошибок
            if (fds[i].revents & POLLERR) {
                printf("Ошибка на сокете %d\n", fds[i].fd);
                close(fds[i].fd);
                if (i < num_fds - 1) {
                    fds[i] = fds[num_fds - 1];
                }
                num_fds--;
                i--;
            }
        }
    }
    
    close(server_fd);
    return 0;
}
```

---

#### 51.3.4 Достоинства poll()

| Достоинство | Объяснение |
|---|---|
| **Нет ограничения на FD_SETSIZE** | Может проверять неограниченное количество дескрипторов (теоретически столько, сколько может быть в системе) |
| **Лучший API** | revents отделены от events, не нужно восстанавливать наборы. Просто добавили fd в массив и вызвали poll |
| **Миллисекундная точность таймаута** | Более удобно, чем структура timeval в select(). Просто целое число миллисекунд |
| **Портативность** | Доступен на всех POSIX системах (Unix-like) |
| **Масштабируемость** | Может использоваться со множеством дескрипторов (1000+), хотя и остаётся O(n) как select() |

---

#### 51.3.5 Недостатки poll()

| Недостаток | Объяснение |
|---|---|
| **Неэффективность при большом числе дескрипторов** | O(n) алгоритм, как и select(). Ядро должно проверить **все** дескрипторы в массиве. При 10000 дескрипторов это медленно |
| **Отсутствие приоритетов** | Нельзя управлять порядком обработки событий |
| **Не работает на Windows** | Специфичен для Unix-like систем (Linux, BSD, macOS, Solaris) |
| **Сложность управления массивом** | Нужно аккуратно управлять массивом pollfd (добавлять/удалять элементы, переиндексировать) |

---

### 51.4 epoll() (Linux-специфичный)

#### 51.4.1 Введение

**epoll** (event poll) — это **Linux-специфичный механизм** для эффективного мультиплексирования очень большого числа файловых дескрипторов. Был введён в **Linux 2.5.44 (2003)**.

**Основное улучшение:** **O(1) сложность** вместо O(n) в select() и poll().

**Как это работает:**
- ОС **хранит список готовых дескрипторов** отдельно
- Вместо проверки всех дескрипторов каждый раз, epoll возвращает только готовые
- Добавляет дескриптор один раз, получает события по мере их появления

---

#### 51.4.2 API Epoll

```c
#include <sys/epoll.h>

// Создать epoll экземпляр (контекст)
int epoll_create(int size);            
// size больше не используется (>0), остался для совместимости
// Возвращает fd epoll'а, который используется в остальных вызовах

int epoll_create1(int flags);           
// Более новый вариант (Linux 2.6.27+)
// flags: 0 или EPOLL_CLOEXEC (close-on-exec)

// Добавить/удалить/изменить дескриптор в epoll
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

// Ждать событий
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

// Структура события
struct epoll_event {
    uint32_t events;       // Маска событий (EPOLLIN, EPOLLOUT и т.д.)
    epoll_data_t data;     // Пользовательские данные
};

typedef union epoll_data {
    void *ptr;             // Указатель на пользовательские данные (например, структуру соединения)
    int fd;                // Файловый дескриптор
    uint32_t u32;          // 32-битное целое число
    uint64_t u64;          // 64-битное целое число
} epoll_data_t;
```

---

#### 51.4.3 Операции epoll_ctl()

```c
// Операции (op):
EPOLL_CTL_ADD    // Добавить дескриптор fd в epoll'е epfd
EPOLL_CTL_DEL    // Удалить дескриптор fd из epoll'а epfd
EPOLL_CTL_MOD    // Изменить события для дескриптора fd

// События (маски):
EPOLLIN         // Данные доступны для чтения (включает EOF)
EPOLLOUT        // Сокет готов для записи (буфер не полный)
EPOLLPRI        // Срочные данные для чтения (OOB)
EPOLLERR        // Ошибка на дескрипторе (автоматически мониторится, не нужно указывать)
EPOLLHUP        // Закрытие соединения (автоматически мониторится)
EPOLLET         // Edge-triggered режим (см. ниже)
EPOLLONESHOT    // One-shot режим: событие отключается после epoll_wait() (см. ниже)
EPOLLRDNORM     // Нормальные данные для чтения (обычно = EPOLLIN)
EPOLLRDBAND     // Данные out-of-band для чтения (обычно = EPOLLPRI)
EPOLLWRNORM     // Нормальная запись (обычно = EPOLLOUT)
```

---

#### 51.4.4 Режимы epoll

**1. Level-triggered (LT) — Уровень сигнала (по умолчанию)**

- **Поведение:** epoll сообщает о событии **каждый раз**, когда вызывается epoll_wait(), если событие **ещё активно**
- **Похоже:** На poll() и select()
- **Безопасность:** Безопаснее — даже если забыли прочитать все данные, следующий epoll_wait() снова сообщит
- **Производительность:** Может быть медленнее на некоторых сценариях (много spurious wakeups)

**Пример:**
```
Приходит 10 байт на сокет → EPOLLIN срабатывает
Читаем 5 байт, оставляем 5 в буфере
Вызываем epoll_wait() снова
→ EPOLLIN срабатывает ещё раз (5 байт остались)
```

---

**2. Edge-triggered (ET) — Срез сигнала**

- **Поведение:** epoll сообщает о событии **только один раз** — при переходе от "не-события" к "событию" (сигнальный срез/edge)
- **Более эффективно:** Уменьшает количество epoll_wait() вызовов
- **Требует:** **Неблокирующий I/O** и обработки всех данных за один раз (до EAGAIN)
- **Сложность:** Легко сделать ошибку (забыть прочитать всё)

**Пример:**
```
Приходит 10 байт → EPOLLIN срабатывает ОДИН раз
Читаем 5 байт, оставляем 5
Вызываем epoll_wait() снова
→ EPOLLIN НЕ срабатывает (уже был сигнальный срез)
Приходит ещё 5 байт
→ EPOLLIN срабатывает снова (новый срез!)
```

**Правило для ET:** Всегда читайте/пишите в цикле до EAGAIN/EWOULDBLOCK:

```c
// Правильно с ET:
while (1) {
    ssize_t n = read(fd, buffer, sizeof(buffer));
    if (n < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            break;  // Больше нет данных
        }
        perror("read");
        break;
    }
    if (n == 0) break;  // EOF
    // обработать n байт
}

// Неправильно с ET:
ssize_t n = read(fd, buffer, sizeof(buffer));
// Если было 10 байт и буфер 5, прочитаем только 5
// Остальные 5 не будут обработаны до новых данных!
```

---

#### 51.4.5 Пример использования epoll()

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <netinet/in.h>
#include <errno.h>

#define PORT 8080
#define MAX_EVENTS 100
#define BUFFER_SIZE 4096

// Сделать сокет неблокирующим
void set_nonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

int main() {
    int server_fd, epfd, n_events, i;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len;
    struct epoll_event event, events[MAX_EVENTS];
    char buffer[BUFFER_SIZE];
    
    // Создать и инициализировать слушающий сокет
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    set_nonblocking(server_fd);  // Неблокирующий режим
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);
    
    int reuse = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
    
    bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_fd, 5);
    
    printf("Сервер слушает на порте %d (epoll)\n", PORT);
    
    // Создать epoll экземпляр
    epfd = epoll_create1(0);
    if (epfd < 0) {
        perror("epoll_create1() failed");
        exit(1);
    }
    
    // Добавить слушающий сокет в epoll (level-triggered по умолчанию)
    event.events = EPOLLIN;
    event.data.fd = server_fd;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, server_fd, &event) < 0) {
        perror("epoll_ctl() failed to add server_fd");
        exit(1);
    }
    
    printf("Ожидание входящих соединений...\n");
    
    while (1) {
        // Подождать событий (5 секунд)
        n_events = epoll_wait(epfd, events, MAX_EVENTS, 5000);
        
        if (n_events < 0) {
            if (errno == EINTR) continue;  // Прерван сигналом
            perror("epoll_wait() failed");
            break;
        }
        
        if (n_events == 0) {
            printf("Timeout: нет активности\n");
            continue;
        }
        
        // Обработать события
        for (i = 0; i < n_events; i++) {
            if (events[i].data.fd == server_fd) {
                // ════════════════════════════════════════
                // ВХОДЯЩЕЕ СОЕДИНЕНИЕ
                // ════════════════════════════════════════
                
                while (1) {  // Принять все входящие (NB mode)
                    client_addr_len = sizeof(client_addr);
                    int client_fd = accept(server_fd,
                                         (struct sockaddr *)&client_addr,
                                         &client_addr_len);
                    
                    if (client_fd < 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            break;  // Нет больше входящих соединений
                        }
                        perror("accept() failed");
                        break;
                    }
                    
                    set_nonblocking(client_fd);
                    
                    char client_ip[INET_ADDRSTRLEN];
                    inet_ntop(AF_INET, &client_addr.sin_addr, 
                             client_ip, INET_ADDRSTRLEN);
                    printf("Подключился клиент: %s:%d (fd=%d)\n",
                           client_ip, ntohs(client_addr.sin_port), client_fd);
                    
                    // Добавить клиента в epoll (edge-triggered)
                    event.events = EPOLLIN | EPOLLET;  // Edge-triggered!
                    event.data.fd = client_fd;
                    epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &event);
                }
            } 
            else {
                // ════════════════════════════════════════
                // ДАННЫЕ ОТ КЛИЕНТА (Edge-triggered mode)
                // ════════════════════════════════════════
                
                int client_fd = events[i].data.fd;
                
                if (events[i].events & EPOLLIN) {
                    // Читать ВСЕ доступные данные (ET режим требует this!)
                    while (1) {
                        memset(buffer, 0, sizeof(buffer));
                        ssize_t n = read(client_fd, buffer, sizeof(buffer) - 1);
                        
                        if (n > 0) {
                            printf("[fd=%d] Получено %ld байт: %s\n", 
                                   client_fd, n, buffer);
                            write(client_fd, "OK\n", 3);
                        } 
                        else if (n == 0) {
                            // EOF — клиент закрыл соединение
                            printf("[fd=%d] Клиент отключился (EOF)\n", client_fd);
                            epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                            close(client_fd);
                            goto next_event;
                        } 
                        else if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // Нет больше данных (ожидаемо в NB mode)
                            break;
                        } 
                        else {
                            perror("read() failed");
                            epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                            close(client_fd);
                            goto next_event;
                        }
                    }
                }
                
                if (events[i].events & EPOLLERR) {
                    printf("[fd=%d] Ошибка на сокете\n", client_fd);
                    epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                    close(client_fd);
                }
                
                if (events[i].events & EPOLLHUP) {
                    printf("[fd=%d] Hang-up на сокете\n", client_fd);
                    epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                    close(client_fd);
                }
                
                next_event:;
            }
        }
    }
    
    epoll_ctl(epfd, EPOLL_CTL_DEL, server_fd, NULL);
    close(epfd);
    close(server_fd);
    return 0;
}
```

**Компиляция:**
```bash
gcc -o epoll_server epoll_server.c
./epoll_server
```

---

#### 51.4.6 Достоинства epoll()

| Достоинство | Объяснение |
|---|---|
| **Масштабируемость** | **O(1) сложность** — время epoll_wait() не зависит от числа мониторимых дескрипторов (только от числа готовых событий). Может эффективно обрабатывать 10,000-100,000+ одновременных соединений |
| **Производительность** | Очень быстро. Используется в высокопроизводительных серверах (Nginx, libevent, libev, Redis) |
| **Гибкость режимов** | Level-triggered (безопасно) и Edge-triggered (эффективно) режимы |
| **Объединение данных** | epoll_data может хранить пользовательские данные (указатель на структуру соединения), не нужно отдельное отображение fd → состояние |
| **Поддержка больших чисел fd** | Нет ограничения на количество дескрипторов (теоретически столько, сколько ОС может открыть) |
| **One-shot режим** | EPOLLONESHOT позволяет обрабатывать событие только один раз, полезно для многопоточных серверов |

---

#### 51.4.7 Недостатки epoll()

| Недостаток | Объяснение |
|---|---|
| **Linux-специфичность** | Не работает на других Unix системах (BSD, macOS, Solaris) и Windows. Требует abstraction layer для портативности (libevent, libev, Boost.Asio) |
| **Сложность Edge-triggered режима** | ET требует неблокирующего I/O и тщательной обработки EAGAIN/EWOULDBLOCK. Легко сделать ошибку (забыть прочитать все данные) |
| **Ограничения на некоторые файлы** | Не работает со всеми типами файлов (особенно обычные файлы на диске). Работает только с "живыми" источниками (сокеты, pipes, fifo) |
| **Сложность отладки** | Асинхронный код сложнее отлаживать (чем полнодупlex fork подход). Требует хороших знаний о событиях и их обработке |

---

### 51.5 Сравнительная таблица select, poll, epoll

| Параметр | select | poll | epoll |
|---|---|---|---|
| **Сложность алгоритма** | O(n) | O(n) | **O(1)** |
| **Макс дескрипторов** | ~1024 (FD_SETSIZE) | Неограничено | Неограничено |
| **Портативность** | POSIX (все Unix) | POSIX (Unix только) | Только Linux |
| **Модификация параметров** | Да (fd_set модифицируется) | Нет (revents отдельно) | Нет (отдельный массив events) |
| **Таймаут** | microseconds (timeval) | milliseconds (int) | milliseconds (int) |
| **Специальные режимы** | — | — | LT, ET, ONESHOT |
| **Простота использования** | Простая | Средняя | Сложнее (требует NB I/O) |
| **Подходит для** | <100 соединений, портативность | 100-1000 соединений | 1000+ соединений (Linux) |
| **Примеры использования** | Портативные приложения (OpenSSL, curl) | Небольшие серверы | Nginx, Redis, Node.js (libuv) |
| **Производительность** | Слаба при большом n | Хуже чем epoll | Отличная |
| **Сложность кода** | Простой | Средний | Более сложный (особенно ET) |

---

### 51.6 Рекомендации по выбору

**Использовать select() когда:**
- Критична **портативность** (BSD, macOS, Solaris, Windows)
- Число соединений < 100
- Простота кода важнее производительности
- Работаете с обычными файлами (select работает с любыми fd)

**Использовать poll() когда:**
- На Unix системах нужно > 1024 дескрипторов
- Число соединений 100-1000
- Простота API важнее микрооптимизаций
- Нужна большая портативность чем epoll (но не на Windows)

**Использовать epoll() когда:**
- На Linux для высокопроизводительных приложений
- Число соединений 1000+
- Максимальная производительность критична
- Используйте abstraction library (libevent, libev, Boost.Asio) для портативности

---

## Вопрос 52: Алгоритм инициализации сокета на сервере. Алгоритм инициализации сокета на клиенте

(Продолжение в части 2 — получился слишком большой файл)

---

## Вопрос 53: Алгоритм установления соединения клиента с сервером. Алгоритм принятия соединения сервером от клиента

(Этот вопрос будет добавлен позже)

---

**Этот файл содержит подробные ответы на вопросы 48-53 из билетов по сетевому программированию. Ответы приближены к учебникам, содержат примеры кода, диаграммы и объяснения всех ключевых концепций.**

