# Сетевое программирование

**Сетевое программирование** — это создание программного обеспечения, компоненты которого взаимодействуют друг с другом через компьютерную сеть. Оно включает в себя использование сетевых протоколов (TCP/IP), адресацию и обмен данными между процессами на удаленных узлах.

---

## Вопрос 48: Понятие сокета. Именное пространство в сети. Виды установления соединения и передачи данных. Порядок байтов, передаваемых по сети

### Понятие сокета
**Сокет** — это программный интерфейс (абстрактный объект) для обеспечения информационного обмена между процессами.
*   Для приложения сокет — это файловый дескриптор, с которым можно работать функциями `read`/`write`.
*   Сокет определяется парой: **IP-адрес + номер порта**.

### Именное пространство
Для адресации в сетях TCP/IP используется иерархия:
1.  **MAC-адрес** (Канальный уровень): Физический адрес сетевой карты (48 бит). Используется внутри локальной сети.
2.  **IP-адрес** (Сетевой уровень): Логический адрес узла в сети (IPv4 — 32 бита, IPv6 — 128 бит).
3.  **Порт** (Транспортный уровень): Число (16 бит), идентифицирующее конкретный процесс/службу на хосте.

### Виды установления соединения и передачи
**По установлению соединения**:
*   **С установлением соединения (Connection-oriented, TCP)**: Гарантирует создание логического канала перед передачей данных.
*   **Без установления соединения (Connectionless, UDP)**: Данные посылаются получателю без предварительной проверки его готовности.

**По типу адресации**:
*   **Unicast** (один-к-одному).
*   **Broadcast** (один-ко-всем в подсети).
*   **Multicast** (один-к-группе).

### Порядок байтов
Разные архитектуры процессоров хранит многобайтовые числа по-разному:
*   **Little-Endian** (Intel x86): Младший байт по младшему адресу.
*   **Big-Endian** (Сетевой порядок, Network Byte Order): Старший байт по младшему адресу.

В заголовках пакетов IP/TCP/UDP всегда используется **Big-Endian**.
Функции преобразования:
*   `htons()` / `htonl()`: Host to Network (Short/Long).
*   `ntohs()` / `ntohl()`: Network to Host (Short/Long).

---

## Вопрос 49: Протоколы TCP и UDP. Достоинства и недостатки

### TCP (Transmission Control Protocol)
Протокол управления передачей. Ориентирован на соединение, обеспечивает надежную доставку потока байтов.
*   **Достоинства**:
    *   Гарантия доставки (автоматический повтор потерянных пакетов).
    *   Сохранение порядка следования данных.
    *   Контроль потока (Flow Control) и перегрузки (Congestion Control).
*   **Недостатки**:
    *   Высокие накладные расходы (заголовок мин. 20 байт, процедура Handshake).
    *   Задержки передачи (из-за подтверждений и таймаутов).
    *   Не поддерживает Broadcast/Multicast.

### UDP (User Datagram Protocol)
Протокол пользовательских датаграмм. Не ориентирован на соединение.
*   **Достоинства**:
    *   Минимальные накладные расходы (заголовок 8 байт).
    *   Высокая скорость (нет задержек на установление соединения и подтверждения).
    *   Поддержка Broadcast и Multicast.
*   **Недостатки**:
    *   Ненадежность (пакеты могут теряться, дублироваться).
    *   Нет гарантии порядка (пакеты могут приходить вразнобой).
    *   Нет контроля перегрузки сети.

---

## Вопрос 50: Мультиплексирование. Использование fork для обработки клиентских соединений

### Мультиплексирование
Технология, позволяющая одному процессу одновременно обрабатывать несколько потоков ввода-вывода (соединений). Вместо блокирования на чтении одного сокета, процесс опрашивает множество сокетов и работает с теми, где есть данные.

### Модель с использованием fork()
Классическая модель "Один процесс — одно соединение".
**Алгоритм**:
1.  Сервер слушает порт (`listen`).
2.  При входящем соединении (`accept`) сервер делает системный вызов `fork()`.
3.  **Родительский процесс**: Закрывает дескриптор соединения, продолжает ждать новых клиентов.
4.  **Дочерний процесс**: Закрывает слушающий сокет, обрабатывает запрос клиента, затем завершается.

**Плюсы**: Изоляция клиентов (ошибка в одном не роняет сервер), простота кода.
**Минусы**: Ресурсоемкость (на каждого клиента создается копия процесса), медленное переключение контекста, ограничение по числу процессов в ОС.

---

## Вопрос 51: Мультиплексирование. Системные вызовы select, poll, epoll

### select
Старейший системный вызов. Использует битовые маски (`fd_set`) для отслеживания дескрипторов.
*   **Ограничения**: Максимальное число дескрипторов ограничено константой `FD_SETSIZE` (обычно 1024).
*   **Сложность**: $O(N)$ — при каждом вызове нужно перебирать все биты и копировать маски из user-space в kernel-space и обратно.

### poll
Использует массив структур `pollfd`.
*   **Отличия от select**: Нет жесткого лимита в 1024 дескриптора.
*   **Сложность**: $O(N)$ — при вызове ядро проходит по всему списку, чтобы проверить события. Эффективность падает линейно с ростом числа соединений.

### epoll (Linux)
Событийно-ориентированный механизм.
*   **Принцип**: Дескрипторы добавляются в ядро один раз (`epoll_ctl`). Вызов `epoll_wait` возвращает список *только тех* сокетов, где произошли события.
*   **Сложность**: $O(1)$ относительно общего числа соединений. Самый эффективный метод для HighLoad серверов (Nginx, Node.js).
*   **Режимы**:
    *   **Level Triggered (LT)**: Сообщает о событии, пока данные есть в буфере.
    *   **Edge Triggered (ET)**: Сообщает о событии только один раз при поступлении данных.

---

## Вопрос 52: Алгоритм инициализации сокета на сервере. Алгоритм инициализации сокета на клиенте

### Алгоритм на сервере (TCP)
1.  **`socket()`**: Создание сокета (получение файлового дескриптора). Указывается домен (IPv4/IPv6) и тип (STREAM для TCP).
2.  **`bind()`**: Привязка сокета к локальному IP-адресу и порту.
3.  **`listen()`**: Перевод сокета в режим ожидания входящих соединений. Создается очередь запросов на подключение.

### Алгоритм на клиенте (TCP)
1.  **`socket()`**: Создание сокета.
2.  (Опционально) **`bind()`**: Обычно не используется, ОС сама назначает свободный порт и IP интерфейса.

---

## Вопрос 53: Алгоритм установления соединения клиента с сервером. Алгоритм принятия соединения сервером от клиента

### Установление соединения клиентом
1.  Клиент вызывает **`connect(socket, address)`**.
2.  Отправляется **SYN**-пакет серверу.
3.  Клиент ждет **SYN-ACK** и отправляет **ACK** (TCP 3-way handshake).
4.  Если успешно, функция возвращает 0, канал готов к `read`/`write`.

### Принятие соединения сервером
1.  Сервер вызывает **`accept(listen_socket)`**.
2.  Функция блокирует выполнение (или возвращает ошибку в non-blocking), пока в очереди `listen` не появится полностью установленное соединение (после завершения handshake).
3.  `accept` возвращает **новый** файловый дескриптор для связи с конкретным клиентом. Слушающий сокет остается свободным для приема новых.
