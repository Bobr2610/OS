# Страничная организация памяти

Страничная организация памяти - продолжи ... 

--- 

## Вопрос 36: Виртуальная память. Общие положения. Таблица страниц. TLB. Поддержка большого объема памяти

### 1. Виртуальная память. Общие положения

#### Определение и назначение виртуальной памяти

Виртуальная память — это механизм управления памятью, который позволяет процессам работать с адресным пространством, которое может быть больше физической оперативной памяти (ОЗУ). Процесс обращается к виртуальным адресам, которые автоматически преобразуются в физические адреса памяти при помощи аппаратного обеспечения (Memory Management Unit — MMU).

#### Основные принципы виртуальной памяти

1. **Трансляция адресов**: Виртуальный адрес, используемый процессом, должен быть преобразован в физический адрес оперативной памяти.

2. **Изоляция процессов**: Каждый процесс имеет собственное виртуальное адресное пространство, что обеспечивает защиту и изоляцию от других процессов.

3. **Прозрачность**: Процесс не знает о трансляции адресов — она происходит автоматически и прозрачно.

4. **Расширение памяти**: Виртуальная память позволяет использовать дисковое пространство как расширение оперативной памяти.

#### Преимущества виртуальной памяти

- Позволяет процессам работать с большим адресным пространством, чем физическая память
- Обеспечивает защиту памяти между процессами
- Упрощает управление памятью для программистов
- Позволяет эффективно использовать физическую память

---

### 2. Страничная организация памяти

#### Концепция пагинга (paging)

Пагинг — это метод реализации виртуальной памяти, при котором:
- Виртуальное адресное пространство разделяется на **страницы** (pages) — блоки одинакового размера, обычно 4096 байт (4 KB)
- Физическая память разделяется на **блоки памяти** (page frames) — блоки того же размера
- Каждая виртуальная страница может быть отображена на любой физический блок памяти

#### Структура виртуального адреса в системе с пагингом

Виртуальный адрес обычно делится на две части:

```
Виртуальный адрес: [номер_страницы : смещение_в_странице]
```

Для 32-битной системы с размером страницы 4096 байт (2^12):
- **Номер страницы (Page number)**: биты 12-31 (20 битов) → может адресовать 2^20 = 1,048,576 страниц
- **Смещение в странице (Page offset)**: биты 0-11 (12 битов) → адресует байты внутри 4 KB страницы

**Пример**: Виртуальный адрес 0x00403004
- Номер страницы: 0x403 (1027 в десятичной)
- Смещение: 0x004 (4 в десятичной)
- Смещение указывает на 4-й байт в странице 1027

#### Преобразование адресов

Процесс трансляции:
1. Виртуальный адрес разбивается на номер страницы и смещение
2. Номер страницы используется как индекс в **таблице страниц**
3. Таблица страниц возвращает номер блока памяти (page frame number)
4. Физический адрес формируется как: `[номер_блока_памяти : смещение]`

---

### 3. Таблица страниц (Page Table)

#### Структура таблицы страниц

Таблица страниц содержит записи (page table entries — PTE), каждая из которых содержит:

**Основные поля записи таблицы страниц:**

| Поле | Размер | Назначение |
|------|--------|-----------|
| **Номер блока памяти (PFN)** | Обычно ~20 битов | Физический адрес, на который отображена виртуальная страница |
| **Бит присутствия (Present)** | 1 бит | Указывает, находится ли страница в физической памяти (1) или на диске (0) |
| **Бит модификации (Modified/Dirty)** | 1 бит | Указывает, была ли страница изменена (1) или нет (0) |
| **Бит доступа (Accessed)** | 1 бит | Указывает, была ли страница недавно прочитана или записана |
| **Бит записи (Write)** | 1 бит | Указывает, разрешена ли запись в страницу (1) или только чтение (0) |
| **Бит выполнения (Execute)** | 1 бит | Указывает, может ли код быть выполнен из этой страницы |
| **Резервные биты** | Различные | Для будущего использования |

**Пример таблицы страниц:**

```
Виртуальная страница | PFN | Present | Modified | Accessed | Write | Execute
        1            | 140 |    1    |    1     |    1     |   1   |    1
        2            | 129 |    1    |    1     |    1     |   1   |    1
       19            | 62  |    1    |    0     |    1     |   0   |    1
       20            | 50  |    1    |    0     |    1     |   0   |    1
       21            | 45  |    1    |    0     |    1     |   0   |    1
      38            | 860 |    1    |    1     |    1     |   1   |    1
      39            | 861 |    1    |    1     |    1     |   1   |    1
```

#### Размер таблицы страниц

Для 32-битной виртуальной системы с размером страницы 4 KB:
- Номер страницы: 20 битов → 2^20 = 1,048,576 страниц
- Размер каждой записи: 4 байта
- **Общий размер таблицы страниц: 4 MB на процесс**

Это значительный объем памяти, который заполняется сложным иерархическим способом.

---

### 4. Иерархическая таблица страниц

Для эффективного использования памяти применяется **многоуровневая таблица страниц** (hierarchical page table).

#### Двухуровневая таблица страниц (32-битная система Intel i386)

В 32-битной системе Intel i386 используется двухуровневая схема:

**Структура адреса:**
```
[10 битов: индекс PT1] [10 битов: индекс PT2] [12 битов: смещение]
```

**Процесс трансляции адреса 0x00403004:**

1. **Первый уровень (PT1)**:
   - Индекс в PT1: биты 22-31 = 1 (из адреса 0x00403004)
   - PT1[1] содержит адрес таблицы PT2

2. **Второй уровень (PT2)**:
   - Индекс в PT2: биты 12-21 = 292 (из адреса 0x00403004)
   - PT2[292] содержит номер физического блока памяти: 4206596

3. **Физический адрес**:
   - Номер блока: 4206596
   - Смещение: 4 (из адреса 0x00403004)
   - Физический адрес: 4206596 × 4096 + 4

#### Четырехуровневая таблица страниц (64-битная система x86-64)

В 64-битной архитектуре AMD x86-64 используется четырехуровневая схема:

**Уровни трансляции:**
```
PML4 (Page Map Level 4) → PDPT → PD → PT → физический адрес
```

**Структура 64-битного адреса:**
```
[9 битов] [9 битов] [9 битов] [9 битов] [12 битов смещения]
```

- **PML4**: 512 записей (9 битов)
- **PDPT** (Page Directory Pointer Table): 512 записей (9 битов)
- **PD** (Page Directory): 512 записей (9 битов)
- **PT** (Page Table): 512 записей (9 битов)
- **Смещение**: 4096 байт (2^12 = 4 KB страница)

**Общий объем адресного пространства:** 9 + 9 + 9 + 9 + 12 = 48 битов = 256 TB

#### Преимущества многоуровневой таблицы страниц

1. **Экономия памяти**: Таблицы более высокого уровня занимают меньше места
2. **Разреженное адресное пространство**: Неиспользуемые области не требуют выделения памяти
3. **Гибкость**: Простое добавление новых уровней для расширения адресного пространства

---

### 5. Translation Lookaside Buffer (TLB)

#### Определение и назначение TLB

Translation Lookaside Buffer (TLB) — это **кэш для таблицы страниц**, встроенный в процессор. Он хранит последние переводы виртуальных адресов в физические адреса, чтобы ускорить трансляцию адресов.

#### Проблема без TLB

Без TLB каждый доступ к памяти требует:
1. Обращение к таблице страниц (или нескольким уровням таблиц) в памяти
2. Получение физического адреса
3. Фактический доступ к памяти

Это требует **несколько обращений к памяти** для одной операции, что значительно замедляет выполнение.

#### Структура записи в TLB

Каждая запись в TLB содержит:

| Поле | Размер | Назначение |
|------|--------|-----------|
| **Виртуальная страница** | ~20 битов | Номер виртуальной страницы |
| **Номер физического блока (PFN)** | ~20 битов | Номер соответствующего физического блока |
| **ASID** | 8-16 битов | Address Space ID — идентификатор пространства адресов (процесса) |
| **Флаги** | Различные | Бит R (Read), W (Write), X (eXecute), Dirty и т.д. |

**Пример содержимого TLB (из учебника):**

```
Виртуальная страница | PFN | Present | R | W | X | Грязная
        1            | 140 |    1    | 1 | 1 |   |    1
       31            | 20  |    1    | 1 | 1 |   |    1
       19            | 62  |    1    | 1 | 0 | 1 |    0
       38            | 860 |    1    | 1 | 1 |   |    1
       39            | 861 |    1    | 1 | 1 |   |    1
```

#### Размер и структура TLB

**Типичные параметры TLB:**
- **Размер**: 8-64 записей (редко более 512)
- **Ассоциативность**: От полностью ассоциативного до N-способного
- **Время доступа**: 0 циклов (встроен в процессор)

**Сравнение доступа к памяти:**
- **TLB hit** (попадание): ~0 циклов + доступ в кэш процессора + доступ в ОЗУ
- **TLB miss** (промах): page table walk (несколько обращений к памяти) + доступ в ОЗУ

#### Процесс трансляции адреса с использованием TLB

1. **TLB hit** (виртуальная страница найдена в TLB):
   - MMU находит номер физического блока в TLB
   - Физический адрес формируется немедленно
   - Доступ к памяти выполняется быстро

2. **TLB miss** (виртуальная страница не найдена в TLB):
   - Исключение (interrupt/trap) передается в операционную систему
   - ОС выполняет **page table walk** — обход таблицы страниц
   - Новая запись добавляется в TLB (вытесняя старую при переполнении)
   - Трансляция повторяется

#### Page Table Walk

Page Table Walk — это процесс получения физического адреса путем обхода многоуровневой таблицы страниц.

**Для двухуровневой таблицы (i386):**
```
1. Загрузить PT1 из регистра CR3 (корневая таблица)
2. Индексировать PT1[номер_виртуальной_страницы[22:31]]
3. Получить адрес PT2
4. Индексировать PT2[номер_виртуальной_страницы[12:21]]
5. Получить номер физического блока
6. Сформировать физический адрес
```

**Количество обращений к памяти для каждого уровня:**
- Двухуровневая: 2 обращения к памяти (PT1 и PT2)
- Четырехуровневая: 4 обращения к памяти (PML4, PDPT, PD, PT)

Это значительно медленнее, чем TLB hit, что подчеркивает важность высокой скорости попадания в TLB.

#### Управление TLB

**Проблемы с управлением TLB:**

1. **Инвалидация TLB** при смене процесса:
   - При контекстном переключении между процессами записи TLB становятся недействительными
   - Без поля ASID требуется очистка всего TLB (дорогостоящая операция)
   - С полем ASID можно пометить записи как принадлежащие старому процессу (более эффективно)

2. **TLB shootdown** в многопроцессорных системах:
   - При изменении таблицы страниц одного процесса необходимо инвалидировать соответствующие записи TLB на всех процессорах
   - Требует межпроцессорной коммуникации (IPI — inter-processor interrupts)

3. **Недостаток места в TLB**:
   - Если программа часто обращается к большому количеству разных страниц, частота промахов TLB повышается
   - Большие страницы (2 MB, 1 GB) могут снизить давление на TLB

---

### 6. Поддержка большого объема памяти

#### Проблема масштабирования

С увеличением размера памяти возникают проблемы:

1. **Размер таблицы страниц растет**:
   - Для 32-битной системы: 4 MB таблица на процесс (и может быть 100+ активных процессов)
   - Для 64-битной системы без оптимизаций: требуется невозможно большое количество памяти

2. **Давление на TLB**:
   - С большим адресным пространством увеличивается вероятность промахов TLB
   - TLB не может кэшировать все активные страницы при большом объеме памяти

#### Решение 1: Большие страницы (Large Pages)

Вместо стандартных 4 KB страниц используются большие страницы:
- **2 MB страницы**: В 512 раз больше, снижает давление на TLB
- **1 GB страницы**: В 262,144 раза больше, еще более эффективно для больших приложений

**Преимущества большие страниц:**
- Снижение давления на TLB (меньше записей требуется для адресации того же объема памяти)
- Снижение количества page walks
- Лучшая локальность кэша

**Недостатки:**
- Внутренняя фрагментация (недостаточное использование страницы)
- Сложность в управлении смешанными размерами страниц

#### Решение 2: Прямое отображение больших блоков

Некоторые системы поддерживают **прямое отображение больших разделов адресного пространства** (например, Linux с CONFIG_FLATMEM), где большие области памяти отображаются без использования полной таблицы страниц.

#### Решение 3: Оптимизация таблиц страниц

В Linux и других ОС используются оптимизированные структуры:

**Linux kernel page descriptors (kernel memory management):**
- Для каждого физического блока памяти ведется дескриптор (struct page)
- Содержит информацию о том, какой процесс использует страницу, флаги состояния и т.д.
- Более гибко, чем простая таблица страниц

**Buddy algorithm (система выделения памяти):**
- Память организована в блоки степеней 2 (1, 2, 4, 8, 16, ... страниц)
- Упрощает выделение и освобождение больших смежных блоков памяти
- Снижает фрагментацию

---

### 7. Обработка Page Faults

#### Типы page faults

1. **Minor page fault** (незначительная ошибка):
   - Страница есть в памяти, но не в TLB
   - Требуется лишь обновить TLB
   - Быстрая обработка

2. **Major page fault** (серьезная ошибка):
   - Страница находится на диске
   - Требуется загрузка со диска в память
   - Медленная обработка (может занять миллисекунды)

#### Обработка page fault

**Последовательность действий при page fault:**

1. **Прерывание**: Процессор генерирует исключение (exception/interrupt)
2. **Сохранение контекста**: Состояние процесса сохраняется
3. **Обработка в ядре**:
   - Определение типа ошибки (виртуальный адрес вне диапазона, отсутствие прав доступа и т.д.)
   - Если страница есть в памяти — обновление TLB
   - Если страница на диске — инициирование операции ввода-вывода и переключение на другой процесс
4. **Восстановление**: После загрузки страницы процесс возобновляется

#### Копирование при записи (Copy-on-Write)

Оптимизация для операции fork():

```c
int pid = fork();  // Создание дочернего процесса
```

1. **Традиционный подход**: Копирование всей памяти родителя в дочерний процесс (дорого)
2. **Copy-on-Write (CoW)**:
   - Изначально дочерний процесс имеет тот же вид на страницы, что и родитель
   - Страницы помечаются как "только для чтения"
   - При попытке записи → page fault → копирование страницы → запись в копию
   - Если дочерний процесс не изменяет память, копирование не происходит (дешево)

---

## Вопрос 37: Виртуальная память. Оптимизации при работе со страничной памятью, сегментирование

### 1. Оптимизации при работе со страничной памятью

#### 1.1 Инвертированная таблица страниц (Inverted Page Table)

**Проблема традиционной таблицы страниц:**
- Требуется одна таблица для каждого процесса
- При большом адресном пространстве (64-битном) таблица становится огромной

**Инвертированная таблица страниц:**
- **Одна таблица на всю систему** вместо таблицы на процесс
- Организована по физическим блокам памяти (page frames), а не по виртуальным страницам
- Каждая запись содержит:
  - Владелец (PID процесса)
  - Виртуальный номер страницы процесса
  - Флаги (present, dirty, accessed и т.д.)

**Структура инвертированной таблицы:**

```
Физический блок | PID | Виртуальная страница | Флаги
       0        | 5   |       120           | R, W
       1        | 7   |       45            | R, W, X
       2        | 3   |       800           | R
       3        | -   |       -             | (свободный)
       ...
```

**Преимущества:**
- Размер таблицы зависит от физической памяти, а не от виртуального адресного пространства
- Для 64-битной системы с 16 GB RAM: таблица займет ~1-2 MB (вместо терабайтов для традиционной таблицы)

**Недостатки:**
- Поиск виртуальной страницы в инвертированной таблице требует линейного поиска или хеширования
- Требуется дополнительная структура (хеш-таблица) для быстрого поиска

**Хеширование для оптимизации:**
- Виртуальный адрес хешируется для поиска записи в таблице
- При коллизиях используется цепочка (связный список)
- Быстрый поиск за O(1) в среднем

#### 1.2 Кэширование доступов к памяти

**Системы кэширования памяти:**

```
                    CPU
                     ↓
              ┌──────────────┐
              │  L1 кэш (32 KB)
              └──────────────┘
                     ↓
              ┌──────────────┐
              │  L2 кэш (256 KB)
              └──────────────┘
                     ↓
              ┌──────────────┐
              │  L3 кэш (8-20 MB)
              └──────────────┘
                     ↓
              ┌──────────────┐
              │   ОЗУ (RAM)
              └──────────────┘
```

**Иерархия памяти:**
- **L1 кэш**: Быстрый, встроен в ядро процессора, 1-2 циклов доступа, ~32 KB
- **L2 кэш**: Быстрый, встроен в ядро, 4-10 циклов, ~256 KB
- **L3 кэш**: Медленнее, общий для всех ядер, 12-75 циклов, ~8-20 MB
- **ОЗУ**: Медленная, 200+ циклов доступа

**Принцип локальности:**
1. **Временная локальность**: Недавно использованные данные часто используются снова
2. **Пространственная локальность**: Данные рядом с недавно использованными часто используются

#### 1.3 Размер блока кэша (Cache line)

**Типичный размер**: 64 байта

**Причины:**
- Баланс между скоростью передачи и гранулярностью кэширования
- 64 байта = 8 операций с int64 (в одном блоке)
- При 64 битах шины памяти: ~1 цикл на 64 байта

#### 1.4 Ассоциативность кэша

**Уровни ассоциативности:**

1. **Прямое отображение (Direct-mapped):**
   - Каждый адрес памяти может быть в строго определенной позиции в кэше
   - Быстро, но высокая вероятность конфликтов

2. **N-способная ассоциативность (N-way associative):**
   - Каждый адрес может быть в одном из N мест в кэше
   - Баланс между гибкостью и скоростью

3. **Полностью ассоциативный (Fully associative):**
   - Каждый адрес может быть в любом месте кэша
   - Медленнее, но минимальные конфликты

#### 1.5 Оптимизация доступа к памяти

**Техники для снижения cache misses:**

1. **Блочная обработка (blocking)**:
```c
// Неоптимальный порядок доступа (плохая локальность)
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        C[i][j] = A[i][j] + B[i][j];
    }
}
// Cache miss каждый раз при доступе к B

// Оптимальный (блокирование для улучшения локальности)
for (int ii = 0; ii < N; ii += BLOCK) {
    for (int jj = 0; jj < M; jj += BLOCK) {
        for (int i = ii; i < ii + BLOCK; i++) {
            for (int j = jj; j < jj + BLOCK; j++) {
                C[i][j] = A[i][j] + B[i][j];
            }
        }
    }
}
```

2. **Выравнивание структур данных**:
```c
// Плохое выравнивание
struct Bad {
    char a;     // 1 байт
    int b;      // 4 байта (требует 3 байта padding)
    char c;     // 1 байт
    int d;      // 4 байта (требует 3 байта padding)
};  // Размер: 16 байт (из них 6 bytes padding)

// Хорошее выравнивание
struct Good {
    int b;      // 4 байта
    int d;      // 4 байта
    char a;     // 1 байт
    char c;     // 1 байт
};  // Размер: 12 байт (из них 2 bytes padding)
```

3. **Предварительная загрузка (prefetching)**:
```c
// Явная подсказка процессору загрузить данные в кэш
for (int i = 0; i < N; i++) {
    __builtin_prefetch(&array[i + 8]);  // Загрузить на 8 итераций вперед
    process(array[i]);
}
```

---

### 2. Алгоритмы замены страниц (Page Replacement Algorithms)

Когда физическая память полна и требуется загрузить новую страницу со диска, необходимо выбрать страницу для вытеснения.

#### 2.1 Оптимальный алгоритм (Optimal Algorithm)

**Теория**: Вытеснить страницу, которая будет использована в самом дальнем будущем.

**Пример:**
```
Последовательность обращений: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Размер памяти: 3 страницы
Начальное состояние: пусто

1. Загрузить 1: [1, -, -]
2. Загрузить 2: [1, 2, -]
3. Загрузить 3: [1, 2, 3]
4. Загрузить 4: Вытеснить 3 (используется в 11-й позиции) → [1, 2, 4]
5. Обращение к 1: Попадание
6. Обращение к 2: Попадание
7. Загрузить 5: Вытеснить 4 (используется в 12-й позиции) → [1, 2, 5]
8. Обращение к 1: Попадание
9. Обращение к 2: Попадание
10. Загрузить 3: Вытеснить 5 (используется в 12-й позиции) → [1, 2, 3]
11. Обращение к 4: Ошибка (требуется новая загрузка) → [1, 4, 3]
12. Обращение к 5: Ошибка → [4, 5, 3]
```

**Недостатки**: Невозможно реализовать в реальных системах (требуется знание будущих обращений).

**Использование**: Служит нижней границей для сравнения с другими алгоритмами.

#### 2.2 FIFO (First-In-First-Out)

**Принцип**: Вытеснить самую старую страницу (первую загруженную).

**Реализация**: Простая очередь страниц.

**Пример:**
```
Последовательность обращений: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Размер памяти: 3 страницы

1. Загрузить 1: [1, -, -]
2. Загрузить 2: [1, 2, -]
3. Загрузить 3: [1, 2, 3]
4. Загрузить 4: Вытеснить 1 (самую старую) → [2, 3, 4]
5. Обращение к 1: Ошибка → [3, 4, 1]
6. Обращение к 2: Ошибка → [4, 1, 2]
7. Загрузить 5: Вытеснить 4 → [1, 2, 5]
8-10. Попадания
11. Загрузить 3: Вытеснить 1 → [2, 5, 3]
12. Загрузить 4: Вытеснить 2 → [5, 3, 4]
```

**Преимущества:**
- Простая реализация
- Предсказуемое поведение

**Недостатки:**
- **Эффект Белэди** (Bélády's anomaly): Увеличение размера памяти может привести к увеличению количества ошибок
- Не учитывает частоту использования страниц
- Может вытеснить часто используемую страницу

#### 2.3 LRU (Least Recently Used)

**Принцип**: Вытеснить страницу, которая не использовалась дольше всего.

**Реализация**: Каждая страница имеет временную метку последнего доступа.

**Пример:**
```
Последовательность обращений: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Размер памяти: 3 страницы

1. Загрузить 1: [1, -, -] (время: 1=[1])
2. Загрузить 2: [1, 2, -] (время: 1=[1], 2=[2])
3. Загрузить 3: [1, 2, 3] (время: 1=[1], 2=[2], 3=[3])
4. Загрузить 4: Вытеснить 1 (ЛРУ) → [2, 3, 4] (время: 2=[2], 3=[3], 4=[4])
5. Обращение к 1: Ошибка → [2, 3, 1] (время: 2=[2], 3=[3], 1=[5])
6. Обращение к 2: Попадание (время: 2=[6], 3=[3], 1=[5])
7. Загрузить 5: Вытеснить 3 (ЛРУ) → [2, 1, 5] (время: 2=[6], 1=[5], 5=[7])
8-10. Попадания
11. Загрузить 3: Вытеснить страницу с минимальным временем
12. ...
```

**Преимущества:**
- Обычно лучше FIFO
- Учитывает недавнее использование
- Нет эффекта Белэди

**Недостатки:**
- Требует отслеживания временных меток для каждой страницы
- Обновление метки при каждом доступе — дорого

#### 2.4 NRU (Not Recently Used)

**Принцип**: Вытеснить страницу с флагами (R=0, M=0) — не используемую и не модифицированную.

**Реализация**: Использует два бита состояния:
- **R (Referenced)**: Установлен, когда страница была прочитана/записана
- **M (Modified)**: Установлен, когда страница была записана

**Классификация страниц:**
```
Класс | R | M | Приоритет вытеснения
  0   | 0 | 0 | Самый высокий (1-й)
  1   | 0 | 1 | 2-й
  2   | 1 | 0 | 3-й
  3   | 1 | 1 | Самый низкий (4-й)
```

**Периодический сброс бита R:**
- Каждые 20-100 мс сброс всех битов R = 0
- Это различает "старые" и "новые" страницы

**Пример выбора жертвы:**
```
Текущее состояние страниц:
Страница | R | M
   1     | 0 | 0  ← Вытеснить эту (класс 0)
   2     | 1 | 0
   3     | 1 | 1
   4     | 0 | 1
```

**Преимущества:**
- Простая реализация (только 2 бита)
- Хороший компромисс между производительностью и сложностью

**Недостатки:**
- Не так хорошо как LRU
- Требует периодического сброса битов R

#### 2.5 Clock (Second Chance)

**Принцип**: Вращающийся алгоритм с одним указателем (как часовая стрелка).

**Реализация:**
```
Страницы хранятся в циклическом буфере:

     ┌─────────────────────────────┐
     │  Страница 0 [R=1]           │
     │  Страница 1 [R=0]  ← указа- │
     │  Страница 2 [R=1]  │ тель   │
     │  Страница 3 [R=0]           │
     └─────────────────────────────┘
```

**Процесс:**
1. При необходимости вытеснения начинаем с текущей позиции указателя
2. Если R=1: установить R=0, переместить указатель (дать второй шанс)
3. Если R=0: вытеснить страницу, переместить указатель

**Пример:**
```
Текущие страницы:
0: R=1    1: R=0 ←  2: R=1    3: R=0

1. Вытеснение нужно. Указатель на 1, R=0 → вытеснить страницу 1
2. Вставить новую страницу: [0, новая, 2, 3]
3. Указатель переместится на 2
```

**Преимущества:**
- Простая реализация (циклический буфер + один указатель)
- Хороший компромисс между производительностью и затратами

**Недостатки:**
- Может быть несправедлив к старым страницам (если часто устанавливается R)

---

### 3. Сегментирование (Segmentation)

#### 3.1 Определение и назначение

Сегментирование — это второй подход к управлению памятью (помимо пагинга), при котором **виртуальное адресное пространство делится на логические единицы разного размера**, называемые **сегментами**.

**Отличие от пагинга:**
```
Пагинг:           Сегментирование:
┌──────────────┐  ┌──────────────────┐
│ Страница 0   │  │ Сегмент CODE     │ (программный код)
│ Страница 1   │  │ Сегмент HEAP     │ (динамическая память)
│ Страница 2   │  │ Сегмент STACK    │ (стек)
│ Страница 3   │  │ Сегмент GLOBALS  │ (глобальные переменные)
│ Страница 4   │  │ Сегмент LIB      │ (общие библиотеки)
└──────────────┘  └──────────────────┘
Одинаковый раз   Разные размеры
мер всех страниц сегментов
```

#### 3.2 Структура сегментированного адреса

Виртуальный адрес состоит из:
```
[номер_сегмента : смещение_в_сегменте]
```

**Пример (16-битный адрес):**
```
Виртуальный адрес: 0x1234
Номер сегмента: 0x1 (старших 4 бита)
Смещение: 0x234 (младших 12 битов)
```

#### 3.3 Таблица сегментов (Segment Table)

Для каждого процесса существует таблица сегментов.

**Запись таблицы сегментов содержит:**

| Поле | Размер | Назначение |
|------|--------|-----------|
| **Базовый адрес** | 32/64 бита | Начальный физический адрес сегмента в памяти |
| **Размер** | 17-20 битов | Размер сегмента в байтах |
| **Присутствие** | 1 бит | Находится ли сегмент в памяти |
| **Модификация** | 1 бит | Был ли сегмент изменен |
| **Доступ** | 1 бит | Был ли сегмент прочитан/написан |
| **Права доступа** | 2 бита | R (чтение), W (запись), X (выполнение) |

**Пример таблицы сегментов:**

```
Сегмент | Базовый адрес | Размер | Present | RWX
--------|---------------|--------|---------|----
  0 (CODE)  | 0x00001000    | 0x2000 |    1    | R-X
  1 (STACK) | 0x00010000    | 0x1000 |    1    | RW-
  2 (DATA)  | 0x00020000    | 0x3000 |    1    | RW-
  3 (HEAP)  | 0x00030000    | 0x5000 |    1    | RW-
```

#### 3.4 Трансляция адреса в сегментированной системе

**Процесс:**
```
1. Виртуальный адрес 0x01234
   ├─ Номер сегмента: 1
   └─ Смещение: 0x234

2. Индексировать таблицу сегментов[1]
   ├─ Базовый адрес: 0x00010000
   └─ Размер: 0x1000

3. Проверка границ:
   0x234 < 0x1000 ✓ (смещение в пределах сегмента)

4. Физический адрес = 0x00010000 + 0x234 = 0x00010234
```

#### 3.5 Примеры сегментов в реальных системах

**Intel x86 (реальный режим):**
```
Сегмент | Назначение
--------|------------------------------------------
CS      | Code Segment (сегмент кода)
DS      | Data Segment (сегмент данных)
SS      | Stack Segment (сегмент стека)
ES, FS, GS | Extra Segments (дополнительные)
```

**MULTICS (исторический пример):**
```
Сегмент | Назначение | Размер
--------|------------|--------
  0     | Текущая процедура (код) | 64 KB
  1     | Локальные переменные | 64 KB
  2     | Глобальные переменные | 256 KB
  3     | Stack | 256 KB
  4     | Общие библиотеки | 256 KB
  ...   | ...
```

#### 3.6 Преимущества сегментирования

1. **Соответствие логической структуре программы**: Сегменты соответствуют реальным компонентам (код, данные, стек, библиотеки)

2. **Простая защита**: Можно устанавливать разные права для каждого сегмента (e.g., код — только для чтения/выполнения)

3. **Совместное использование**: Несколько процессов могут использовать один сегмент библиотеки (например, libc)

4. **Динамический рост**: Стек может динамически расти в пределах сегмента

5. **Простота отладки**: Сегменты соответствуют элементам программы

#### 3.7 Недостатки сегментирования

1. **Фрагментация памяти**: Промежутки между сегментами тратят память впустую
   ```
   Память:  [Seg1][gap][Seg2][gap][Seg3][gap]
   ```

2. **Сложность управления**: Требуется сложный алгоритм размещения (First-Fit, Best-Fit и т.д.)

3. **Проблемы роста**: Если сегмент растет и нет места рядом, требуется перемещение

4. **Сложность реализации**: Более сложный, чем пагинг

#### 3.8 Сегментация vs Пагинг

| Параметр | Сегментирование | Пагинг |
|----------|-----------------|--------|
| **Размер единицы** | Переменный | Фиксированный (4 KB) |
| **Видимость программе** | Видно | Невидимо |
| **Фрагментация** | Внешняя (фрагменты между сегментами) | Внутренняя (внутри страниц) |
| **Трансляция адреса** | Простая | Требует многоуровневые таблицы |
| **Кэширование** | Сложное | Легко с TLB |
| **Совместное использование** | Легко | Сложнее |
| **Защита** | Хорошая (разные права на сегмент) | Менее гибкая |

#### 3.9 Сегментирование + Пагинг (комбинированный подход)

**Многие современные системы используют оба подхода:**

```
Виртуальный адрес
    ↓
[Номер сегмента : Смещение в сегменте]
    ↓ (сегментирование)
Линейный адрес (в сегменте)
    ↓ 
[Номер виртуальной страницы в сегменте : Смещение в странице]
    ↓ (пагинг через TLB)
Физический адрес

Пример (Intel 80386):
1. Сегментирование преобразует виртуальный адрес в линейный адрес
2. MMU преобразует линейный адрес через TLB в физический
3. Физический адрес используется для доступа к памяти
```

**Преимущества комбинированного подхода:**
- Сегментирование обеспечивает логическую организацию и защиту
- Пагинг обеспечивает гибкость и снижает фрагментацию

---

### 4. Оптимизации при обработке сегментов

#### 4.1 LRU для сегментов

Когда сегмент находится на диске, он загружается в память целиком.

При нехватке памяти требуется выбрать сегмент для выгрузки на диск.

**LRU для сегментов:**
```
Когда сегмент не был использован дольше всего - выгрузить его
```

#### 4.2 Совместное использование сегментов (Sharing)

**Сценарий: две программы используют libc**

```
Программа A: 
  Сегмент 0: [Свой код]
  Сегмент 1: [Свои данные]
  Сегмент 2: [libc] ← указывает на общий сегмент

Программа B:
  Сегмент 0: [Свой код]
  Сегмент 1: [Свои данные]
  Сегмент 2: [libc] ← указывает на тот же общий сегмент
  
В памяти сегмент libc хранится только ОДИН раз
```

**Требования для совместного использования:**
- Код должен быть re-entrant (переиспользуемый)
- Не должны быть модифицированы глобальные переменные
- Хранение специфичных для процесса данных в отдельных сегментах (PIC - Position Independent Code)

---

### 5. Обобщение оптимизаций

**Основные техники оптимизации памяти:**

| Техника | Применение | Эффект |
|---------|-----------|--------|
| **Инвертированная таблица страниц** | 64-битные системы | Снижение размера таблиц в 1000x раз |
| **TLB** | Все системы | Ускорение трансляции адресов в 10-100x |
| **Большие страницы** | Системы с большой памятью | Снижение давления на TLB |
| **Copy-on-Write** | fork() операции | Экономия памяти при создании процессов |
| **NRU + Clock** | Замена страниц | Эффективное использование памяти с минимум затрат |
| **Кэширование** | Все системы | Ускорение доступа на 10-100x |
| **Сегментирование** | Логическая организация | Защита и совместное использование памяти |
| **Пагинг + Сегментирование** | Современные системы | Комбинированные преимущества обоих подходов |

---

## Заключение

Страничная организация памяти является фундаментальной частью современных операционных систем. Она обеспечивает:

1. **Абстракцию** виртуального адресного пространства от физической памяти
2. **Защиту** между процессами через изоляцию памяти
3. **Гибкость** в распределении памяти
4. **Масштабируемость** от малых встроенных систем до больших серверов

Множество оптимизаций (TLB, большие страницы, инвертированные таблицы, кэширование, различные алгоритмы замены) позволяют достичь высокой производительности даже при работе с миллиардами страниц памяти.

Комбинирование сегментирования и пагинга дает лучший из обоих миров — логическую организацию программы с гибкостью и производительностью пагинга.
