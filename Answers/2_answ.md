# Понятие процесса

**Процесс** — это абстракция ОС, представляющая собой экземпляр выполняемой программы. В отличие от программы (пассивного набора инструкций и данных на диске), процесс является активной сущностью, владеющей ресурсами: адресным пространством, открытыми файлами, сигналами и потоками исполнения. Процесс обеспечивает изоляцию выполнения программ друг от друга.

---

## Вопрос 7: Память процесса. Инициализация и завершение процесса

### Память процесса
Память процесса делится на следующие секции:

1.  **Text (Code) Segment**: Содержит исполняемый код программы. Обычно доступен только для чтения и фиксирован по размеру.
2.  **Data Segment**: Содержит инициализированные и неинициализированные (BSS) глобальные и статические переменные. Размер фиксирован.
3.  **Heap (Куча)**: Динамически выделяемая память во время выполнения программы (malloc/new). Растет в сторону увеличения адресов.
4.  **Stack (Стек)**: Содержит временные данные функций (локальные переменные, аргументы, адреса возврата). Растет в сторону уменьшения адресов.

### Инициализация процесса
При создании процесса ОС выполняет следующие шаги:

1.  **Загрузка**: Загрузка кода программы и данных из исполняемого файла в память.
2.  **Выделение ресурсов**: Создание PCB, выделение памяти под стек и кучу.
3.  **Инициализация контекста**: Установка регистров процессора (включая PC - Program Counter на точку входа) и переменных окружения.
4.  **Состояние**: Перевод процесса в состояние *Ready*.

### Завершение процесса
Процесс завершается либо добровольно (exit), либо принудительно (kill).
1.  **Освобождение ресурсов**: Память, открытые файлы, дескрипторы освобождаются или закрываются.
2.  **Статус завершения**: Код возврата передается родительскому процессу.
3.  **Состояние Zombie**: Процесс переходит в состояние *Terminated* (Zombie), храня лишь минимальную информацию (PID, статус), пока родитель не считает её через `wait()`. После этого запись о процессе удаляется окончательно.

---

## Вопрос 8: Отличие между процессами в Windows и Unix. Понятие Process Control Block (PCB), из чего он состоит

### Отличия процессов Windows и Unix
*   **Создание**:
    *   *Unix*: `fork()` создает полную копию родительского процесса (с тем же кодом и данными). `exec()` заменяет код процесса на новый. Иерархия строго древовидная (init - корень).
    *   *Windows*: `CreateProcess()` создает новый пустой процесс и загружает в него указанную программу. Иерархия процессов не поддерживается явно (нет строгого "родитель-потомок" владения, есть только хендлы).
*   **Идентификация**: В Unix PID - число, в Windows - Handle (дескриптор) и PID.

### Process Control Block (PCB)
**PCB (Блок управления процессом)** — это структура данных в ядре ОС, содержащая всю информацию, необходимую для управления конкретным процессом.

**Состав PCB**:
1.  **Идентификатор процесса (PID)**: Уникальный номер.
2.  **Состояние процесса**: (New, Ready, Running, Waiting, Terminated).
3.  **Счетчик команд (Program Counter)**: Адрес следующей инструкции для выполнения.
4.  **Регистры процессора**: Содержимое аккумуляторов, индексных регистров, стекового указателя и флагов (сохраняется при прерывании).
5.  **Информация о планировании**: Приоритет, указатели на очереди планирования.
6.  **Управление памятью**: Значения базового и граничного регистров, указатели на таблицы страниц/сегментов.
7.  **Учетная информация**: Время процессора, реальное время работы, лимиты времени.
8.  **Информация о вводе-выводе**: Список открытых файлов, выделенные устройства.

---

## Вопрос 9: Состояния процесса. Таблица процессов. Моделирование режима многозадачности

### Состояния процесса
Основные состояния жизненного цикла процесса:

1.  **New (Создание)**: Процесс создается.
2.  **Running (Выполнение)**: Инструкции выполняются на процессоре.
3.  **Waiting (Ожидание/Blocked)**: Процесс ждет события (ввод-вывод, сигнал).
4.  **Ready (Готовность)**: Процесс готов к выполнению, ждет освобождения процессора.
5.  **Terminated (Завершение)**: Процесс закончил выполнение.

Переходы:

*   *New -> Ready* (допуск к системе)
*   *Ready -> Running* (планировщик выбрал процесс)
*   *Running -> Ready* (истек квант времени или прерывание)
*   *Running -> Waiting* (запрос ввода-вывода)
*   *Waiting -> Ready* (завершение ввода-вывода)
*   *Running -> Terminated* (выход)

### Таблица процессов
**Таблица процессов** — системная структура данных, содержащая ссылки на PCB всех процессов (или сами PCB). Позволяет ОС быстро находить информацию о любом процессе.

### Моделирование многозадачности
Многозадачность на одном процессоре реализуется через **псевдопараллелизм**:

1.  Процессор выполняет процесс A.
2.  По таймеру происходит прерывание.
3.  ОС сохраняет контекст A в его PCB.
4.  Планировщик выбирает процесс B.
5.  ОС загружает контекст B из его PCB.
6.  Процессор выполняет процесс B.
Быстрое переключение создает иллюзию одновременной работы.

---

## Вопрос 10: Механизм прерываний. Доступ пользовательских программ к функциям ОС. Контексты исполнения программного кода

### Механизм прерываний
**Прерывание** — сигнал процессору о событии, требующем немедленного внимания. Приводит к приостановке текущего кода и вызову обработчика прерывания.
*   **Аппаратные**: От внешних устройств (таймер, диск, клавиатура).
*   **Программные (Исключения)**: Ошибки (деление на 0) или специальные инструкции (int, syscall).

### Доступ к функциям ОС (Системные вызовы)
Пользовательские программы работают в ограниченном режиме (User Mode) и не могут напрямую обращаться к железу или памяти ядра.
Доступ осуществляется через **Системные вызовы (System Calls)**:

1.  Программа помещает аргументы в регистры.
2.  Выполняет инструкцию прерывания (например, `syscall` или `int 0x80`).
3.  Процессор переключается в режим ядра (Kernel Mode).
4.  Ядро выполняет запрошенную операцию (например, `read`, `open`).
5.  Ядро возвращает результат и переключает процессор обратно в режим пользователя.

### Контексты исполнения
1.  **Контекст процесса (User Context)**: Код, данные, стек пользователя, регистры при выполнении в User Mode.
2.  **Контекст ядра (Kernel Context)**: Стек ядра, регистры, структуры данных ядра при выполнении системного вызова или обработчика прерывания в Kernel Mode.
3.  **Контекст прерывания**: Специфическое состояние при обработке аппаратного прерывания (часто не связано с текущим процессом).

---

## Вопрос 11: Кооперация процессов. Причины кооперации. Способы межпроцессной коммуникации

### Кооперация процессов
Кооперация — взаимодействие процессов для выполнения общей задачи.
**Причины**:
1.  **Обмен информацией**: Несколько пользователей/процессов работают с одними данными.
2.  **Ускорение вычислений**: Распараллеливание задачи на подзадачи (на многоядерных системах).
3.  **Модульность**: Разделение системы на функциональные блоки (процессы).
4.  **Удобство**: Выполнение нескольких задач одновременно (редактирование и печать).

### Способы межпроцессной коммуникации (IPC)
1.  **Общая память (Shared Memory)**: Процессы имеют доступ к общей области оперативной памяти. Самый быстрый способ, но требует синхронизации.
2.  **Передача сообщений (Message Passing)**: Обмен пакетами данных через механизмы ОС (`send`/`receive`). Медленнее, но безопаснее (нет конфликтов доступа к памяти).
3.  **Каналы (Pipes)**: Потоковая передача данных (см. вопрос 12).
4.  **Сокеты (Sockets)**: Обмен данными между процессами на разных машинах (или одной) через сеть.
5.  **Сигналы**: Простые уведомления о событиях.

---

## Вопрос 12: Каналы (pipes). Особенности работы различных видов каналов. Организация процессов в группы

### Каналы (Pipes)
Канал — это однонаправленный буфер для передачи потока байтов от одного процесса к другому.

### Виды каналов
1.  **Неименованные каналы (Anonymous pipes)**:
    *   Создаются системным вызовом `pipe()`.
    *   Существуют только в оперативной памяти пока открыты дескрипторы.
    *   Доступны только родственным процессам (родитель-потомок), унаследовавшим дескрипторы.
    *   Данные читаются в порядке FIFO.
2.  **Именованные каналы (Named pipes / FIFO)**:
    *   Существуют в виде специального файла в файловой системе.
    *   Доступны любым процессам, знающим путь к файлу (даже неродственным).
    *   Живут до явного удаления файла.

### Организация процессов в группы
**Группа процессов** — объединение одного или нескольких процессов (обычно связанных одной задачей, например, конвейер `ls | grep`).
*   Каждая группа имеет уникальный идентификатор **PGID**.
*   Группы используются для управления сигналами: сигнал, отправленный группе, доставляется всем процессам в ней (например, Ctrl+C в терминале останавливает все процессы текущей группы).
*   **Сессия** объединяет несколько групп процессов (активная группа + фоновые).
