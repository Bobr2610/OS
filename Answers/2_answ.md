# Понятие процесса

Понятие процесса - продолжи ... 

---

## ВОПРОС 7: Память процесса. Инициализация и завершение процесса

### Структура памяти процесса

Память процесса организована в виде четырёх основных секций, каждая из которых имеет определённое назначение:

#### **1. Text (Текстовая) секция**
- Содержит **исполняемый код** программы
- **Размер фиксирован** и не изменяется во время выполнения программы
- Это машинные инструкции, которые процессор выполняет последовательно
- На многопроцессных системах может быть **общей для нескольких процессов** (если они запущены из одного исполняемого файла - shared text segments)

#### **2. Data (Данные) секция**
- Содержит **глобальные переменные**, которые инициализированы в коде
- Разделяется на две части:
  - **Инициализированные данные** (initialized data): глобальные переменные с известными значениями
  - **Неинициализированные данные (BSS - Block Started by Symbol)**: глобальные переменные, которые будут инициализированы нулями
- **Размер фиксирован** и известен на момент компиляции

#### **3. Heap (Куча) секция**
- **Динамически выделяемая память** во время выполнения программы
- Выделяется посредством функций `malloc()` (C) или `new` (C++)
- **Растёт в направлении от низких адресов к высоким** (в типичной архитектуре)
- Требует явного освобождения памяти через `free()` или автоматической очистки
- **Переменный размер**, может увеличиваться и уменьшаться

#### **4. Stack (Стек) секция**
- Содержит **временные данные** для функций:
  - Параметры функции
  - Локальные переменные функции
  - Адреса возврата из функций
  - Состояние регистров процессора
- **Растёт в направлении от высоких адресов к низким** (в типичной архитектуре)
- Каждый вызов функции добавляет **record активации** в стек
- При возврате из функции запись удаляется (pop)
- **Переменный размер**, но ОС должна следить, чтобы стек и heap не пересеклись

### Макет памяти 32-битного процесса (типичный пример x86)

```
Высокие адреса:
┌─────────────────────┐
│      STACK          │  ← растёт вверх ↓
├─────────────────────┤
│      (свободное)    │
├─────────────────────┤
│      HEAP           │  ← растёт вниз ↑
├─────────────────────┤
│    DATA + BSS       │  ← фиксированный размер
├─────────────────────┤
│      TEXT           │  ← фиксированный размер
└─────────────────────┘
Низкие адреса
```

На 32-битных системах стек часто начинается с адреса 0xC0000000 и растёт вниз.

### Инициализация процесса

Процесс инициализируется в следующем порядке:

#### **1. Загрузка исполняемого файла**
- Операционная система читает ELF-файл (Executable and Linkable Format) на Linux/Unix или PE-файл на Windows
- Определяются границы каждой секции памяти
- Загружается код из text-секции и инициализированные данные

#### **2. Выделение памяти**
- ОС выделяет физическую (или виртуальную) память для:
  - Text-секции
  - Data-секции (инициализированной и BSS)
  - Начального размера heap
  - Начального размера stack

#### **3. Инициализация регистров**
- **Программный счётчик (Program Counter, PC)** устанавливается на адрес функции `main()` или точки входа программы
- **Указатель стека (Stack Pointer, SP)** устанавливается в конец выделенной памяти стека

#### **4. Передача параметров**
- Параметры командной строки (`argc`, `argv`) помещаются в стек
- Переменные окружения также передаются процессу

#### **5. Запуск программы**
- Код инициализации (startup code) выполняется перед `main()`
- Затем начинает выполняться основной код программы

### Завершение процесса

Процесс завершается в следующем порядке:

#### **1. Явный выход из main()**
```c
// Unix/Linux
exit(int status);      // POSIX функция
return 0;              // Из main() - эквивалентно exit(0)

// Windows
ExitProcess(DWORD exitCode);
```

#### **2. Очистка ресурсов (на уровне библиотеки)**
- Вызываются функции, зарегистрированные через `atexit()`
- Закрываются все открытые файлы
- Освобождаются выделенные ресурсы (памяти, сокеты и т.д.)

#### **3. Системный вызов exit (syscall)**
- Процесс делает системный вызов `exit()` или `ExitProcess()`
- Передаёт код выхода (status code) ядру ОС
- Выполняется в режиме ядра (kernel mode)

#### **4. Очистка в ядре ОС**
- ОС **освобождает все ресурсы**, принадлежащие процессу:
  - Физическую память
  - Виртуальное адресное пространство
  - Открытые файловые дескрипторы
  - Привилегии доступа
  - Таблицы страниц памяти

#### **5. Передача статуса родительскому процессу**
- Процесс переходит в состояние **Zombie (Зомби)**
- ОС сохраняет код выхода процесса
- Родительский процесс может прочитать статус через `wait()` или `waitpid()`

#### **6. Удаление из системы**
- После того, как родитель вызвал `wait()` и прочитал статус
- **Процесс полностью удаляется** из системы
- Если родитель не вызвал `wait()`, процесс может оставаться зомби

### Жизненный цикл процесса

```
Создание (fork)
    ↓
Инициализация памяти и регистров
    ↓
Исполнение (Running)
    ↓
Вызов exit() или return из main()
    ↓
Очистка ресурсов
    ↓
Состояние Zombie
    ↓
Родитель вызывает wait() и прочитал статус
    ↓
Процесс удалён из системы
```

---

## ВОПРОС 8: Отличие между процессами в Windows и Unix. Понятие Process Control Block (PCB), из чего он состоит.

### Сравнение процессов Windows и Unix

#### **Создание процесса**

| Аспект | **Unix/Linux** | **Windows** |
|--------|---|---|
| **Системный вызов** | `fork()` | `CreateProcess()` |
| **Механизм** | Копирование родительского процесса (почти полное) | Создание нового процесса с нуля |
| **Код** | Наследуется от родителя (copy-on-write) | Указывается отдельно |
| **Параметры** | `fork()` не принимает параметров | `CreateProcess()` принимает 10 параметров |

#### **Детали CreateProcess (Windows)**

```c
BOOL CreateProcess(
    LPCTSTR lpApplicationName,      // Имя исполняемого файла
    LPTSTR lpCommandLine,           // Командная строка
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,           // Наследование дескрипторов
    DWORD dwCreationFlags,          // Флаги создания
    LPVOID lpEnvironment,           // Переменные окружения
    LPCTSTR lpCurrentDirectory,     // Текущая директория
    LPSTARTUPINFO lpStartupInfo,    // Информация о запуске
    LPPROCESS_INFORMATION lpProcessInformation  // Информация о процессе
);
```

#### **Смена исполняемого кода**

| Аспект | **Unix/Linux** | **Windows** |
|--------|---|---|
| **Функция** | `execve()` (семейство exec функций) | Через `CreateProcess()` + `DLL injection` |
| **Отношение к памяти** | Заменяет image процесса, сохраняет PID | Создаёт новый процесс с новым кодом |
| **Когда используется** | shell вызывает `fork()`, затем дочерний процесс вызывает `execve()` | Обычно всё делается в одном `CreateProcess()` |

#### **Завершение процесса**

| Аспект | **Unix/Linux** | **Windows** |
|--------|---|---|
| **Системный вызов** | `exit(int status)` или `kill()` | `ExitProcess(DWORD exitCode)` или `TerminateProcess()` |
| **Статус выхода** | Возвращает 8-битный код (0-255) | Возвращает 32-битный код (0-4294967295) |
| **Zombie состояние** | Процесс остаётся в системе до `wait()` родителя | Нет состояния Zombie - процесс сразу удаляется, но родитель может прочитать статус |

#### **Иерархия процессов**

| Аспект | **Unix/Linux** | **Windows** |
|--------|---|---|
| **Структура** | Дерево процессов с корнем `init` | Плоская структура (нет явной иерархии) |
| **Родитель** | У каждого процесса есть родитель (PPID) | Нет прямой связи между процессами |
| **Наследование** | Дочерний процесс наследует многие свойства родителя | Минимальное наследование |

#### **Программирование**

**Unix/Linux - типичный паттерн:**
```c
pid_t pid = fork();           // Создание процесса
if (pid == 0) {               // Дочерний процесс
    execve("./program", ...);  // Замена кода
    exit(0);
} else {                       // Родительский процесс
    wait(NULL);                // Ожидание завершения
}
```

**Windows - типичный паттерн:**
```c
PROCESS_INFORMATION pi;
CreateProcess(
    TEXT("C:\\program.exe"),   // Полный путь и имя
    TEXT("arg1 arg2"),         // Параметры
    NULL, NULL, FALSE,
    0,
    NULL,
    NULL,
    &si,
    &pi                        // Информация о процессе
);
WaitForSingleObject(pi.hProcess, INFINITE);
```

### Process Control Block (PCB) / Task Control Block (TCB)

**PCB (Process Control Block)** - это структура данных, которая содержит всю информацию об одном процессе в операционной системе.

#### **Основные компоненты PCB**

##### **1. Идентификация процесса**
- **PID (Process ID)** - уникальный номер процесса в системе
- **PPID (Parent Process ID)** - PID родительского процесса
- **UID (User ID)** - пользователь, запустивший процесс
- **GID (Group ID)** - группа пользователя

##### **2. Состояние процесса**
- **Process State** - текущее состояние (New, Ready, Running, Waiting, Halted)
- Определяет, может ли процесс выполняться в данный момент

##### **3. Управление программой**
- **Program Counter (PC)** - адрес следующей инструкции для выполнения
- **Instruction Pointer** - указатель на текущую инструкцию
- Необходимо для возобновления процесса после прерывания

##### **4. Содержимое регистров процессора**
- **General Purpose Registers** - регистры общего назначения (EAX, EBX, ECX и т.д.)
- **Special Registers**:
  - Stack Pointer (SP) - указатель на стек
  - Frame Pointer (FP) - указатель на фрейм функции
  - Status Register (FLAGS) - флаги состояния ЦП
- **Все это нужно сохранить при переключении контекста**

##### **5. Информация о памяти**
- **Base Register** - базовый адрес адресного пространства процесса
- **Limit Register** - лимит адресного пространства (размер)
- **Page Table Pointer** - указатель на таблицу страниц
- **Segment Table Pointer** - указатель на таблицу сегментов (если используется сегментация)
- Для управления виртуальной памятью

##### **6. Информация о планировании (Scheduling)**
- **Priority** - приоритет процесса для планировщика
- **Scheduling Queue Pointers** - указатели на очереди планировщика (Ready Queue, Wait Queue)
- **CPU Burst Time** - количество времени, которое процесс использовал CPU
- **Wait Time** - время ожидания в очереди Ready

##### **7. Информация о статусе I/O**
- **List of Open Files** - список дескрипторов открытых файлов
- **List of Allocated Devices** - список выделенных устройств
- **I/O Status Information** - статус I/O операций
- Для управления ввод-выводом

##### **8. Информация об учёте ресурсов (Accounting)**
- **CPU Time Used** - сколько CPU-времени использовано
- **Real Time** - реальное время (wall clock time)
- **Time Limits** - ограничения по времени выполнения
- **Account Numbers** - номер счёта/проекта
- **Job/Process Numbers** - внутренние номера

##### **9. Сигналы и обработчики**
- **Signal Handlers** - обработчики сигналов
- **Pending Signals** - ожидающие сигналы
- **Signal Mask** - маска сигналов (какие сигналы блокированы)

##### **10. Информация о потоках (для многопоточных ОС)**
- **Thread Information** - информация о потоках процесса
- **Thread Control Blocks** - для каждого потока свой TCB

#### **Структурное представление PCB в коде**

```c
// Linux kernel - упрощённая версия struct task_struct
struct task_struct {
    // Идентификация
    pid_t pid;
    pid_t ppid;
    uid_t uid, gid;
    
    // Состояние
    long state;
    
    // Регистры и программный счётчик
    struct pt_regs *thread;
    unsigned long instruction_pointer;
    
    // Память
    struct mm_struct *mm;           // Информация о памяти
    struct vm_area_struct *mmap;    // Области памяти
    
    // Планирование
    int prio;                        // Приоритет
    int static_prio;
    struct list_head run_list;       // Очередь планировщика
    unsigned long cpu_time;          // Использованное CPU время
    
    // I/O и файлы
    struct files_struct *files;      // Открытые файлы
    struct fs_struct *fs;            // Информация о файловой системе
    
    // Учёт
    unsigned long cpu_usage;
    unsigned long real_time;
    
    // Потоки
    struct thread_struct thread_info;
    
    // Сигналы
    struct signal_struct *signal;
    sigset_t blocked;
};

// Windows - упрощённая версия структуры процесса
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Дескриптор процесса
    HANDLE hThread;     // Дескриптор основного потока
    DWORD dwProcessId;  // ID процесса (PID)
    DWORD dwThreadId;   // ID основного потока
} PROCESS_INFORMATION;
```

#### **Зачем нужен PCB**

PCB необходим для:

1. **Переключения контекста** - сохранение и восстановление состояния процесса
2. **Планирования** - выбор процесса для выполнения на ЦП
3. **Управления ресурсами** - отслеживание выделенных ресурсов
4. **Прерываний** - обработка прерываний и возврат к процессу
5. **Синхронизации** - координация между процессами
6. **Отладки** - отслеживание выполнения процесса

---

## ВОПРОС 9: Состояния процесса. Таблица процессов. Моделирование режима многозадачности

### Состояния процесса

В течение жизни процесс переходит между несколькими состояниями. Каждое состояние определяет, может ли процесс выполняться в данный момент и почему.

#### **Пять основных состояний**

##### **1. New (Новый)**
- Процесс был только что создан
- ОС выполняет инициализацию:
  - Выделение памяти
  - Инициализация PCB
  - Установка начальных значений регистров
- Процесс ещё не готов к выполнению
- Переход: New → Ready (когда инициализация завершена)

##### **2. Ready (Готов)**
- Процесс полностью инициализирован и готов к выполнению
- Ждёт, когда планировщик назначит ему CPU
- Может быть несколько процессов в состоянии Ready одновременно
- Находятся в очереди Ready Queue
- Переход: Ready → Running (когда CPU назначен процессу планировщиком)

##### **3. Running (Выполняется)**
- Процесс активно выполняется на CPU
- Увеличивается счётчик CPU time в PCB
- Только **один процесс** может быть в состоянии Running на одном CPU core
- На многоядерных системах может быть несколько Running процессов одновременно
- **Переходы:**
  - Running → Ready (при истечении time slice в многозадачной системе)
  - Running → Waiting (при I/O запросе или ожидании события)
  - Running → Terminated (при выходе)

##### **4. Waiting (Ожидание)**
- Процесс не может продолжать выполнение
- Ожидает наступления события:
  - Завершения I/O операции (чтение диска, сетевой ввод-вывод)
  - Получения сигнала (signal)
  - Освобождения синхронизационной переменной (mutex, semaphore)
  - Взаимодействия с другим процессом
- Находится в очереди ожидания (Wait Queue) для конкретного события
- Не потребляет CPU
- Переход: Waiting → Ready (когда событие произойдёт)

##### **5. Terminated (Завершён)**
- Процесс завершил выполнение
- Может быть в состоянии Zombie, ожидая, пока родитель прочитает статус выхода
- ОС может освободить ресурсы процесса (или оставить их для родителя)
- После прочтения статуса родителем процесс окончательно удаляется

#### **Диаграмма состояний процесса**

```
┌─────────────────────────────────────────────────┐
│                    NEW                          │
│        (Инициализация процесса)                 │
└────────────────────┬────────────────────────────┘
                     │ admitted
                     ↓
        ┌────────────────────────┐
        │      READY             │
        │   (В очереди ожидания)  │
        └─────────┬──────────┬───┘
                  │          ↑
       scheduler  │          │ interrupt
       dispatch   │          │ (time slice)
                  ↓          │
        ┌────────────────────┴───┐
        │      RUNNING           │
        │ (Выполняется на CPU)   │
        └────────┬───────────────┘
                 │
        ┌────────┴────────┐
        │                 │
    I/O or event      exit
    wait                 │
        │                 ↓
        │          ┌─────────────────┐
        │          │  TERMINATED     │
        │          │  (Завершён)     │
        │          └─────────────────┘
        │
        ↓
┌─────────────────────┐
│    WAITING          │
│ (Ожидает события)   │
└──────────┬──────────┘
           │ I/O or event
           │ complete
           ↓
        READY
```

### Таблица процессов (Process Table)

**Таблица процессов (Process Table)** - это основная структура данных ОС, которая содержит PCB всех процессов в системе.

#### **Структура таблицы процессов**

```
┌─────────────────────────────────────────────────┐
│       PROCESS TABLE (Таблица процессов)         │
├──────┬──────┬──────┬──────┬──────┬──────┬──────┤
│ PID  │State │ PC   │Mem   │ Prio │Queue │ ...  │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  1   │Ready │ xxx  │yyy   │  10  │ ptr1 │      │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  2   │Runnin│ aaa  │ bbb  │   5  │ ptr2 │      │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  3   │Waitin│ ccc  │ ddd  │  15  │ ptr3 │      │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  4   │Termin│ eee  │ fff  │   0  │  -   │      │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│ ...  │ ...  │ ...  │ ...  │ ...  │ ...  │ ...  │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┘
```

#### **Очереди процессов**

Процессы организованы в очередях в зависимости от состояния:

##### **1. Ready Queue**
- Список всех процессов в состоянии Ready
- Процессы ждут назначения на CPU
- Порядок в очереди определяется планировщиком (FIFO, Priority, RR и т.д.)

##### **2. Wait Queue (для каждого события)**
- Отдельная очередь для каждого вида события
- Например, очередь ожидания I/O от диска, очередь ожидания сетевого ввода-вывода
- Когда событие происходит, процесс перемещается из Wait Queue в Ready Queue

##### **3. Device Queue**
- Для каждого устройства (диск, принтер) есть своя очередь
- Процессы ожидают своей очереди для использования устройства

#### **Операции с таблицей процессов**

```c
// Создание записи в таблице
create_process():
    - Найти свободный слот в таблице
    - Инициализировать PCB
    - Добавить в Ready Queue
    
// Переключение контекста
context_switch(old_process, new_process):
    - Сохранить состояние old_process в его PCB
    - Загрузить состояние new_process из его PCB
    - Обновить регистры процессора
    
// Завершение процесса
terminate_process(pid):
    - Установить состояние процесса как Terminated
    - Освободить ресурсы
    - Оставить запись для parent для прочтения статуса
```

### Моделирование режима многозадачности

**Многозадачность (Multitasking)** - способность ОС выполнять несколько процессов «одновременно» путём переключения между ними.

#### **Основной механизм многозадачности**

На однопроцессорной системе истинный параллелизм невозможен. Вместо этого используется **временное разделение (time sharing)**:

1. **Timer interrupt** - генерируется каждые N миллисекунд (например, 10 мс)
2. **Context switch** - ОС переключается на другой процесс
3. **Планировщик выбирает** следующий процесс для выполнения
4. **Восстановление состояния** - загружаются регистры и PC нового процесса
5. **Выполнение** - новый процесс выполняется

#### **Пример моделирования многозадачности**

Предположим, у нас есть 3 процесса (P1, P2, P3) и time slice = 10 миллисекунд:

```
Время    CPU        Процесс    Состояние          Описание
────────────────────────────────────────────────────────────────
0 мс     P1         P1:Running  ─┐
                    P2:Ready    │ Процесс P1 выполняется
                    P3:Ready    ─┘

10 мс    Timer interrupt!
         ├─ Сохранить PC и регистры P1
         ├─ P1 → Ready Queue
         └─ Выбрать P2 из Ready

10 мс    P2         P1:Ready    ─┐
                    P2:Running  │ Процесс P2 выполняется
                    P3:Ready    ─┘

20 мс    Timer interrupt!
         ├─ Сохранить PC и регистры P2
         ├─ P2 → Ready Queue
         └─ Выбрать P3 из Ready

20 мс    P3         P1:Ready    ─┐
                    P2:Ready    │ Процесс P3 выполняется
                    P3:Running  ─┘

30 мс    Timer interrupt!
         ├─ Сохранить PC и регистры P3
         ├─ P3 → Ready Queue
         └─ Выбрать P1 из Ready (round robin)

30 мс    P1         P1:Running  ─┐
                    P2:Ready    │ Процесс P1 выполняется снова
                    P3:Ready    ─┘

... (цикл повторяется)
```

#### **Код моделирования простой многозадачности**

```c
// Простой симулятор многозадачности
#include <stdio.h>
#include <time.h>

typedef struct {
    int pid;
    int pc;           // Program Counter
    int state;        // 0=Ready, 1=Running, 2=Waiting
    int time_used;
} Process;

#define MAX_PROCESSES 3
#define TIME_SLICE 10  // миллисекунд

Process processes[MAX_PROCESSES];
int current_process = 0;
int current_time = 0;
int remaining_time_slice = TIME_SLICE;

void init_processes() {
    for (int i = 0; i < MAX_PROCESSES; i++) {
        processes[i].pid = i + 1;
        processes[i].pc = 0;
        processes[i].state = 0;  // Ready
        processes[i].time_used = 0;
    }
    processes[0].state = 1;  // P1 Running
}

void context_switch() {
    printf("[%d ms] Context switch!\n", current_time);
    
    // Сохранить текущий процесс
    processes[current_process].state = 0;  // Ready
    printf("  P%d -> Ready (used %d ms)\n", 
           processes[current_process].pid,
           TIME_SLICE);
    
    // Выбрать следующий процесс
    current_process = (current_process + 1) % MAX_PROCESSES;
    processes[current_process].state = 1;  // Running
    printf("  P%d -> Running\n", 
           processes[current_process].pid);
    
    remaining_time_slice = TIME_SLICE;
}

void simulate() {
    init_processes();
    
    printf("=== Моделирование многозадачности ===\n");
    printf("Time Slice = %d ms\n\n", TIME_SLICE);
    
    while (current_time < 100) {
        printf("[%d ms] Running P%d (pc=%d)\n", 
               current_time,
               processes[current_process].pid,
               processes[current_process].pc);
        
        // Выполнение "инструкций"
        processes[current_process].pc += 5;
        processes[current_process].time_used += 10;
        
        current_time += 10;
        remaining_time_slice -= 10;
        
        // Проверка timer interrupt
        if (remaining_time_slice <= 0) {
            context_switch();
        }
    }
    
    printf("\n=== Итоги ===\n");
    for (int i = 0; i < MAX_PROCESSES; i++) {
        printf("P%d: total time = %d ms, PC = %d\n",
               processes[i].pid,
               processes[i].time_used,
               processes[i].pc);
    }
}

int main() {
    simulate();
    return 0;
}
```

#### **Вывод программы:**
```
=== Моделирование многозадачности ===
Time Slice = 10 ms

[0 ms] Running P1 (pc=0)
[10 ms] Context switch!
  P1 -> Ready (used 10 ms)
  P2 -> Running
[10 ms] Running P2 (pc=0)
[20 ms] Context switch!
  P2 -> Ready (used 10 ms)
  P3 -> Running
[20 ms] Running P3 (pc=0)
[30 ms] Context switch!
  P3 -> Ready (used 10 ms)
  P1 -> Running
...
```

#### **Преимущества многозадачности**

1. **Лучшее использование CPU** - когда один процесс ждёт I/O, другой использует CPU
2. **Интерактивность** - пользователь может работать с несколькими приложениями одновременно
3. **Справедливость (Fairness)** - каждый процесс получает определённую долю CPU времени
4. **Быстрый отклик** - система отвечает на события более быстро

#### **Проблемы многозадачности**

1. **Overhead переключения контекста** - требуется время на сохранение/восстановление состояния
2. **Cache thrashing** - изменение процесса может привести к промахам кэша
3. **Сложность синхронизации** - необходимо защищать общие ресурсы
4. **Priority inversion** - высокоприоритетный процесс может быть заблокирован низкоприоритетным

---

## ВОПРОС 10: Механизм прерываний. Доступ пользовательских программ к функциям ОС. Контексты исполнения программного кода.

### Механизм прерываний

**Прерывание (Interrupt)** - это механизм, который позволяет ОС быстро реагировать на события, происходящие вне текущего выполняемого кода.

#### **Типы событий, вызывающих прерывания**

##### **1. Внешние прерывания (External/Hardware Interrupts)**
- От устройств (диск, сетевая карта, клавиатура, мышь)
- **Примеры:**
  - Данные готовы к чтению с клавиатуры
  - Диск завершил операцию чтения/записи
  - Сетевой пакет поступил
  - Истёк тайм-аут (timer)

##### **2. Внутренние прерывания (Software Interrupts)**
- От кода, выполняемого в режиме ядра
- Могда процесс пытается выполнить недопустимую операцию
- **Примеры:**
  - Деление на нуль
  - Обращение к недопустимой памяти (segmentation fault)

##### **3. Исключения (Exceptions)**
- Ошибки в текущей программе
- **Примеры:**
  - Division by zero
  - Page fault (обращение к странице памяти, которой нет в памяти)
  - Invalid instruction

##### **4. Системные вызовы (System Calls / Traps)**
- Программа сознательно переходит в режим ядра через `syscall`
- Запрос функции ОС у ядра

#### **Цикл обработки прерывания**

```
1. ПРЕРЫВАНИЕ ПРОИСХОДИТ
   └─ Устройство ставит сигнал на interrupt request line
   
2. КОНЕЦ ТЕКУЩЕЙ ИНСТРУКЦИИ
   └─ CPU завершает выполнение текущей инструкции
   
3. ПРОВЕРКА INTERRUPT REQUEST LINE
   └─ CPU проверяет после каждой инструкции
   
4. ПЕРЕХОД В РЕЖИМ ЯДРА (Kernel Mode)
   └─ CPU переходит из User Mode в Kernel Mode
   
5. ОПРЕДЕЛЕНИЕ НОМЕРА ПРЕРЫВАНИЯ
   └─ CPU читает номер прерывания из interrupt controller
   └─ Используется как индекс в interrupt vector
   
6. СОХРАНЕНИЕ СОСТОЯНИЯ
   ├─ Сохраняется PC (Program Counter) текущего процесса
   ├─ Сохраняются все регистры
   └─ Сохраняется статус процессора
   
7. ПОИСК ОБРАБОТЧИКА
   └─ interrupt_handler = interrupt_vector[interrupt_number]
   
8. ВЫПОЛНЕНИЕ ОБРАБОТЧИКА
   └─ Выполняется код обработчика прерывания
   └─ Обработчик выполняется в режиме ядра
   
9. ВОЗВРАТ ИЗ ПРЕРЫВАНИЯ
   ├─ Выполняется инструкция "return from interrupt" (IRET)
   ├─ Восстанавливаются все сохранённые регистры
   ├─ Восстанавливается режим (User/Kernel)
   └─ Восстанавливается PC
   
10. ВОЗОБНОВЛЕНИЕ ПРОГРАММЫ
    └─ Программа продолжает выполнение как ни в чём не бывало
```

#### **Временная шкала обработки прерывания**

```
время   CPU              Текущая программа    Interrupt контроллер
────────────────────────────────────────────────────────────────
 0 мс   Выполняет        Инструкция N
        инструкцию N     (выполняется нормально)
        
10 мс   Проверяет        Готовится инструкция  Диск завершил
        interrupt        N+1                   операцию!
        request line     
                                                Сигнал на
                                                interrupt line
        
11 мс   Определён        Инструкция N+1 НЕ    
        interrupt #5     выполняется!
        
12 мс   Переход в        Состояние текущего
        kernel mode      процесса сохранено
        
13 мс   Сохранение       PC, регистры
        состояния        сохранены
        
14 мс   Поиск обработ    interrupt_handler[5]
        чика             найден
        
15 мс   Выполнение       handle_disk_interrupt()
        обработчика      - прочитать данные с диска
                         - поместить в буфер
                         - пробудить ожидающий процесс
        
20 мс   Завершение       handle_disk_interrupt() завершена
        обработчика      
        
21 мс   Восстановление   Состояние восстановлено
        состояния        
        
22 мс   Выполнение       Инструкция N+1
        продолжается     выполняется как обычно
```

### Доступ пользовательских программ к функциям ОС

В современных процессорах есть несколько уровней привилегий:
- **Ring 0 (Kernel Mode)** - максимальные привилегии
- **Ring 3 (User Mode)** - ограниченные привилегии (для приложений)

#### **Проблема: Как пользовательская программа может использовать функции ОС?**

Пользовательская программа не может просто так вызвать функцию ядра, потому что:
1. Это может быть опасно (программа может сделать что-то вредное)
2. Требуется переход в режим ядра
3. Требуется контроль и валидация аргументов

#### **Решение: Системные вызовы (System Calls)**

**Системный вызов** - это управляемый способ для пользовательской программы запросить функцию ядра.

##### **Механизм системного вызова**

```
Пользовательская программа (User Mode)
         │
         │ 1. Подготовка аргументов
         │    (обычно в регистрах или стеке)
         │
         ├─ syscall #5  (например, open)
         │
         ▼
    CPU Переход
         │
         │ 2. Переход в Kernel Mode
         │
         ├─ Сохранение состояния пользователя
         ├─ Загрузка обработчика системного вызова
         │
         ▼
    Ядро ОС (Kernel Mode)
         │
         │ 3. Проверка номера системного вызова
         ├─ Поиск в syscall table
         │
         ▼
    Функция ядра
         │
         │ 4. Выполнение операции
         │    (например, открытие файла)
         │
         ├─ Валидация параметров
         ├─ Проверка прав доступа
         ├─ Выполнение операции
         │
         ▼
    Результат
         │
         │ 5. Возврат результата (обычно в RAX)
         │
         ├─ 0 = успех
         ├─ < 0 = ошибка
         │
         ▼
    Пользовательская программа
         │
         │ 6. Проверка результата
         ├─ if (result < 0) handle_error();
         │
         ▼
    Продолжение выполнения
```

##### **Примеры системных вызовов**

**Linux / Unix:**
```c
// Открытие файла (syscall #2)
int fd = open("file.txt", O_RDONLY);

// Чтение данных (syscall #0)
ssize_t bytes = read(fd, buffer, 4096);

// Создание процесса (syscall #57)
pid_t pid = fork();

// Выполнение программы (syscall #59)
execve("/bin/ls", argv, envp);

// Выход из процесса (syscall #60)
exit(0);

// Установка сигнального обработчика (syscall #13)
signal(SIGTERM, handler);
```

**Windows:**
```c
// CreateFile (аналог open)
HANDLE hFile = CreateFile("file.txt", GENERIC_READ, ...);

// ReadFile (аналог read)
DWORD bytesRead;
ReadFile(hFile, buffer, 4096, &bytesRead, NULL);

// CreateProcess (аналог fork + exec)
PROCESS_INFORMATION pi;
CreateProcess("program.exe", NULL, ...);

// ExitProcess (аналог exit)
ExitProcess(0);
```

##### **Таблица системных вызовов (Syscall Table)**

```c
// Упрощённая версия syscall table Linux x86_64

struct {
    int number;      // номер syscall
    char *name;      // имя
    void (*handler)(void);  // функция обработчика
} syscall_table[] = {
    { 0, "read", sys_read },
    { 1, "write", sys_write },
    { 2, "open", sys_open },
    { 3, "close", sys_close },
    { 4, "stat", sys_stat },
    { 5, "fstat", sys_fstat },
    { 6, "lstat", sys_lstat },
    ...
    { 59, "execve", sys_execve },
    { 60, "exit", sys_exit },
    ...
    { 302, "pselect6", sys_pselect6 },
};
```

#### **Как работает системный вызов (детально)**

```c
// В пользовательской программе
#include <unistd.h>

int main() {
    char buffer[100];
    
    // Вызов системного вызова read
    // Аргументы:
    //   - fd: 0 (stdin)
    //   - buffer: адрес буфера
    //   - count: 100 байт
    int bytes = read(0, buffer, 100);
}

// Что происходит:
// 1. Препроцессор заменяет read() на syscall инструкцию
// 2. Аргументы помещаются в регистры:
//    - rdi = 0 (fd)
//    - rsi = buffer (адрес)
//    - rdx = 100 (count)
// 3. rax = 0 (номер syscall read)
// 4. syscall инструкция генерирует exception #0x80 (на x86)
//    или использует специальный механизм на x86_64
// 5. CPU переходит в kernel mode
// 6. Обработчик exception'а ищет rax в syscall table
// 7. Вызывает sys_read(0, buffer, 100)
// 8. Функция выполняет операцию
// 9. Результат (количество прочитанных байт) помещается в rax
// 10. Инструкция sysret возвращает управление в пользовательский код
// 11. Значение из rax автоматически становится результатом read()
```

### Контексты исполнения

**Контекст исполнения (Execution Context)** - это совокупность информации, необходимой для выполнения кода.

#### **Два основных контекста**

##### **1. User Mode Context (Пользовательский контекст)**

**Характеристики:**
- Ограниченный доступ к памяти и устройствам
- Может выполнять только "безопасные" инструкции
- Не может:
  - Писать в регистры процессора напрямую
  - Обращаться к памяти ядра
  - Выполнять привилегированные инструкции
  - Отключать прерывания

**Как запускаются программы пользователя:**
- Компилируется в машинный код для User Mode
- ОС загружает программу в память
- Устанавливает регистры (PC, SP, etc.)
- Переходит в User Mode (устанавливая флаг режима в регистр статуса)
- Программа выполняется

**Пример User Mode кода:**
```c
int main() {
    int x = 5;
    int y = 10;
    int sum = x + y;  // Обычная инструкция, может выполняться в User Mode
    printf("%d\n", sum);  // printf это системный вызов
    return 0;
}
```

##### **2. Kernel Mode Context (Контекст ядра)**

**Характеристики:**
- Полный доступ к памяти и устройствам
- Может выполнять все инструкции (привилегированные и обычные)
- Может:
  - Читать/писать в памяти ядра
  - Запускать любые инструкции
  - Отключать прерывания
  - Управлять аппаратурой (диск, сеть, и т.д.)

**Когда выполняется ядро:**
- При системном вызове (syscall)
- При прерывании (interrupt)
- При исключении (exception)

**Пример Kernel Mode кода (упрощённый):**
```c
// В ядре Linux
asmlinkage long sys_open(const char __user *filename, int flags, int mode) {
    // Здесь мы в kernel mode
    // Можем напрямую обращаться к таблицам ядра
    
    // Но нельзя напрямую обращаться к пользовательской памяти!
    // Нужно использовать copy_from_user()
    char kfilename[256];
    copy_from_user(kfilename, filename, 256);  // Безопасное копирование
    
    // Открытие файла
    struct file *f = open_file(kfilename);
    
    // Возврат файлового дескриптора
    return f->fd;
}
```

#### **Переходы между контекстами**

```
┌──────────────────────────────────────────────┐
│     USER MODE CONTEXT                        │
│                                              │
│   Пользовательская программа выполняется    │
│                                              │
│   - Ограниченные права                       │
│   - Безопасные инструкции                    │
│   - Собственная память                       │
│                                              │
└───────────────────┬──────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
    syscall               Прерывание (interrupt)
    (например,            или исключение
     read, write,
     fork, etc)
        │                       │
        └───────────┬───────────┘
                    │
                    ▼
        ┌──────────────────────────────────────┐
        │   KERNEL MODE CONTEXT                │
        │                                      │
        │   ОС выполняет операцию              │
        │                                      │
        │   - Полные права доступа             │
        │   - Все инструкции                   │
        │   - Память ядра и пользователя       │
        │                                      │
        └───────────┬──────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
    Возврат из syscall      Обработчик прерывания
    (sysret)               завершен (iret)
        │                       │
        └───────────┬───────────┘
                    │
                    ▼
        ┌──────────────────────────────────────┐
        │   USER MODE CONTEXT                  │
        │   (продолжение программы)            │
        │                                      │
        │   Результат syscall в rax            │
        └──────────────────────────────────────┘
```

#### **Переключение между процессами (также контекстное переключение)**

Переключение между процессами - это частный случай изменения контекста:

```
Time   Контекст          Процесс    PC     Регистры    Память
──────────────────────────────────────────────────────────────
0 мс   User Mode         P1:User    100    rax=5       P1_mem
       Context P1                   ebx=10  rbx=10
       
10 мс  Timer Interrupt!
       ├─ Сохранить состояние P1
       ├─ PC1=110, rax=5, rbx=10
       └─ Загрузить состояние P2

       Kernel Mode       (Timer    -       -           -
       Context (Ядро)    interrupt)
       
       ├─ Выполнить scheduler
       ├─ Выбрать P2
       └─ Подготовить контекст P2

       User Mode         P2:User    200    rax=20      P2_mem
       Context P2                   ebx=30  rbx=30

20 мс  Выполнение P2 продолжается...

30 мс  Timer Interrupt!
       (Повтор цикла для P3, P1, ...)
```

#### **Сохранение и восстановление контекста**

```c
// В ядре (упрощённый код на pseudo-C / ассемблере)

void context_switch(struct task_struct *old_task, 
                    struct task_struct *new_task) {
    // СОХРАНЕНИЕ контекста old_task
    save_context(&old_task->context);
    
    // Это может быть сделано в ассемблере:
    // movq %rax, old_task->rax
    // movq %rbx, old_task->rbx
    // movq %rcx, old_task->rcx
    // ... (все регистры)
    // movq %rsp, old_task->sp
    // movq $return_address, old_task->pc
    
    // ЗАГРУЗКА контекста new_task
    restore_context(&new_task->context);
    
    // Это может быть:
    // movq new_task->rax, %rax
    // movq new_task->rbx, %rbx
    // movq new_task->rcx, %rcx
    // ... (все регистры)
    // movq new_task->sp, %rsp
    // jmp *new_task->pc  // Перейти к сохранённому PC
}
```

---

## ВОПРОС 11: Кооперация процессов. Причины кооперации. Способы межпроцессной коммуникации

### Кооперация процессов

**Кооперация процессов** - это механизм взаимодействия между двумя или несколькими процессами для выполнения общей задачи.

#### **Причины кооперации процессов**

##### **1. Информационный обмен (Information sharing)**
- Процессы нуждаются в обмене данными друг с другом
- **Пример:** Процесс A генерирует данные, процесс B их обрабатывает

##### **2. Ускорение вычислений (Computation speedup)**
- Разделение задачи между несколькими процессами для параллельного выполнения
- **Пример:** Обработка большого файла несколькими процессами параллельно
- **Требование:** Система должна быть многопроцессорной или многоядерной

##### **3. Модульность (Modularity)**
- Разделение программы на несколько модулей (процессов) для лучшей организации
- **Пример:** Web-сервер может быть разбит на процесс слушателя (listener) и рабочие процессы (workers)

##### **4. Удобство программирования (Convenience)**
- Некоторые задачи легче написать как несколько процессов, чем как один
- **Пример:** GUI приложение - один процесс для UI, другой для фоновых задач

##### **5. Отказоустойчивость (Fault tolerance)**
- Если один процесс упадёт, другие могут продолжить работу
- **Пример:** Database replication - несколько процессов ведут БД

### Способы межпроцессной коммуникации (IPC - Interprocess Communication)

#### **1. Shared Memory (Общая память)**

##### **Принцип:**
- Процессы используют общую область памяти для обмена данными
- Оба процесса могут читать и писать в одно и то же место памяти
- Самый быстрый способ IPC

##### **Реализация POSIX:**

```c
// ПРОЦЕСС 1: Создание и запись в shared memory

#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 1. Создание объекта shared memory
    int shm_fd = shm_open("/my_memory", O_CREAT | O_RDWR, 0666);
    
    // 2. Устанавливаем размер
    ftruncate(shm_fd, 4096);
    
    // 3. Отображаем в адресное пространство процесса
    void *shm_ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                         MAP_SHARED, shm_fd, 0);
    
    // 4. Записываем данные
    char *message = (char *)shm_ptr;
    strcpy(message, "Hello from Process 1!");
    
    // 5. Ждём завершения (например, 10 секунд)
    sleep(10);
    
    // 6. Очистка
    munmap(shm_ptr, 4096);
    shm_unlink("/my_memory");
    
    return 0;
}
```

```c
// ПРОЦЕСС 2: Чтение из shared memory

#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 1. Открываем существующий shared memory объект
    int shm_fd = shm_open("/my_memory", O_RDONLY, 0666);
    
    // 2. Отображаем в адресное пространство
    void *shm_ptr = mmap(NULL, 4096, PROT_READ,
                         MAP_SHARED, shm_fd, 0);
    
    // 3. Читаем данные
    char *message = (char *)shm_ptr;
    printf("Received: %s\n", message);
    
    // 4. Очистка
    munmap(shm_ptr, 4096);
    
    return 0;
}
```

##### **Преимущества:**
- Очень быстро (прямой доступ к памяти)
- Можно обмениваться большими объёмами данных

##### **Недостатки:**
- Сложная синхронизация (race conditions)
- Требуется использовать mutex или semaphore
- Не подходит для удалённых процессов

##### **Макет shared memory:**

```
Процесс A              Shared Memory           Процесс B
┌────────────────┐     ┌──────────────┐     ┌────────────────┐
│ Адресное       │────→│ Одна и та    │←────│ Адресное       │
│ пространство A │     │ же область   │     │ пространство B │
│                │     │ в физической │     │                │
│ ptr_a ────────────┐  │ памяти       │  ┌──→ ptr_b         │
└────────────────┘  └──→│              │←─┘  └────────────────┘
                        └──────────────┘
                        Содержимое:
                        "message"
                        data_struct
                        buffer[100]
                        count = 42
```

#### **2. Message Passing (Передача сообщений)**

##### **Принцип:**
- Процессы отправляют друг другу сообщения
- Взаимодействие асинхронное
- ОС обеспечивает доставку сообщений

##### **Реализация:**

```c
// ПРОЦЕСС 1: Отправка сообщения

#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

struct message {
    long type;           // Тип сообщения
    char data[256];      // Данные
};

int main() {
    // 1. Получаем очередь сообщений (создаём или открываем)
    key_t key = ftok(".", 'A');
    int msgid = msgget(key, IPC_CREAT | 0666);
    
    // 2. Создаём сообщение
    struct message msg;
    msg.type = 1;
    strcpy(msg.data, "Hello from Process 1!");
    
    // 3. Отправляем сообщение
    msgsnd(msgid, &msg, sizeof(msg.data), 0);
    
    printf("Message sent!\n");
    
    return 0;
}
```

```c
// ПРОЦЕСС 2: Приём сообщения

#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

struct message {
    long type;
    char data[256];
};

int main() {
    // 1. Открываем очередь сообщений
    key_t key = ftok(".", 'A');
    int msgid = msgget(key, 0666);
    
    // 2. Ожидаем сообщение
    struct message msg;
    msgrcv(msgid, &msg, sizeof(msg.data), 1, 0);
    
    // 3. Обрабатываем сообщение
    printf("Received: %s\n", msg.data);
    
    return 0;
}
```

##### **Преимущества:**
- Изолированность (процессы не видят друг друга память)
- Безопасность
- Синхронизация встроена (блокирующие операции)

##### **Недостатки:**
- Медленнее shared memory
- Требует копирования данных
- Требует большей памяти (буферы очереди)

#### **3. Pipes (Каналы)**

##### **Принцип:**
- Однонаправленный канал связи между процессами
- Один конец для записи, другой для чтения
- Работает как файл

##### **Типы pipes:**

**Unnamed pipe (безымянный канал):**
```c
#include <unistd.h>

int main() {
    int pipefd[2];  // pipefd[0] = читаемый конец
                    // pipefd[1] = писаемый конец
    
    // Создание pipe
    pipe(pipefd);
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс: ЧИТАЕТ из pipe
        close(pipefd[1]);  // Закрыть писаемый конец
        
        char buffer[100];
        read(pipefd[0], buffer, 100);
        printf("Child received: %s\n", buffer);
        
        close(pipefd[0]);
    } else {
        // Родительский процесс: ПИШЕТ в pipe
        close(pipefd[0]);  // Закрыть читаемый конец
        
        write(pipefd[1], "Hello from parent", 17);
        
        close(pipefd[1]);
        wait(NULL);
    }
    
    return 0;
}
```

**Named pipe (FIFO - именованный канал):**
```c
// Создание FIFO
mkfifo("/tmp/my_pipe", 0666);

// Писатель
int fd = open("/tmp/my_pipe", O_WRONLY);
write(fd, "message", 7);
close(fd);

// Читатель
int fd = open("/tmp/my_pipe", O_RDONLY);
char buffer[100];
read(fd, buffer, 100);
close(fd);
```

##### **Макет pipe:**

```
Процесс A              Pipe                Процесс B
┌──────────────┐      ┌──────┐           ┌──────────────┐
│ Код A        │      │      │           │ Код B        │
├──────────────┤      │      │           ├──────────────┤
│ write(...) ──┼────→ │ Buffer├──────────→│ read(...)    │
│              │      │ [Data]│           │              │
│ printf(...) │      │      │           │ process()    │
└──────────────┘      │      │           └──────────────┘
                      └──────┘
```

##### **Преимущества:**
- Простота использования
- Встроенная буферизация
- Хорошо для потока данных

##### **Недостатки:**
- Однонаправленный (нужны 2 pipe для двусторонней коммуникации)
- Ограниченный размер буфера

#### **4. Сокеты (Sockets)**

##### **Принцип:**
- Двусторонний канал коммуникации
- Работает локально (между процессами) и по сети
- Основан на протоколах TCP/UDP

##### **Реализация:**

```c
// СЕРВЕР

#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

int main() {
    // 1. Создание сокета
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    
    // 2. Связывание с адресом
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(8888);
    
    bind(server_socket, (struct sockaddr*)&addr, sizeof(addr));
    
    // 3. Прослушивание входящих соединений
    listen(server_socket, 5);
    
    // 4. Принятие соединения
    int client_socket = accept(server_socket, NULL, NULL);
    
    // 5. Обмен данными
    char buffer[256];
    recv(client_socket, buffer, 256, 0);
    printf("Received: %s\n", buffer);
    
    send(client_socket, "Hello from server!", 18, 0);
    
    // 6. Закрытие
    close(client_socket);
    close(server_socket);
    
    return 0;
}
```

```c
// КЛИЕНТ

#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main() {
    // 1. Создание сокета
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    
    // 2. Подключение к серверу
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(8888);
    
    connect(client_socket, (struct sockaddr*)&addr, sizeof(addr));
    
    // 3. Отправка данных
    send(client_socket, "Hello from client!", 18, 0);
    
    // 4. Приём данных
    char buffer[256];
    recv(client_socket, buffer, 256, 0);
    printf("Received: %s\n", buffer);
    
    // 5. Закрытие
    close(client_socket);
    
    return 0;
}
```

##### **Преимущества:**
- Двусторонняя коммуникация
- Может работать по сети
- Гибкий (TCP, UDP)

##### **Недостатки:**
- Сложнее чем pipes
- Больше overhead

#### **Сравнение механизмов IPC**

| Характеристика | Shared Memory | Message Passing | Pipes | Sockets |
|---|---|---|---|---|
| **Скорость** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **Простота** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐ |
| **Безопасность** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **Направление** | Двусторонняя | Двусторонняя | Односторонняя | Двусторонняя |
| **По сети** | ❌ | ❌ | ❌ | ✅ |
| **Буферизация** | Нет | Да | Да | Да |
| **Синхронизация** | Требуется | Встроена | Встроена | Встроена |

---

## ВОПРОС 12: Каналы (pipes). Особенности работы различных видов каналов. Организация процессов в группы

### Каналы (Pipes)

**Pipe** - это механизм межпроцессной коммуникации, который обеспечивает однонаправленный поток данных между процессами.

#### **Основные характеристики pipes**

1. **Однонаправленный** - данные текут в одном направлении
2. **FIFO (First In First Out)** - данные обрабатываются в порядке поступления
3. **Буферизованный** - имеет ограниченный буфер (обычно 4-65 KB)
4. **Синхронный** - если буфер полон, писатель блокируется
5. **Работает только между связанными процессами** - обычно родитель-дитя

#### **Типы pipes**

##### **1. Unnamed Pipes (Безымянные каналы)**

**Создание и использование:**

```c
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    int pipefd[2];
    
    // Создание pipe
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        return 1;
    }
    
    pid_t pid = fork();
    
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }
    
    if (pid == 0) {
        // ДОЧЕРНИЙ ПРОЦЕСС - ЧИТАЕТ
        close(pipefd[1]);  // Закрыть писаемый конец
        
        char buffer[100];
        ssize_t bytes = read(pipefd[0], buffer, 100);
        
        printf("[Child] Received %zd bytes: %s\n", bytes, buffer);
        
        close(pipefd[0]);
        
    } else {
        // РОДИТЕЛЬСКИЙ ПРОЦЕСС - ПИШЕТ
        close(pipefd[0]);  // Закрыть читаемый конец
        
        const char *message = "Hello from parent!";
        write(pipefd[1], message, strlen(message));
        
        printf("[Parent] Sent message\n");
        
        close(pipefd[1]);
        wait(NULL);  // Ждём дочернего процесса
    }
    
    return 0;
}
```

**Структура pipe в памяти:**

```
Файловая таблица процессов:
┌───────────────────────────────────┐
│ Процесс A (Родитель)              │
├───────┬───────────────────────────┤
│ FD  │ File Pointer                │
├───────┼───────────────────────────┤
│  0  │ stdin                       │
│  1  │ stdout                      │
│  2  │ stderr                      │
│  3  │ → [Pipe Buffer] ← (запись) │
└─────┴───────────────────────────┘

┌───────────────────────────────────┐
│ Процесс B (Дочерний)              │
├───────┬───────────────────────────┤
│ FD  │ File Pointer                │
├───────┼───────────────────────────┤
│  0  │ stdin                       │
│  1  │ stdout                      │
│  2  │ stderr                      │
│  3  │ → [Pipe Buffer] ← (чтение) │
└─────┴───────────────────────────┘

Общий ресурс:
┌──────────────────────────────────┐
│  Pipe Buffer (ядро ОС)           │
│  ┌─────────────────────────────┐ │
│  │ "Hello from parent!"        │ │
│  └─────────────────────────────┘ │
│  Размер: 4096 байт (обычно)     │
└──────────────────────────────────┘
```

##### **Особенности работы:**

1. **Блокирование при записи:**
```c
// Если буфер pipe полон (4096 байт), write() блокируется
// до тех пор, пока читатель не прочитает данные
write(pipefd[1], large_data, 10000);  // Может заблокироваться
```

2. **Блокирование при чтении:**
```c
// Если в pipe нет данных, read() блокируется
// до тех пор, пока писатель не напишет
char buffer[100];
read(pipefd[0], buffer, 100);  // Может ждать
```

3. **EOF (Конец файла):**
```c
// Когда писатель закрывает pipe, read() возвращает 0
close(pipefd[1]);
// Дочерний процесс получит EOF
ssize_t n = read(pipefd[0], buffer, 100);  // n = 0
```

##### **2. Named Pipes (FIFO - Именованные каналы)**

**Создание FIFO:**

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main() {
    const char *fifo_path = "/tmp/my_fifo";
    
    // Создание FIFO файла
    mkfifo(fifo_path, 0666);
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // ДОЧЕРНИЙ ПРОЦЕСС - ЧИТАЕТ
        printf("[Reader] Opening FIFO...\n");
        int fd = open(fifo_path, O_RDONLY);
        
        char buffer[100];
        ssize_t bytes = read(fd, buffer, 100);
        printf("[Reader] Received: %s\n", buffer);
        
        close(fd);
        
    } else {
        // РОДИТЕЛЬСКИЙ ПРОЦЕСС - ПИШЕТ
        sleep(1);  // Даём дочернему процессу время открыть FIFO
        
        printf("[Writer] Opening FIFO...\n");
        int fd = open(fifo_path, O_WRONLY);
        
        write(fd, "Hello via FIFO!", 15);
        printf("[Writer] Sent message\n");
        
        close(fd);
        wait(NULL);
    }
    
    // Удаление FIFO файла
    unlink(fifo_path);
    
    return 0;
}
```

**Отличия от unnamed pipes:**

| Характеристика | Unnamed Pipe | Named Pipe (FIFO) |
|---|---|---|
| **Существование** | Только в памяти | Как файл в FS |
| **Видимость** | Только для связанных процессов | Видны всем процессам |
| **Создание** | `pipe(pipefd)` | `mkfifo(path, mode)` |
| **Доступ** | Через FD | Через имя файла |
| **Связь** | Только родитель-дитя | Любые процессы |
| **Жизненный цикл** | Исчезает когда закроют все процессы | Существует в FS пока не удалят |

**Пример использования FIFO:**

```bash
# Terminal 1: Читатель
$ cat < /tmp/my_fifo
# Ожидает данных...

# Terminal 2: Писатель
$ echo "Hello from shell" > /tmp/my_fifo

# Terminal 1: Выводит
# Hello from shell
```

##### **3. Двусторонняя коммуникация через pipes**

Для двусторонней коммуникации нужно **два pipe**:

```c
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    // Pipe 1: Родитель → Дочерний процесс
    int pipe1[2];  
    // Pipe 2: Дочерний процесс → Родитель
    int pipe2[2];
    
    pipe(pipe1);
    pipe(pipe2);
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // ДОЧЕРНИЙ ПРОЦЕСС
        close(pipe1[1]);  // Не пишем в pipe1
        close(pipe2[0]);  // Не читаем из pipe2
        
        // Читаем из pipe1
        char buffer[100];
        read(pipe1[0], buffer, 100);
        printf("[Child] Received: %s\n", buffer);
        
        // Пишем в pipe2
        write(pipe2[1], "Response from child", 19);
        
        close(pipe1[0]);
        close(pipe2[1]);
        
    } else {
        // РОДИТЕЛЬСКИЙ ПРОЦЕСС
        close(pipe1[0]);  // Не читаем из pipe1
        close(pipe2[1]);  // Не пишем в pipe2
        
        // Пишем в pipe1
        write(pipe1[1], "Hello from parent", 16);
        
        // Читаем из pipe2
        char buffer[100];
        read(pipe2[0], buffer, 100);
        printf("[Parent] Received: %s\n", buffer);
        
        close(pipe1[1]);
        close(pipe2[0]);
        
        wait(NULL);
    }
    
    return 0;
}
```

**Диаграмма двусторонней коммуникации:**

```
Родитель                           Дочерний процесс
    │                                     │
    │  Pipe 1 (P → D)                     │
    ├────────────────────────────────────>│
    │  "Hello from parent"                │ read()
    │                                     │
    │                                     │
    │                                     │ Обработка
    │                                     │
    │  Pipe 2 (D → P)                     │
    │<────────────────────────────────────┤
    │ read()   "Response from child"      │
    │                                     │
```

#### **Буферизация в pipes**

**Буфер pipe имеет ограниченный размер:**

```
Размер буфера: обычно 4-65 KB (зависит от OS и конфигурации)

Состояния:
1. EMPTY (Пусто)
   ┌─────────────────────────────┐
   │                             │
   │  write() может писать       │
   │  read() будет ждать         │
   └─────────────────────────────┘

2. PARTIAL (Частично заполнен)
   ┌─────────────────────────────┐
   │ [Data]                      │
   │ write() может писать        │
   │ read() может читать         │
   └─────────────────────────────┘

3. FULL (Полностью заполнен)
   ┌─────────────────────────────┐
   │ [Data][Data][Data][Data]... │
   │ write() БУДЕТ ЖДАТЬ         │
   │ read() должен читать        │
   └─────────────────────────────┘
```

**Пример с буферизацией:**

```c
int main() {
    int pipefd[2];
    pipe(pipefd);
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс - МЕДЛЕННО читает
        close(pipefd[1]);
        
        char buffer[1];
        for (int i = 0; i < 100000; i++) {
            read(pipefd[0], buffer, 1);
            // Очень медленно, с задержкой
            usleep(1000);  // 1 мс между чтениями
        }
        
        close(pipefd[0]);
        
    } else {
        // Родитель - пишет в pipe
        close(pipefd[0]);
        
        // Первые 4-65 KB напишутся быстро
        // После этого write() будет блокироваться
        // пока дочерний процесс не прочитает
        
        for (int i = 0; i < 100000; i++) {
            write(pipefd[1], "A", 1);
            if (i % 10000 == 0) {
                printf("Written %d bytes\n", i);
            }
        }
        
        close(pipefd[1]);
        wait(NULL);
    }
    
    return 0;
}
```

### Организация процессов в группы

**Группа процессов (Process Group)** - это набор процессов, которые могут получать сигналы вместе.

#### **Концепция групп процессов**

##### **Зачем нужны группы процессов?**

1. **Управление группой** - отправить сигнал всей группе одной командой
2. **Job control** - в shell'е можно запустить "job" (группу процессов)
3. **Изоляция** - процессы в группе логически связаны

##### **Иерархия в Unix/Linux:**

```
Session (Сессия)
    │
    └─ Process Group 1 (Группа процессов 1)
    │      ├─ Process A
    │      ├─ Process B
    │      └─ Process C
    │
    └─ Process Group 2 (Группа процессов 2)
           ├─ Process D
           └─ Process E
```

#### **Операции с группами процессов**

**Получение информации:**

```c
#include <unistd.h>

int main() {
    // Получить GID (Group ID) текущего процесса
    pid_t pgid = getpgrp();  // или getpgid(0)
    
    printf("Process ID: %d\n", getpid());
    printf("Process Group ID: %d\n", pgid);
    printf("Parent Process ID: %d\n", getppid());
    
    return 0;
}
```

**Создание новой группы:**

```c
#include <unistd.h>

int main() {
    // Создать новую группу процессов
    // Новый лидер группы будет текущий процесс
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс становится лидером группы
        setpgrp();  // или setpgid(0, 0)
        
        printf("[Child] New process group created\n");
        printf("[Child] My PID: %d\n", getpid());
        printf("[Child] My PGID: %d\n", getpgrp());
        
    } else {
        printf("[Parent] Child PID: %d\n", pid);
    }
    
    return 0;
}
```

#### **Использование группы процессов для сигналов**

**Отправка сигнала всей группе:**

```c
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pgid = getpgrp();  // Получить PGID текущей группы
    
    // Отправить сигнал SIGTERM всей группе
    killpg(pgid, SIGTERM);
    
    // Это эквивалентно отправке сигнала каждому процессу в группе:
    // kill(pid1, SIGTERM);
    // kill(pid2, SIGTERM);
    // ...
    
    return 0;
}
```

#### **Shell job control**

В shell'е группы процессов используются для управления "jobs":

```bash
# Запуск процесса в фоне
$ ./long_running_program &
[1] 12345

# Список всех job'ов
$ jobs
[1]+ Running    ./long_running_program

# Отправка сигнала всей группе (job'у)
$ kill %1       # Убить job номер 1
$ kill -STOP %1 # Остановить job

# Перемещение job'а на передний план
$ fg %1

# Перемещение job'а в фон
$ bg %1

# Остановка текущего job'а
$ ^Z  (Ctrl+Z)
[1]+ Stopped    ./long_running_program
```

**Как это работает в коде:**

```c
// Простой shell с job control

#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    pid_t pid;
    pid_t pgid;
    char command[256];
    int status;  // 0=running, 1=stopped
} Job;

#define MAX_JOBS 10
Job jobs[MAX_JOBS];
int job_count = 0;

int main() {
    char command[256];
    
    while (1) {
        printf("shell> ");
        fgets(command, sizeof(command), stdin);
        
        pid_t pid = fork();
        
        if (pid == 0) {
            // Дочерний процесс - создать новую группу
            setpgrp();  // Этот процесс становится лидером группы
            
            // Выполнить команду
            system(command);
            exit(0);
            
        } else {
            // Родительский процесс (shell) - регистрирует job
            printf("[%d] %d\n", job_count + 1, pid);
            
            jobs[job_count].pid = pid;
            jobs[job_count].pgid = pid;  // Лидер группы имеет PID == PGID
            strcpy(jobs[job_count].command, command);
            jobs[job_count].status = 0;
            
            job_count++;
            
            // Ждём завершения (если команда не в фоне)
            if (command[strlen(command)-2] != '&') {
                wait(NULL);
            }
        }
    }
    
    return 0;
}
```

#### **Сессии (Sessions)**

**Сессия** - это группа групп процессов.

```
TTY (Terminal)
    │
    └─ Session
          │
          ├─ Foreground Process Group
          │      ├─ Process A (лидер)
          │      ├─ Process B
          │      └─ Process C
          │
          └─ Background Process Groups
                 ├─ Process Group 2
                 │      ├─ Process D (лидер)
                 │      └─ Process E
                 │
                 └─ Process Group 3
                        └─ Process F
```

**Контроль сессии:**

```c
#include <unistd.h>

int main() {
    // Создать новую сессию (текущий процесс становится лидером)
    setsid();
    
    pid_t sid = getsid(0);  // Получить SID
    printf("Session ID: %d\n", sid);
    
    return 0;
}
```

---

## Заключение

В этой главе мы рассмотрели основные концепции процессов в операционных системах:

1. **Память процесса** - организована в четыре секции (text, data, heap, stack)
2. **PCB** - ключевая структура, содержащая всю информацию о процессе
3. **Состояния процесса** - New, Ready, Running, Waiting, Terminated
4. **Многозадачность** - временное разделение CPU между процессами
5. **Прерывания** - механизм быстрого реагирования на события
6. **Системные вызовы** - путь для пользовательских программ получить услуги ОС
7. **Кооперация** - взаимодействие между процессами
8. **IPC механизмы** - shared memory, message passing, pipes, sockets
9. **Группы процессов** - организация процессов для управления сигналами

---

**Создано:** Январь 2026
**Версия:** 1.0
**Статус:** Готово к использованию на экзамене