# Файловые системы

Файловые системы - продолжи ... 

---

## 38. Общие положения файловых систем. Понятие файла. Структура файла. Типы и характеристики файлов. Понятие Каталога. Операции над файлами и каталогами

### Понятие файла

**Файл** — это именованная последовательность байтов, хранящаяся на внешнем запоминающем устройстве (обычно на диске). Файл является абстракцией, которая скрывает детали физической организации данных и позволяет приложениям работать с информацией независимо от ее физического размещения.

**Основные характеристики файла:**
- **Имя** — уникальный идентификатор файла в пределах каталога
- **Расширение** — суффикс имени файла, указывающий на тип содержимого
- **Путь** — последовательность каталогов, ведущая к файлу
- **Размер** — количество байтов в файле
- **Метаданные** — атрибуты файла (время создания, владелец, права доступа и т.д.)

### Структура файла

Файл организуется как последовательность логических записей различных размеров:

**Форматы файлов:**
1. **Байтовые файлы** — файлы без какой-либо структуры, просто последовательность байтов (текстовые файлы в Unix/Linux)
2. **Файлы с записями фиксированной длины** — файлы, состоящие из записей одинакового размера
3. **Древовидные файлы** — структурированные файлы, содержащие иерархию записей

**В современных ОС наиболее распространены байтовые файлы**, которые предоставляют максимальную гибкость приложениям в интерпретации содержимого.

### Типы файлов

**В Unix/Linux выделяют следующие типы:**

1. **Обычные файлы** — содержат данные (текст, двоичные данные, исполняемый код)
2. **Каталоги (директории)** — специальные файлы, содержащие информацию об именах и расположении других файлов
3. **Блочные устройства** (`/dev/`) — позволяют доступ к блочным устройствам (диски, разделы)
4. **Символьные устройства** (`/dev/`) — позволяют доступ к символьным устройствам (терминалы, принтеры)
5. **Именованные каналы (FIFO)** — используются для межпроцессного взаимодействия
6. **Сокеты** — служат для сетевого взаимодействия между процессами
7. **Символические ссылки** — ссылки на другие файлы (могут быть на другие диски и системы)

### Характеристики файлов

Каждый файл имеет в своей метаинформации (i-узле) следующие характеристики:

| Характеристика | Описание |
|---|---|
| **Размер** | Количество байтов в файле |
| **Владелец (UID)** | Идентификатор пользователя, создавшего файл |
| **Группа (GID)** | Группа, к которой принадлежит файл |
| **Права доступа** | rwx права для владельца, группы и остальных |
| **Время создания** | Время, когда файл был создан |
| **Время модификации** | Время последнего изменения содержимого |
| **Время доступа** | Время последнего чтения файла |
| **Время изменения метаданных** | Время изменения параметров i-узла |
| **Количество ссылок** | Количество имен, указывающих на этот файл |
| **Номер i-узла** | Уникальный идентификатор файла в файловой системе |
| **Права SETUID/SETGID** | Флаги, позволяющие выполнить файл с правами владельца |

### Понятие каталога

**Каталог (директория)** — это специальный файл, который содержит таблицу, связывающую имена файлов с их i-узлами. Каталог описывает структуру файловой системы, образуя иерархическую древовидную структуру.

**Структура записи в каталоге:**
```
Имя файла | Номер i-узла
```

Например:
```
.       | 15420
..      | 8193
file1.c | 15421
file2.o | 15422
src     | 15423
```

**Иерархия каталогов:**
- **Корневой каталог** (`/`) — верхушка иерархии
- **Абсолютный путь** — путь от корня: `/usr/bin/gcc`
- **Относительный путь** — путь от текущего каталога: `../src/file.c`
- **Текущий каталог** (`.`) — указатель на сам себя
- **Родительский каталог** (`..`) — указатель на родителя

### Операции над файлами

**Основные системные вызовы для работы с файлами:**

```c
// Создание/открытие файла
int open(const char *path, int flags, mode_t mode);

// Создание нового файла (стандартный C)
FILE *fopen(const char *filename, const char *mode);

// Чтение из файла
ssize_t read(int fd, void *buf, size_t count);

// Запись в файл
ssize_t write(int fd, const void *buf, size_t count);

// Закрытие файла
int close(int fd);

// Перемещение указателя в файле
off_t lseek(int fd, off_t offset, int whence);

// Получение информации о файле
int stat(const char *path, struct stat *buf);

// Удаление файла
int unlink(const char *path);

// Переименование файла
int rename(const char *oldpath, const char *newpath);
```

**Флаги при открытии файла:**
- `O_RDONLY` — открыть для чтения
- `O_WRONLY` — открыть для записи
- `O_RDWR` — открыть для чтения и записи
- `O_CREAT` — создать файл, если не существует
- `O_TRUNC` — обрезать файл до нулевой длины
- `O_APPEND` — добавлять данные в конец файла

### Операции над каталогами

**Системные вызовы для работы с каталогами:**

```c
// Создание каталога
int mkdir(const char *path, mode_t mode);

// Удаление каталога (пустого)
int rmdir(const char *path);

// Изменение текущего каталога
int chdir(const char *path);

// Создание ссылки (жесткой)
int link(const char *oldpath, const char *newpath);

// Создание символической ссылки
int symlink(const char *target, const char *linkpath);

// Получение текущего рабочего каталога
char *getcwd(char *buf, size_t size);

// Открытие каталога для чтения
DIR *opendir(const char *name);

// Чтение записи из каталога
struct dirent *readdir(DIR *dirp);

// Закрытие каталога
int closedir(DIR *dirp);
```

**Структура dirent (запись каталога):**
```c
struct dirent {
    ino_t d_ino;        // Номер i-узла
    char d_name[256];   // Имя файла
};
```

---

## 39. Структура файловой системы. Реализация файлов. Непрерывное размещение файлов и I-узлы. Совместно используемые файлы

### Непрерывное размещение файлов

**Непрерывное размещение (contiguous allocation)** — это метод, при котором каждый файл занимает непрерывную последовательность блоков на диске.

**Преимущества:**
- Очень быстрый доступ к файлу (нужна одна операция поиска)
- Простое вычисление адреса блока: `адрес_блока = начальный_блок + смещение`
- Минимальные затраты на метаданные (нужно хранить только начало и длину)
- Хороший контроль над фрагментацией — фрагментация отсутствует

**Недостатки:**
- Внешняя фрагментация — со временем появляются "дыры" между файлами
- Сложно расширять файлы — может не быть достаточно места после файла
- Требуется знать размер файла при создании (в некоторых системах)
- Неэффективное использование дискового пространства

**Пример:**
```
Диск:
[Блоки 0-5: файл A] [Пустой 6-9] [Блоки 10-14: файл B] [Пустой 15]

Таблица размещения файлов:
файл A: начало = 0, длина = 6
файл B: начало = 10, длина = 5
```

**Применение:** Используется в DVD, Blu-ray и других оптических носителях, где фрагментация не происходит.

### I-узлы (inode)

**I-узел (inode, index node)** — это структура метаданных, которая описывает файл. I-узел содержит всю информацию о файле кроме его имени и содержимого.

**Структура i-узла (на примере ext2):**

| Поле | Размер | Описание |
|---|---|---|
| Mode | 2 байта | Тип файла и права доступа (rwx) |
| Owner (UID) | 2 байта | Идентификатор владельца |
| Group (GID) | 2 байта | Идентификатор группы |
| Size | 4 байта | Размер файла в байтах |
| Atime | 4 байта | Время последнего доступа |
| Mtime | 4 байта | Время последней модификации |
| Ctime | 4 байта | Время изменения метаданных |
| Nlink | 2 байта | Количество жестких ссылок |
| Blocks | 4 байта | Количество блоков диска, занятых файлом |
| Addr[0-11] | 12×4 = 48 байт | Прямые указатели на блоки данных |
| Addr[12] | 4 байта | Указатель на блок косвенных указателей |
| Addr[13] | 4 байта | Указатель на блок двойных косвенных указателей |
| Addr[14] | 4 байта | Указатель на блок тройных косвенных указателей |

**Всего в i-узле ext2: 128 байт**

**Как работает адресация в i-узле:**

Предположим, размер блока = 4 КБ (4096 байт), размер указателя = 4 байта.

1. **Первые 12 блоков (Addr[0-11])** — прямые указатели:
   - Адреса первых 12 блоков данных
   - Максимум: 12 × 4 КБ = 48 КБ

2. **Addr[12] — косвенная адресация (single indirect block):**
   - Один блок косвенных указателей содержит 4096/4 = 1024 указателя
   - Каждый указатель указывает на блок данных
   - Максимум: 1024 × 4 КБ = 4 МБ
   - Всего с прямыми: 48 КБ + 4 МБ = ~4 МБ

3. **Addr[13] — двойная косвенная адресация (double indirect block):**
   - Блок содержит 1024 указателя на блоки косвенных указателей
   - Каждый такой блок содержит 1024 указателя на данные
   - Максимум: 1024 × 1024 × 4 КБ = 4 ГБ
   - Всего: ~4 ГБ

4. **Addr[14] — тройная косвенная адресация (triple indirect block):**
   - Используется для очень больших файлов
   - Максимум: 1024^3 × 4 КБ = 4 ТБ

**Пример расчета адреса блока при чтении:**

```
Задача: прочитать байт 15000 из файла
Размер блока = 4096 байт

1. Номер блока = 15000 / 4096 = 3 (блок с индексом 3)
2. Смещение в блоке = 15000 % 4096 = 3808 байт

3. Поскольку номер блока = 3, это попадает в прямые указатели (Addr[0-11])
4. Адрес блока берется из Addr[3]
5. Фактический адрес = адрес из Addr[3] + 3808
```

**Преимущества i-узлов:**
- Отделение метаданных от имен файлов
- Эффективная адресация файлов любого размера
- Поддержка жестких ссылок
- Быстрый доступ благодаря многоуровневой адресации

### Совместно используемые файлы

**Совместно используемые файлы** — это файлы, на которые указывают несколько имен в файловой системе. Это реализуется через **жесткие ссылки (hard links)**.

**Как работают жесткие ссылки:**

В отличие от копирования файла, жесткая ссылка создает новую запись в каталоге с **тем же номером i-узла**. Поэтому все имена указывают на один и тот же файл.

**Пример в памяти файловой системы:**
```
Таблица i-узлов:
i-узел 100: размер=1024, владелец=john, ...

Каталог /home/john/:
имя файла | номер i-узла
data      | 100
backup    | 100

Вторая ссылка:
$ ln data backup    # создается жесткая ссылка
```

Теперь оба имени указывают на один и тот же файл (i-узел 100). Содержимое всегда остается в одном месте на диске.

**Счетчик ссылок (link count, Nlink):**
```
После создания файла:
data: Nlink = 1

После создания жесткой ссылки:
data: Nlink = 2
backup: Nlink = 2
```

Файл удаляется с диска только когда **Nlink становится равным 0**.

**Ограничения жестких ссылок:**
- Нельзя создать жесткую ссылку на каталог (во избежание циклов)
- Нельзя создать жесткую ссылку через границы файловых систем (разные диски)
- Все ссылки должны быть на одном диске, так как они используют номер i-узла

---

## 40. Структура файловой системы. Реализация файлов. Жесткие и символические ссылки

### Жесткие ссылки (Hard Links)

**Жесткая ссылка** — это новая запись в каталоге, которая указывает на **тот же i-узел**, что и исходный файл.

**Характеристики жестких ссылок:**

```
$ ln исходный_файл имя_ссылки

Пример:
$ ln /home/user/data.txt /home/user/data_link.txt
```

**Как это выглядит в памяти:**
```
Диск:

i-узел 500:
├─ Mode: -rw-r--r--
├─ Size: 1024
├─ Nlink: 2
├─ Addr[0]: блок 1000

Каталог /home/user:
data.txt       → i-узел 500
data_link.txt  → i-узел 500

Блок 1000 (содержимое файла): "Привет, мир!"
```

**Свойства жестких ссылок:**

1. **Неразличимость** — обе ссылки совершенно равноправны:
   ```bash
   $ ls -i /home/user/data*
   500 /home/user/data.txt
   500 /home/user/data_link.txt
   ```

2. **Общее содержимое** — изменение одного имени меняет содержимое для обоих:
   ```bash
   $ echo "Новая строка" >> data.txt
   $ cat data_link.txt
   # Покажет "Новая строка"
   ```

3. **Независимые имена в каталогах** — можно удалить одно имя, файл остается:
   ```bash
   $ rm /home/user/data.txt
   $ cat /home/user/data_link.txt  # Все еще работает!
   ```

4. **Счетчик ссылок** — файл удаляется только при Nlink = 0:
   ```bash
   $ rm /home/user/data_link.txt   # Теперь Nlink = 0
   # Файл полностью удален
   ```

**Ограничения жестких ссылок:**
- ❌ Нельзя на каталоги (кроме самого каталога и родителя `.` и `..`)
- ❌ Не работают через границы файловых систем
- ❌ Зависят от номера i-узла (неоднозначно в разных FS)

### Символические ссылки (Symbolic Links, Symlinks)

**Символическая ссылка** — это специальный файл, который **содержит путь** (строку) на другой файл или каталог.

**Создание символической ссылки:**
```bash
$ ln -s исходный_файл имя_ссылки

Пример:
$ ln -s /home/user/data.txt /tmp/mydata
$ ln -s /usr/bin/python3 python
```

**Как это выглядит в памяти:**

```
i-узел 500 (исходный файл data.txt):
├─ Mode: -rw-r--r--
├─ Size: 1024
├─ Nlink: 1
├─ Addr[0]: блок 1000

i-узел 501 (символическая ссылка mydata):
├─ Mode: lrwxrwxrwx  (тип = ссылка)
├─ Size: 20 (размер пути "/home/user/data.txt")
├─ Nlink: 1
├─ Содержимое: "/home/user/data.txt"

Блок 1000 (содержимое файла): "Привет, мир!"
```

**Свойства символических ссылок:**

1. **Разные i-узлы**:
   ```bash
   $ ls -i /home/user/data.txt /tmp/mydata
   500 /home/user/data.txt
   501 /tmp/mydata
   ```

2. **Содержит путь** (видимо при прямом доступе):
   ```bash
   $ ls -l /tmp/mydata
   lrwxrwxrwx 1 user group 20 Jan 19 10:00 /tmp/mydata -> /home/user/data.txt
   
   $ readlink /tmp/mydata
   /home/user/data.txt
   ```

3. **Прозрачное разрешение пути** при нормальном использовании:
   ```bash
   $ cat /tmp/mydata  # Автоматически читает /home/user/data.txt
   Привет, мир!
   ```

4. **Не влияет на Nlink исходного файла**:
   ```bash
   $ rm /tmp/mydata      # Удалим ссылку
   $ cat /home/user/data.txt  # Файл целый!
   Привет, мир!
   ```

**Возможности символических ссылок:**

1. **Работают через границы файловых систем:**
   ```bash
   $ ln -s /mnt/other_drive/file.txt ~/link_to_remote
   ```

2. **Работают на каталоги:**
   ```bash
   $ ln -s /usr/local/include ~/include_link
   ```

3. **Могут быть "битыми" (broken links):**
   ```bash
   $ ln -s /home/user/deleted_file ~/broken_link
   $ cat ~/broken_link
   # Ошибка: No such file or directory
   ```

4. **Полезны для версионирования:**
   ```bash
   /opt/
   ├── app-v1.0/
   ├── app-v2.0/
   └── app -> app-v2.0/  # Ссылка на текущую версию
   ```

### Сравнение жестких и символических ссылок

| Аспект | Жесткие ссылки | Символические ссылки |
|--------|---|---|
| **Тип** | Новая запись в каталоге | Специальный файл (i-узел) |
| **i-узел** | Указывают на один i-узел | Разные i-узлы |
| **Nlink** | Увеличивают счетчик | Не влияют на счетчик |
| **На каталоги** | ❌ Нельзя | ✅ Можно |
| **Через FS** | ❌ Нельзя | ✅ Можно |
| **Видимость** | `ls` показывает как обычные файлы | `ls -l` показывает стрелочку |
| **Битые ссылки** | Невозможны | Возможны |
| **Размер** | Ничего (только запись в каталоге) | Размер пути |
| **Производительность** | Быстрее (прямой доступ) | Медленнее (разрешение пути) |

---

## 41. Структура файловой системы. Реализация файлов. Суперблок как описатель файловой системы

### Суперблок: определение и назначение

**Суперблок (superblock)** — это критически важная структура данных, которая содержит описание всей файловой системы: ее размер, структуру, параметры и состояние.

**Суперблок обычно расположен:**
- В начале каждого раздела диска (блок 1 в ext2/ext3/ext4)
- Часто дублируется на нескольких блоках для восстановления

### Структура суперблока (ext2 на примере)

**Суперблок ext2 (1024 байта):**

| Смещение | Размер | Поле | Описание |
|----------|--------|------|---------|
| 0 | 4 | Total inodes | Общее количество i-узлов в файловой системе |
| 4 | 4 | Total blocks | Общее количество блоков в файловой системе |
| 8 | 4 | Reserved blocks | Блоки, зарезервированные для администратора |
| 12 | 4 | Free blocks | Количество свободных блоков |
| 16 | 4 | Free inodes | Количество свободных i-узлов |
| 20 | 4 | Block size | Размер блока (2^(10 + значение)) |
| 24 | 4 | Fragment size | Размер фрагмента |
| 28 | 4 | Blocks per group | Блоков на группу |
| 32 | 4 | Fragments per group | Фрагментов на группу |
| 36 | 4 | Inodes per group | I-узлов на группу |
| 40 | 4 | Last mount time | Время последнего монтирования |
| 44 | 4 | Last write time | Время последней записи |
| 48 | 2 | Mount count | Количество монтирований |
| 50 | 2 | Max mount count | Максимум монтирований до проверки |
| 52 | 2 | Magic number | 0xEF53 (сигнатура ext2) |
| ... | ... | ... | ... |

**Пример содержимого (в шестнадцатеричном виде):**
```
Total inodes:     500000
Total blocks:     1000000
Reserved blocks:  50000 (5%)
Free blocks:      750000
Free inodes:      480000
Block size:       4096 (2^12)
```

### Назначение полей суперблока

**1. Параметры размера:**
- `Total inodes` и `Total blocks` — размеры FS
- Позволяет ОС понять объем доступного пространства

**2. Информация о свободном месте:**
- `Free blocks` и `Free inodes` — сколько ресурсов свободно
- Используется при создании новых файлов
- Должна быть актуальна для контроля переполнения

**3. Параметры блока:**
- `Block size` — размер блока (обычно 4 КБ)
- Определяет адресацию и производительность
- **Должен совпадать при монтировании FS**

**4. Организация групп блоков:**
- `Blocks per group`, `Inodes per group` — структура группировки
- ext2 разбивает FS на группы для улучшения производительности

**5. Состояние FS:**
- `Mount count` — сколько раз монтирована FS
- `Last mount time`, `Last write time` — метаданные о последнем использовании
- `Max mount count` — после скольких монтирований нужна проверка целостности
- Помогает контролировать состояние диска

**6. Идентификация:**
- `Magic number` (0xEF53) — сигнатура ext2
- Позволяет ОС узнать тип FS при монтировании

### Важность суперблока

1. **Восстановление FS:** Суперблок содержит всю информацию для восстановления
2. **Консистентность:** Отслеживает состояние целостности
3. **Безопасность:** Резервные копии суперблока спасают FS при повреждении
4. **Монтирование:** ОС читает суперблок перед монтированием раздела

**Команды для работы с суперблоком:**
```bash
# Просмотр информации о суперблоке
dumpe2fs /dev/sda1 | head -30

# Восстановление суперблока (если поврежден основной)
e2fsck -b 32768 /dev/sda1

# Проверка целостности FS
fsck /dev/sda1
```

---

## 42. Структура файловой системы. Реализация файлов. Размещение с использованием связанного списка

### Метод связанного списка (Linked List Allocation)

**Размещение с использованием связанного списка** — это метод распределения файла по блокам диска, где каждый блок содержит указатель на следующий блок файла.

**Структура блока данных:**
```
┌─────────────────┬──────────────────────┐
│  Указатель на   │   Данные файла       │
│  следующий блок │   (n-4 байта)        │
├─────────────────┼──────────────────────┤
│  4 байта        │   4092 байта         │
│  (при блоке     │  (при блоке 4096)    │
│   4096 байт)    │                      │
└─────────────────┴──────────────────────┘
```

**Пример в памяти диска:**

```
Файл "document.txt" размером 12000 байт:

Блок 100: [→Блок 110] + 4092 байта данных
Блок 110: [→Блок 120] + 4092 байта данных
Блок 120: [→-1] + 3816 байта данных (последний блок)

Таблица размещения файлов:
document.txt: начало = блок 100
```

**Работа алгоритма:**
1. Читаем i-узел файла → получаем номер первого блока (100)
2. Читаем блок 100 → извлекаем 4092 байта данных + указатель на 110
3. Читаем блок 110 → извлекаем 4092 байта данных + указатель на 120
4. Читаем блок 120 → извлекаем оставшиеся 3816 байт + указатель -1 (конец)

### Преимущества связанного списка

✅ **Отсутствие фрагментации**
- Блоки могут быть расположены где угодно на диске
- Нет необходимости в дефрагментации

✅ **Динамическое расширение**
- Легко добавлять новые блоки в конец файла
- Не нужно знать финальный размер при создании

✅ **Простота управления памятью**
- Нет необходимости в сложных структурах выделения
- Каждый блок содержит информацию о следующем

### Недостатки связанного списка

❌ **Медленный случайный доступ**
- Чтобы прочитать блок N, нужно прочитать все блоки 0, 1, ..., N-1
- Для доступа к байту 8000000 в 2 ГБ файле нужно 500000+ операций чтения!

❌ **Надежность**
- Если повредится один указатель, остаток файла потеряется
- Потеря одного блока разрушает всю цепь

❌ **Пространство метаданных**
- Каждый блок тратит 4 байта (или более) на указатель
- Потеря эффективности использования диска (0.1%)

❌ **Кэширование**
- Если один блок не в памяти, нужно читать его с диска для следующего

### Пример: MS-DOS FAT

**File Allocation Table (FAT)** решает некоторые проблемы связанного списка:

**Вместо хранения указателя в каждом блоке, используется отдельная таблица FAT:**

```
FAT-таблица (в памяти или в кэше):
Блок 100 → 110
Блок 110 → 120
Блок 120 → EOF (-1)

Каталог:
document.txt: начало = 100

Когда нужен блок N файла, не нужно читать все предыдущие —
просто смотрим в FAT-таблицу.
```

**Улучшения FAT:**
- ✅ Быстрее, чем читать все блоки подряд (если FAT в памяти)
- ✅ Проще восстановление (таблица отдельно)
- ❌ Все еще медленно для случайного доступа
- ❌ Нужно хранить всю FAT в памяти при больших разделах

### Применение сегодня

Связанный список мало используется в современных FS:
- ❌ ext2/ext3/ext4 используют i-узлы с многоуровневой индексацией
- ❌ NTFS использует B-деревья
- ✅ FAT все еще используется в USB флешках и некоторых встроенных системах

---

## 43. Структура файловой системы. Реализация каталогов. Оптимизации при поиске в каталогах

### Организация каталогов на диске

**Каталог** — это специальный файл, содержащий таблицу, связывающую имена файлов с их i-узлами.

**Внутренняя структура каталога:**

Каталог хранится как файл на диске, но его блоки содержат записи (entries) вместо пользовательских данных.

```
Блоки каталога на диске:
┌─────────────────────────────────────────────────┐
│  запись 1  │  запись 2  │  запись 3  │  ...    │
└─────────────────────────────────────────────────┘
```

**Структура одной записи в каталоге (ext2):**

```c
struct dirent {
    uint32_t inode;        // 4 байта - номер i-узла
    uint16_t rec_len;      // 2 байта - длина записи (включая имя)
    uint8_t name_len;      // 1 байт - длина имени
    uint8_t file_type;     // 1 байт - тип файла
    char name[255];        // Имя (переменная длина)
};
```

**Пример каталога `/home/john/` на диске:**

```
Запись 0:
├─ inode: 15420 (сам каталог)
├─ rec_len: 12
├─ name_len: 1
├─ name: "."

Запись 1:
├─ inode: 8193 (родительский каталог /home)
├─ rec_len: 12
├─ name_len: 2
├─ name: ".."

Запись 2:
├─ inode: 15421
├─ rec_len: 20
├─ name_len: 5
├─ name: "file1.c"

Запись 3:
├─ inode: 15422
├─ rec_len: 20
├─ name_len: 5
├─ name: "file2.o"

Запись 4:
├─ inode: 15423
├─ rec_len: 12
├─ name_len: 3
├─ name: "src"
```

### Навигация по структуре каталогов

**Разрешение пути при открытии файла `/home/john/src/main.c`:**

1. **Начало:** Читаем i-узел корневого каталога `/` (всегда i-узел 2)

2. **Поиск "home":**
   ```
   Просматриваем блоки i-узла 2 (корень):
   Находим запись: "home" → inode 50
   ```

3. **Поиск "john":**
   ```
   Просматриваем блоки i-узла 50 (/home):
   Находим запись: "john" → inode 15420
   ```

4. **Поиск "src":**
   ```
   Просматриваем блоки i-узла 15420 (/home/john):
   Находим запись: "src" → inode 15423
   ```

5. **Поиск "main.c":**
   ```
   Просматриваем блоки i-узла 15423 (/home/john/src):
   Находим запись: "main.c" → inode 15424
   ```

6. **Результат:** Открываем файл через i-узел 15424

### Оптимизации при поиске в каталогах

#### 1. Кэширование каталогов

**Проблема:** Каждый поиск по пути требует нескольких поисков в памяти диска.

**Решение:** ОС кэширует недавно использованные записи каталогов в памяти.

```c
// Структура кэша каталогов
struct dentry_cache {
    char *name;           // Имя файла
    struct inode *inode;  // Указатель на i-узел в памяти
    struct dentry_cache *parent;  // Родительский каталог
};
```

**Пример кэша:**
```
dentry_cache:
├─ "/" (root inode)
├─ "/home" → inode_50
├─ "/home/john" → inode_15420
├─ "/home/john/src" → inode_15423
└─ "/home/john/src/main.c" → inode_15424
```

При следующем открытии того же файла ОС не читает диск, а использует кэш!

#### 2. Хеширование имен

**Проблема:** Линейный поиск записей в каталоге медленный для больших каталогов (1000+).

**Решение:** Использование хеш-таблицы для быстрого поиска имен.

```
Hash-таблица для каталога:
┌──────┬────────────────────┐
│Hash  │  Список записей    │
├──────┼────────────────────┤
│ 0x02 │ "file1.c" → 15421  │
│ 0x1F │ "file2.o" → 15422  │
│ 0x45 │ "src" → 15423      │
│ 0x3A │ "data.txt" → 15425 │
└──────┴────────────────────┘

Поиск "file1.c":
1. Хеш("file1.c") = 0x02
2. Проходим список по индексу 0x02
3. Находим "file1.c" → 15421
```

#### 3. Двоичный поиск

**Проблема:** Если имена отсортированы, линейный поиск неэффективен.

**Решение:** Отсортировать имена и использовать двоичный поиск.

```
Отсортированный каталог:
data.txt    → 15425
file1.c     → 15421
file2.o     → 15422
main.c      → 15424
src         → 15423

Поиск "main.c":
1. Берем средний элемент: file2.o < main.c
2. Ищем правую половину
3. Берем main.c — НАЙДЕНО!
```

**Сложность:**
- Линейный поиск: O(n)
- Двоичный поиск: O(log n)

#### 4. Буферизация блоков каталогов

**Проблема:** Каждое чтение блока каталога требует операции дискового ввода-вывода.

**Решение:** ОС кэширует блоки каталогов в буферном кэше.

```
Буферный кэш:
┌──────────────────────┐
│ Блоки каталогов      │
│ (в памяти)           │
├──────────────────────┤
│ Блок 1100            │
│ Блок 1101            │
│ Блок 1102            │
└──────────────────────┘
```

При повторном доступе к тому же каталогу, блок уже в памяти!

#### 5. Ленивое преобразование имен

**Проблема:** Каждый символ имени требует сравнения.

**Решение:** Использование быстрого сравнения строк до полного поиска.

```c
// Быстрое сравнение по длине и хешу
if (strlen(target) == entry_len && hash_match) {
    // Полное сравнение
    if (strcmp(target, entry_name) == 0) {
        return entry_inode;
    }
}
```

### Linux ext2 — оптимизации в реальности

В Linux ext2 используется **комбинация технологий:**

```c
// Иерархия поиска в Linux
1. dentry_cache (кэш каталогов) — O(1)
2. Хеширование имен в каталоге — O(n/m) где m — размер хеша
3. Двоичный поиск (если нужно) — O(log n)
4. Буферный кэш для блоков
```

**Команды для отслеживания производительности:**
```bash
# Просмотр статистики кэша каталогов
cat /proc/sys/fs/dentry-state

# Просмотр размера кэша
free -m
```

---

## 44. Структура файловой системы. Виртуальные файловые системы

### Определение и назначение

**Виртуальная файловая система (VFS, Virtual File System)** — это абстрактный слой в ядре ОС, который обеспечивает **единый интерфейс для работы с различными типами файловых систем**.

VFS позволяет ОС работать с разными файловыми системами (ext2, NTFS, FAT, NFS и т.д.) так, как если бы это была одна система.

**Задача VFS:**
- Скрыть различия между разными FS
- Предоставить единый API приложениям
- Позволить монтировать разные FS в одно дерево каталогов

### Архитектура VFS

**Слои в ядре Linux:**

```
┌─────────────────────────────────────────┐
│  Приложение (cat, ls, open, read)      │
├─────────────────────────────────────────┤
│  Системные вызовы (syscall interface)   │
├─────────────────────────────────────────┤
│         ВИРТУАЛЬНАЯ ФАЙЛОВАЯ СИСТЕМА    │
│  (VFS слой в ядре)                      │
├─────────────────────────────────────────┤
│  Конкретные реализации FS:              │
│  ┌──────────┬──────────┬──────────┐    │
│  │ ext2/3/4 │  NTFS    │   FAT    │    │
│  └──────────┴──────────┴──────────┘    │
├─────────────────────────────────────────┤
│  Драйверы устройств (блочные устройства)│
├─────────────────────────────────────────┤
│  Буферный кэш и менеджер памяти         │
└─────────────────────────────────────────┘
```

### Ключевые структуры данных VFS

#### 1. Структура inode в памяти

**Когда файл открывается, ядро создает i-узел в памяти:**

```c
struct inode {
    ino_t       i_ino;           // Номер i-узла на диске
    struct super_block *i_sb;    // Указатель на суперблок FS
    unsigned int i_mode;         // Тип и права доступа
    uid_t       i_uid;           // Владелец
    gid_t       i_gid;           // Группа
    off_t       i_size;          // Размер файла
    time_t      i_atime;         // Время доступа
    time_t      i_mtime;         // Время модификации
    time_t      i_ctime;         // Время изменения метаданных
    blkcnt_t    i_blocks;        // Количество занятых блоков
    unsigned int i_count;        // Счетчик ссылок из памяти
    unsigned int i_flags;        // Флаги
    struct inode_operations *i_op;     // Указатели на методы
    struct file_operations  *i_fop;    // Указатели на методы
    struct address_space *i_mapping;   // Адресное пространство (для mmap)
};
```

**Связь между i-узлом диска и i-узлом памяти:**

```
Диск:
┌─────────────────────┐
│ i-узел на диске 500 │ (128 байт в ext2)
│ Mode, Size, ...     │
└─────────────────────┘
        ↑
        │ (читаем при открытии)
        ↓
Память:
┌──────────────────────────────┐
│ struct inode в памяти        │ (больше 1 КБ)
│ i_ino: 500                   │
│ i_size, i_mode, ...          │
│ i_count: 3 (3 открытия)      │
│ i_mapping, i_op, i_fop       │
└──────────────────────────────┘
```

#### 2. Структура dentry (запись каталога)

**"dentry" — это запись каталога в памяти ядра:**

```c
struct dentry {
    char *d_name;              // Имя файла
    struct inode *d_inode;     // Указатель на i-узел
    struct dentry *d_parent;   // Родительский каталог
    struct dentry *d_child;    // Дочерние записи
    struct list_head d_subdirs;// Список поддиректорий
    int d_count;               // Счетчик ссылок
    unsigned int d_flags;      // Флаги (valid, negative и т.д.)
};
```

**Иерархия dentry в памяти:**

```
/
├─ home (dentry)
│  ├─ john (dentry)
│  │  ├─ src (dentry) → inode_15423
│  │  │  └─ main.c (dentry) → inode_15424
│  │  └─ data.txt (dentry) → inode_15425
│  └─ mary (dentry) → inode_15430
└─ usr (dentry) → inode_15431
```

#### 3. Структура superblock (суперблок в памяти)

**После монтирования FS, ядро создает суперблок в памяти:**

```c
struct super_block {
    dev_t       s_dev;                 // Устройство
    unsigned long s_blocksize;         // Размер блока
    unsigned int s_blocksize_bits;     // log2(blocksize)
    struct file_system_type *s_type;   // Тип FS (ext2, NTFS и т.д.)
    struct super_operations *s_op;     // Методы для этого суперблока
    struct dentry *s_root;             // Корневой каталог
    struct list_head s_inodes;         // Список активных i-узлов
    struct list_head s_dirty;          // Список грязных i-узлов
    void *s_fs_info;                   // Приватные данные FS
};
```

### Операции VFS

**Основные операции, предоставляемые VFS приложениям:**

```c
// Операции с файлами
open(path, flags, mode)
read(fd, buf, count)
write(fd, buf, count)
lseek(fd, offset, whence)
close(fd)
stat(path, buf)
unlink(path)
rename(oldpath, newpath)

// Операции с каталогами
mkdir(path, mode)
rmdir(path)
chdir(path)
readdir(fd)
getcwd(buf, size)
link(oldpath, newpath)
symlink(target, linkpath)
```

**Каждая операция проходит через VFS:**

```
Приложение вызывает: open("/home/john/file.txt")
                       ↓
          Ядро обрабатывает системный вызов
                       ↓
          VFS разрешает путь (в dentry_cache)
          / → home → john → file.txt
                       ↓
     VFS определяет конкретную FS (ext2)
                       ↓
  Вызывает методы ext2: ext2_read, ext2_write
                       ↓
     Получает данные с диска через блочный уровень
                       ↓
          Возвращает результат приложению
```

### Преимущества VFS

✅ **Единый интерфейс**
- Приложения работают с файлами независимо от типа FS
- `read()` работает одинаково для ext2, NTFS, NFS

✅ **Поддержка нескольких FS**
- ОС может смонтировать разные FS в одно дерево
- Легко добавить поддержку новой FS без изменения приложений

✅ **Прозрачность монтирования**
- Файлы на разных FS выглядят как одна единая система
- Приложения не знают и не должны знать о типе FS

✅ **Эффективность**
- Кэширование dentry и i-узлов в памяти
- Оптимизация для наиболее частых операций

### Пример: монтирование разных FS

**В Linux можно собрать систему из разных FS:**

```
/                  (ext4)
├─ /boot           (ext2) ← отдельный раздел
├─ /home           (NTFS) ← Windows раздел
├─ /media/usb      (FAT32) ← USB флешка
└─ /mnt/nfs        (NFS) ← сетевая FS
```

**Для приложения это прозрачно:**
```bash
$ cat /home/john/document.docx    # Читает NTFS
$ cat /media/usb/photo.jpg        # Читает FAT32
$ cat /boot/vmlinuz               # Читает ext2

# Все работает одинаково благодаря VFS!
```

---

## 45. Структура файловой системы. Оптимальный выбор размер размера блока. Принципы отслеживания пустых блоков

### Размер блока файловой системы

**Блок** — это минимальная единица дискового пространства, которой может манипулировать FS. Выбор размера блока критичен для производительности.

**Типовые размеры блоков:**

| Размер | Характеристики | Применение |
|--------|---|---|
| **512 байт** | Исторический стандарт, малоэффективный | Старые системы |
| **1 КБ** | Мало используется | Flash память |
| **2 КБ** | Редко используется | Некоторые встроенные системы |
| **4 КБ** | **СОВРЕМЕННЫЙ СТАНДАРТ** | Большинство FS (ext2/3/4, NTFS) |
| **8 КБ** | Для больших файлов | Больные базы данных |
| **16 КБ** | Для видео и мультимедиа | Специализированные FS |
| **32 КБ** | Для очень больших файлов | DFS с большим медиа |
| **64 КБ** | Редко используется | Некоторые старые FS |

### Анализ компромиссов при выборе размера

#### Малый размер блока (512 байт - 2 КБ)

**Преимущества:**
✅ Мало неиспользуемого пространства в конце файла
- Для файла размером 513 байт нужен только 2 блока вместо 1 полного

✅ Низкие требования к памяти
- I-узел с 12 прямыми указателями может адресовать больше блоков

✅ Быстрее для малых файлов
- Малых файлов часто больше, чем больших

**Недостатки:**
❌ Большие служебные расходы в памяти и на диске
- Таблица размещения больше для того же дискового пространства
- Дольше читать метаданные

❌ Много операций ввода-вывода
- Для чтения большого файла нужно много дисковых операций
- Каждая операция имеет накладные расходы

❌ Неэффективное использование памяти
- Буферный кэш фрагментирован

#### Большой размер блока (8 КБ - 64 КБ)

**Преимущества:**
✅ Эффективная передача больших файлов
- Меньше дисковых операций для чтения
- Лучше использует скорость диска

✅ Меньше метаданных
- Таблица размещения меньше
- Быстрее поиск блоков

✅ Лучше для кэширования
- Больше данных загружается за один раз

**Недостатки:**
❌ Внутренняя фрагментация
- Файл размером 513 байт занимает целый 8 КБ блок!
- Потеря 7.5 КБ на файл

❌ Больше памяти на буферный кэш
- Каждый блок в памяти занимает больше места

❌ Медленнее для малых файлов
- Много времени на чтение ненужных данных

### Математический анализ оптимального размера

**Формула для расчета расходов:**

```
Полезность = (Размер файла) / (Размер блока)
```

**Теория:**
- Очень малые файлы (< 512 байт) плохо укладываются в большие блоки
- Очень большие файлы хорошо укладываются в любые блоки
- Оптимум зависит от распределения размеров файлов

**Эмпирические исследования показали:**

Для типичной файловой системы:
- **4 КБ** — оптимальный размер блока
- Это компромисс между производительностью и эффективностью

### Динамическое распределение блоков

**ext2 решение: фрагменты (fragments)**

```c
// В суперблоке ext2:
Block size:     4096 байт
Fragment size:  1024 байт

// Малые файлы могут занимать несколько фрагментов в одном блоке:
Файл 1: 1024 байта (фрагмент 0)
Файл 2: 512 байт   (часть фрагмента 1)
Файл 3: 2560 байт  (фрагменты 1-2)
```

**Это позволяет:**
✅ Снизить фрагментацию малых файлов
✅ Сохранить эффективность больших файлов

### Отслеживание пустых блоков

**Проблема:** ОС должна знать, какие блоки свободны для выделения новым файлам.

**Решение 1: Битовая карта (Bitmap)**

**Структура:** Массив битов, где каждый бит представляет один блок.

```
Битовая карта для 10 блоков:
Индекс:  0 1 2 3 4 5 6 7 8 9
Бит:     1 1 0 0 1 0 1 1 0 1
         │ │ └─┘ └─┘ │ │ │ │
         └─┘     Свободые блоки
      Занятые

Интерпретация:
- Блоки 0,1,4,6,7,9 — заняты (бит=1)
- Блоки 2,3,5,8 — свободны (бит=0)
```

**Преимущества:**
✅ Быстро найти свободный блок (операция поиска бита)
✅ Компактно хранится (1 бит на блок)
✅ Легко читать и обновлять

**Недостатки:**
❌ Всю битовую карту нужно хранить на диске
❌ Больших FS требуют много памяти (4 ТБ FS требует 512 МБ битовой карты!)

**Пример в ext2:**

```
Суперблок указывает на блок битовой карты (Block Bitmap):
┌────────────────────────────────┐
│ Блок битовой карты (1 блок)    │
├────────────────────────────────┤
│ 1 блок = 4096 байт = 32768 бит │
│ = может отслеживать 32768 блоков│
│ = 128 МБ дискового пространства │
└────────────────────────────────┘
```

**Решение 2: Список свободных блоков (Free List)**

**Структура:** Связанный список, где каждый узел содержит блоки.

```
Список свободных блоков:
┌────────┐
│ Блок 2 │ → [Блок 3] → [Блок 5] → [Блок 8] → NULL
│ 100    │
│ 101    │
│ 102    │
└────────┘
```

**Преимущества:**
✅ Хранит только свободные блоки
✅ При полной диске список пуст (нет памяти на бесполезные данные)

**Недостатки:**
❌ Медленно найти блок (нужно пройти список)
❌ Требует много операций с диском

**Решение 3: Суперблок со счетчиком (Free Block Count)**

**Структура:** В суперблоке хранится счетчик и список последних свободных блоков.

```c
struct superblock {
    int free_blocks_count;      // Всего свободных блоков
    int free_blocks[];          // Массив последних 16 свободных блоков
    int free_blocks_index;      // Индекс в массиве
};

// Если массив пуст, читаем специальный блок со списком
```

**Это используется в ext2/ext3/ext4 и дает оптимальный компромисс:**
✅ Быстро найти несколько блоков
✅ Не нужна большая память
✅ Легко управлять

### Отслеживание пустых i-узлов

**Аналогично блокам, но для i-узлов:**

```
Битовая карта i-узлов (inode bitmap):
Индекс:    0  1  2  3  4  5  6  7  8  9
Бит:       1  1  0  1  0  0  1  1  0  1
           │  │     │     └─┘     │
           Заняты              Свободые
```

**Суперблок отслеживает:**
```c
struct superblock {
    int total_inodes;          // Всего i-узлов
    int free_inodes_count;     // Свободных i-узлов
    
    int free_inodes[];         // Недавние свободные (для быстрого доступа)
};
```

### Алгоритм выделения блока

**Когда нужен новый блок для файла:**

```c
allocate_block() {
    // 1. Проверяем счетчик
    if (superblock.free_blocks_count == 0) {
        ERROR("Диск полон!");
        return -1;
    }
    
    // 2. Берем первый свободный блок из массива
    block = superblock.free_blocks[0];
    
    // 3. Если массив пуст, читаем специальный блок свободных блоков
    if (superblock.free_blocks_index == 0) {
        read_free_block_list();
    }
    
    // 4. Обновляем счетчик
    superblock.free_blocks_count--;
    
    // 5. Возвращаем блок
    return block;
}
```

---

## 46. Структура файловой системы. Поддержание непротиворечивости файловой системы. Увеличение производительности при работе с блоками файловой системы. Отображение файлов на оперативную память

### Проблема непротиворечивости

**Файловая система находится в непротиворечивом состоянии, если:**
- Все данные правильно связаны между собой
- Счетчики свободных блоков верны
- Нет потерянных блоков (занятых, но не используемых ни одним файлом)
- Нет циклов в структуре данных

**Источники проблем:**
❌ Внезапное отключение питания во время записи
❌ Ошибка ядра с перезагрузкой
❌ Сбой жесткого диска
❌ Некорректное завершение программы

**Пример нарушения целостности:**

```
Было (перед сбоем):
Блок 100: [→101][данные]
Блок 101: [→-1][данные]
Блок 102: [СВОБОДНЫЙ]

Во время записи нового блока произошел сбой.

Стало (после сбоя):
Блок 100: [→101][данные]
Блок 101: [→102][данные]  ← ЧАСТИЧНО ПЕРЕЗАПИСАН!
Блок 102: [???][???]      ← НЕИЗВЕСТНОЕ СОСТОЯНИЕ!

Суперблок:
Свободные блоки = 0 (но блок 102 свободный!)
```

### Журналирование (Journaling)

**Журналирование** — это техника, при которой перед внесением изменений в FS, они записываются в журнал.

**Структура:**

```
Журнал (Journal):
┌─────────────────────────┐
│ Запись 1: Транзакция    │
├─────────────────────────┤
│ Операция 1: Выделить блок 100
│ Операция 2: Обновить i-узел 50
│ Операция 3: Обновить суперблок
└─────────────────────────┘
```

**Процесс с журналированием:**

```
1. ОС записывает в журнал ВСЕ изменения, которые она собирается сделать
2. ОС ждет, пока журнал синхронизируется на диск
3. ОС выполняет реальные изменения в FS
4. ОС помечает транзакцию как завершенную

Если произойдет сбой:
- На диске есть полный журнал транзакции
- При восстановлении ОС может повторить операцию
- Или откатить ее, если она не была завершена
```

**Реальные системы журналирования:**

**ext3 / ext4 — журналирование на уровне метаданных:**
```
Транзакция:
└─ Изменения метаданных (i-узлы, блоки, каталоги)
   └─ Данные пользователя (не журналируются)
```

**NTFS — структурированное журналирование:**
```
Change Journal:
└─ Отслеживает ВСЕ изменения (метаданные и данные)
```

### Инструменты проверки целостности

**Unix: fsck (File System Check)**

```bash
# Проверка целостности FS
fsck /dev/sda1

# Автоматическое исправление
fsck -y /dev/sda1

# Без интерактивного режима
fsck -c /dev/sda1

# Проверка только READONLY
fsck -n /dev/sda1
```

**Что делает fsck:**

```
Фаза 1: Проверка i-узлов
├─ Проверяет битовую карту i-узлов
├─ Проверяет валидность i-узлов
└─ Отмечает плохие i-узлы

Фаза 2: Проверка структуры каталогов
├─ Проверяет связность каталогов
├─ Проверяет наличие всех записей
└─ Отмечает потерянные каталоги

Фаза 3: Проверка битовой карты
├─ Подсчитывает использованные блоки
├─ Сравнивает с битовой картой
└─ Исправляет ошибки

Фаза 4: Проверка счетчиков ссылок
├─ Подсчитывает ссылки на каждый i-узел
├─ Сравнивает с Nlink в i-узле
└─ Исправляет счетчики

Фаза 5: Проверка свободного пространства
├─ Подсчитывает свободные блоки и i-узлы
├─ Обновляет суперблок
└─ Исправляет счетчики
```

**Windows: sfc (System File Checker)**

```cmd
# Проверка целостности системных файлов
sfc /scannow

# Проверка и автоматическое исправление
sfc /scannow /offbootdir=C:\
```

### Увеличение производительности при работе с блоками

#### 1. Буферизация блоков

**Буферный кэш** — это область памяти, которая хранит недавно читанные блоки.

```
Буферный кэш:
┌──────────────────────┐
│ Блок 100 (прочитан)  │
│ Блок 101 (прочитан)  │
│ Блок 200 (прочитан)  │
│ ...                  │
└──────────────────────┘
          ↑
         LRU выбросит блок, если памяти не хватает
```

**Алгоритм работы:**
```
read(block 100) {
    1. Проверим буферный кэш
    2. Если блок есть → вернуть из памяти (быстро!)
    3. Если нет → прочитать с диска (медленно)
    4. Положить в кэш
    5. Вернуть данные
}
```

**Преимущества:**
✅ Повторные чтения одного блока быстрые (из памяти)
✅ Амортизирует затраты на дисковые операции

#### 2. Предварительное чтение (read-ahead)

**Идея:** Если приложение читает блок N, скорее всего будут читать и блоки N+1, N+2, ...

```
read_block(100)
├─ Читаем блок 100
├─ Читаем блоки 101, 102, 103, 104... (предварительно)
└─ Когда приложение попросит блок 101, он уже в памяти!
```

**Пример для последовательного чтения файла:**
```
Без read-ahead:
read(block 0) → [диск I/O] → вернуть
read(block 1) → [диск I/O] → вернуть
read(block 2) → [диск I/O] → вернуть

С read-ahead:
read(block 0) → [диск I/O читаем 0-7] → вернуть 0
read(block 1) → [из кэша!] → вернуть 1
read(block 2) → [из кэша!] → вернуть 2
...
```

**Типичное значение:** 8-16 блоков read-ahead

#### 3. Асинхронная запись (write buffering)

**Идея:** Не писать на диск немедленно, а накопить изменения в памяти и написать позже.

```
Приложение:
write("Hello") → в буферный кэш
write("World") → в буферный кэш
close()        → еще в кэше
... (время спустя)
[дисковый процесс] → Синхронизирует все на диск за один раз
```

**Преимущества:**
✅ Быстрее для приложения (в памяти, а не на диске)
✅ Может объединить несколько записей в одну дисковую операцию

**Недостатки:**
❌ При сбое потеряются несинхронизированные данные

**Управление синхронизацией:**
```bash
# Синхронизировать все буферы на диск
sync

# Синхронизировать конкретный файл
fsync(fd)

# Асинхронная синхронизация (не ждать)
asyncio_sync(buffer)
```

#### 4. Кэширование на уровне FS

**Двухуровневое кэширование:**

```
Приложение
    ↓
Буферный кэш (ядро)     ← уровень 1 (быстро)
    ↓
Дисковый кэш (SSD)      ← уровень 2 (среднее)
    ↓
Механический диск       ← уровень 3 (медленно)
```

**Современные системы:**
- ✅ SSD имеют встроенный кэш (8-256 МБ)
- ✅ Контроллер диска имеет буферный кэш
- ✅ Ядро ОС имеет буферный кэш
- ✅ Приложение может иметь собственный кэш

### Отображение файлов на оперативную память

**Memory-mapped файлы (mmap)** — это техника, при которой файл отображается в адресное пространство процесса.

```c
// Обычное чтение файла:
int fd = open("file.txt");
char buf[1024];
read(fd, buf, 1024);  // Копирование данных

// Memory-mapped чтение:
char *ptr = mmap(NULL, 1024, PROT_READ, MAP_SHARED, fd, 0);
// Теперь ptr указывает прямо на данные файла в памяти!
```

**Как это работает:**

```
Виртуальное адресное пространство процесса:
┌──────────────────────┐
│ Код программы        │
├──────────────────────┤
│ Данные               │
├──────────────────────┤
│ Динамическая память  │
├──────────────────────┤
│ [память файла]       │ ← mmap отображает файл здесь!
│ [данные из файла]    │
│ [выглядит как RAM]   │
└──────────────────────┘
        ↓
      Физическая RAM ← ОС автоматически загружает блоки по требованию
```

**Преимущества mmap:**
✅ Прозрачный доступ к файлу (как к обычной памяти)
✅ Эффективнее для больших файлов
✅ ОС сама управляет загрузкой блоков

✅ Несколько процессов могут MAP_SHARED одного файла → общее использование памяти

**Недостатки:**
❌ Сложнее обрабатывать ошибки I/O (они приходят как SIGSEGV)
❌ Портативность (не все ОС поддерживают)

**Пример: программа быстрого поиска в файле**

```c
int main(int argc, char *argv[]) {
    int fd = open(argv[1], O_RDONLY);
    struct stat sb;
    fstat(fd, &sb);
    
    // Отобразим весь файл
    char *file_ptr = mmap(NULL, sb.st_size, PROT_READ, 
                          MAP_SHARED, fd, 0);
    
    // Теперь можно работать с файлом как с памятью
    for (off_t i = 0; i < sb.st_size; i++) {
        if (file_ptr[i] == 'x') {
            // Найдено!
        }
    }
    
    munmap(file_ptr, sb.st_size);
    close(fd);
    
    return 0;
}
```

---

## 47. Как работает Copy-On-Write.

### Определение и назначение

**Copy-on-Write (CoW)** — это оптимизация, при которой копирование данных откладывается до момента, когда один из процессов попытается **изменить** эти данные.

**Идея:** Зачем копировать данные, если оба процесса только их читают?

### Проблема: дорогое копирование

**Традиционное копирование при fork():**

```c
// Родительский процесс
pid_t child = fork();

if (child == 0) {
    // Дочерний процесс
    // Ядро КОПИРУЕТ всю память родителя в дочерний процесс
    // Для процесса с 500 МБ памяти это занимает время и диск!
}
```

**Проблема:** fork() очень медленный для больших процессов, потому что копирует всю память.

### Решение: Copy-on-Write

**Вместо копирования памяти:**

1. ОС помечает все страницы памяти как **read-only** для обоих процессов
2. Обе процессы указывают на **одни и те же физические страницы**
3. Если процесс попытается писать → **Page Fault!**
4. ОС ловит исключение, копирует страницу, и позволяет писать

**Диаграмма:**

```
ДО fork():
Родитель: ┌──────────┬──────────┬──────────┐
          │ Страница │ Страница │ Страница │
          └──────────┴──────────┴──────────┘

ПОСЛЕ fork() с CoW:
Родитель: ┌────────────────────────────────┐
          │  Виртуальные адреса 0x1000     │
          └────────────────────────────────┘
                      ↓ (указывают на одни и те же)
Дочерний:  ┌──────────┬──────────┬──────────┐
           │ Страница │ Страница │ Страница │ (физическая память)
           │(read-only)
           └──────────┴──────────┴──────────┘

ЕСЛИ дочерний пишет в свою страницу:
Дочерний хочет писать → Page Fault!
    ↓
ОС копирует физическую страницу
    ↓
Новая физическая страница (для дочернего)
Старая физическая страница (остается у родителя)
```

### Пример из реальности

```c
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    char *buffer = malloc(100 * 1024 * 1024);  // 100 МБ
    strcpy(buffer, "Родительский процесс");
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс
        printf("Дочерний: %s\n", buffer);  // Чтение → нет копирования!
        strcpy(buffer, "Дочерний процесс");  // Запись → Page Fault → копирование!
        
    } else {
        // Родительский процесс
        sleep(1);
        printf("Родитель: %s\n", buffer);  // Все еще видит "Родительский процесс"
    }
    
    return 0;
}
```

**Что происходит:**
1. Оба процесса читают "Родительский процесс" из одной страницы → быстро!
2. Дочерний пишет → Page Fault → ядро копирует страницу → дочерний может писать
3. Родитель видит только свою копию

### Copy-on-Write в файловых системах

**CoW используется и для отображения файлов на память:**

```
Процесс A:  ┌──────────────────────┐
            │ mmap(file.dat)       │ (read-only)
            └──────────────────────┘
                        ↓ (один файл на диске)
Процесс B:  ┌──────────────────────┐
            │ mmap(file.dat)       │ (read-only)
            └──────────────────────┘

Если процесс A пишет:
            ┌──────────────────────┐
            │ Копия в памяти A     │
            └──────────────────────┘
                    ↑
          (исходный файл не изменен)
```

**Преимущества для файловых систем:**
✅ Быстрое создание снимков (snapshots)
✅ Эффективное использование памяти для общих файлов
✅ Снижение нагрузки на диск

### Copy-on-Write в системах виртуализации

**Виртуальные машины часто используют CoW:**

```
Шаблон диска ВМ (100 ГБ):
├─ VM1: Copy-on-Write слой (на диск пишутся только изменения)
├─ VM2: Copy-on-Write слой (на диск пишутся только изменения)
└─ VM3: Copy-on-Write слой (на диск пишутся только изменения)

Вместо хранения 100+100+100 ГБ, ОС хранит:
- 1 копия шаблона (100 ГБ)
- 3 дельта-слоя (только изменения, обычно 10-30 ГБ каждый)
```

**Экономия памяти:** 300 ГБ → 160 ГБ!

### Реализация Copy-on-Write

**В ядре Linux:**

```c
// Когда происходит Page Fault при записи:
void handle_page_fault(unsigned long addr) {
    struct page *page = get_page(addr);
    
    // Если на эту страницу ссылаются несколько процессов
    if (page->count > 1) {
        // Copy-on-Write!
        struct page *new_page = alloc_page();
        copy_page_contents(page, new_page);
        
        // Обновим таблицу страниц процесса
        set_page_table_entry(addr, new_page);
        
        // Уменьшим счетчик ссылок старой страницы
        page->count--;
    }
    
    // Теперь можно писать в страницу
    make_page_writable(addr);
}
```

**Ключевые компоненты:**
1. **Счетчик ссылок на страницу** (page->count)
   - Отслеживает, сколько процессов используют страницу

2. **Page Fault handler**
   - Ловит исключение при попытке писать в read-only страницу

3. **Копирование страницы**
   - Быстрое (все 4 КБ за раз)
   - Обновление таблицы страниц

### Преимущества и недостатки CoW

**Преимущества:**
✅ Ускорение fork() — процесс копирует память только при необходимости
✅ Экономия памяти — несколько процессов делят чтение одних данных
✅ Экономия диска — снимки ВМ занимают мало места
✅ Быстрое распределение ресурсов

**Недостатки:**
❌ Задержка при первой записи — Page Fault замедляет первую запись
❌ Сложность реализации в ядре
❌ Непредсказуемая производительность для интерактивных приложений

### Где используется CoW

| Область | Пример |
|---------|--------|
| **Процессы Unix** | fork() с CoW |
| **Файловые системы** | BTRFS, ZFS snapshots |
| **Виртуализация** | Hypervisor снимки ВМ |
| **БД** | MVCC (Multi-Version Concurrency Control) |
| **Системы контроля версий** | Git (своя реализация) |

---

# ИТОГОВОЕ РЕЗЮМЕ

## Основные ключевые понятия

### Слой абстракции файловой системы:
1. **Файл** — именованная последовательность байтов на диске
2. **Каталог** — таблица, связывающая имена файлов с i-узлами
3. **i-узел** — структура метаданных файла
4. **Блок** — минимальная единица дискового пространства

### Методы реализации:
- **Непрерывное размещение** — быстрый доступ, но фрагментация
- **I-узлы с многоуровневой адресацией** — гибкий размер файлов
- **Связанный список** — динамическое расширение, медленный доступ
- **Виртуальная файловая система** — единый интерфейс для разных FS

### Оптимизации производительности:
- **Блочный кэш** — быстрое повторное чтение
- **Read-ahead** — предварительное чтение блоков
- **Write buffering** — асинхронная запись на диск
- **Memory-mapped файлы** — прямой доступ из памяти
- **Copy-on-Write** — отложенное копирование

### Надежность:
- **Журналирование** — восстановление после сбоев
- **Битовые карты** — отслеживание свободных ресурсов
- **fsck/sfc** — проверка целостности системы

---

**Этот документ содержит полные и подробные ответы на все 10 вопросов из билетов по файловым системам, основанные на материалах учебников Таненбаума и Operating System Concepts.**