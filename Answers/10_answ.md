# Файловые системы

**Файловая система** — это часть операционной системы, определяющая способ организации, хранения и именования данных на носителях информации. Она предоставляет абстракцию "файлов" и "каталогов" для удобного взаимодействия пользователя и программ с данными, скрывая детали физического размещения на диске.

---

## Вопрос 38: Общие положения файловых систем. Понятие файла. Структура файла. Типы и характеристики файлов. Понятие Каталога. Операции над файлами и каталогами

### Понятие файла и его структура
**Файл** — именованная область данных на носителе информации. Это абстракция, скрывающая детали физического хранения.
**Структура файла**:
1.  **Неструктурированная последовательность байтов** (современный стандарт, Unix/Windows). ОС не знает о содержимом, смысл придают прикладные программы.
2.  **Последовательность записей** (фиксированной или переменной длины). Чтение/запись идет записями.
3.  **Дерево записей** (индексированные файлы, мейнфреймы). Поиск по ключу.

### Типы и характеристики
**Типы файлов**:
*   Регулярные файлы (текстовые, бинарные).
*   Каталоги (директории).
*   Специальные файлы устройств (блочные и символьные).
*   Каналы (pipes) и сокеты.
*   Символические ссылки.

**Характеристики (Атрибуты/Метаданные)**:
Имя, размер, время создания/модификации/доступа, владелец (UID), группа (GID), права доступа (RWX), флаги (скрытый, системный).

### Каталог
**Каталог** — файл, содержащий список соответствий «имя файла — идентификатор файла (inode)». Обеспечивает иерархическую структуру ФС.
*   **Корневой каталог (/)**.
*   **Текущий каталог (.)**.
*   **Родительский каталог (..)**.

### Операции
*   **Над файлами**: Create, Delete, Open, Close, Read, Write, Seek, Get/Set Attributes.
*   **Над каталогами**: Create, Delete, Opendir, Readdir, Rename, Link (создание ссылки).

---

## Общие понятия: Структура файловой системы и Реализация файлов

### Структура файловой системы
**Структура файловой системы** определяет, как данные организованы на диске. Обычно диск разбивается на разделы (partitions). В начале раздела располагается **Загрузочный блок** (Boot block), затем **Суперблок** (Superblock), содержащий параметры ФС. Далее следуют структуры для управления свободным местом (битовые карты или списки), область **i-узлов** (inode table) и область данных (data blocks), где хранятся файлы и каталоги.

### Реализация файлов
**Реализация файлов** решает задачу отображения логического потока байтов файла на физические блоки диска. Основная цель — обеспечить быстрый доступ (последовательный и произвольный) и эффективное использование места. Основные методы реализации:
1.  **Непрерывное размещение**: Файл занимает смежные блоки.
2.  **Связанный список**: Блоки разбросаны, каждый ссылается на следующий.
3.  **Индексированное размещение (i-nodes)**: Специальная структура хранит адреса всех блоков файла.

---

## Вопрос 39: Структура файловой системы. Реализация файлов. Непрерывное размещение файлов и I-узлы. Совместно используемые файлы

### Непрерывное размещение
Файл занимает последовательный набор блоков диска.
*   **Плюсы**: Простая реализация (хранится только начальный блок и длина), максимальная скорость чтения (нет поиска).
*   **Минусы**: Внешняя фрагментация диска, сложность расширения файла (если нет места сразу за ним). Применимо для CD/DVD (ISO 9660).

### I-узлы (Index Nodes)
Каждому файлу соответствует структура данных — **i-node**, содержащая атрибуты файла и адреса его блоков.
*   **Адресация**:
    *   Прямые адреса (на первые N блоков).
    *   Косвенный адрес (на блок, содержащий адреса).
    *   Двойной/тройной косвенный адрес (для больших файлов).
*   **Плюсы**: Быстрый доступ, отсутствие внешней фрагментации, легкое расширение файла.

### Совместно используемые файлы (Hard Links)
Реализуются через **жесткие ссылки**. В разных каталогах (или одном) создаются записи с разными именами, указывающие на **один и тот же i-node**. В i-node ведется счетчик ссылок. Файл удаляется физически только когда счетчик равен 0.

---

## Вопрос 40: Структура файловой системы. Реализация файлов. Жесткие и символические ссылки

### Жесткие ссылки (Hard Links)
*   Прямая ссылка на **i-node** файла.
*   Все жесткие ссылки на файл равноправны (исходное имя — тоже жесткая ссылка).
*   **Ограничения**: Нельзя ссылаться на каталоги (во избежание циклов), нельзя ссылаться на файлы в другой файловой системе (i-node уникален только в пределах одной ФС).

### Символические ссылки (Symbolic/Soft Links)
*   Специальный файл, содержащий **путь** к целевому файлу.
*   Имеет свой собственный i-node.
*   **Особенности**: Могут указывать на несуществующие файлы ("битые ссылки"), могут ссылаться на каталоги и файлы в других ФС. Медленнее жестких (нужен парсинг пути).

---

## Вопрос 41: Структура файловой системы. Реализация файлов. Суперблок как описатель файловой системы

### Суперблок
Ключевая структура данных, располагающаяся в начале раздела диска. Описывает параметры всей файловой системы. При монтировании считывается в память.
**Содержит**:
1.  Тип файловой системы (Magic number).
2.  Общее количество блоков и i-узлов.
3.  Количество свободных блоков и i-узлов.
4.  Размер блока.
5.  Указатели на списки свободных блоков/i-узлов (или битовые карты).
6.  Флаги состояния (чистая/грязная размонтировка).

Повреждение суперблока делает ФС нечитаемой (поэтому хранятся его копии).

---

## Вопрос 42: Структура файловой системы. Реализация файлов. Размещение с использованием связанного списка

### Связанный список блоков
Файл хранится как цепочка блоков. В начале каждого блока несколько байт отводится под указатель на следующий блок.
*   **Плюсы**: Нет внешней фрагментации, файл может расти пока есть место. Метаданные (в каталоге) хранят только адрес первого блока.
*   **Минусы**: Очень медленный произвольный доступ (чтобы прочитать конец, нужно пройти весь список), данные блока не степень двойки (из-за указателя), ненадежность (потеря одного блока рвет цепочку).

### Связанный список с таблицей (FAT)
Указатели вынесены из блоков данных в отдельную таблицу в памяти (**FAT - File Allocation Table**). Таблица индексируется номером блока.
*   `Table[i]` хранит номер следующего блока за блоком `i`.
*   **Плюсы**: Весь блок под данные, быстрый произвольный доступ (если таблица в RAM).
*   **Минусы**: Таблица может быть огромной для больших дисков, должна постоянно находиться в памяти.

---

## Вопрос 43: Структура файловой системы. Реализация каталогов. Оптимизации при поиске в каталогах

### Реализация каталогов
Каталог — это файл, содержащий список записей. Каждая запись: `(Имя файла, Номер i-узла)`.
1.  **Линейный список**: Простой массив записей. Поиск требует линейного сканирования ($O(N)$). Удаление требует сдвига или пометки "пусто". Медленно для больших каталогов.
2.  **Хеш-таблица**: Используется хеш от имени файла для быстрого поиска ($O(1)$). Сложнее в реализации (коллизии).
3.  **B-деревья**: Сбалансированные деревья (используются в NTFS, XFS, современных ext4). Гарантируют логарифмическое время поиска ($O(\log N)$) и сортировку имен.

### Оптимизации поиска
*   **Кэширование путей (dentry cache)**: В оперативной памяти (VFS) хранятся результаты трансляции путей в i-узлы, чтобы не читать диск каждый раз при обращении по пути.

---

## Вопрос 44: Структура файловой системы. Виртуальные файловые системы

### Виртуальная файловая система (VFS)
Абстрактный слой в ядре ОС, предоставляющий единый интерфейс (API) для работы с различными файловыми системами (ext4, NTFS, FAT32, NFS).
*   **Принцип**: Приложения используют системные вызовы `open`, `read`, `write`. VFS перенаправляет их к драйверу конкретной ФС.
*   **Объекты VFS**:
    *   `superblock` (описание ФС).
    *   `inode` (метаданные файла).
    *   `dentry` (элемент пути/каталога, кэшируется).
    *   `file` (открытый файл, связан с процессом).

---

## Вопрос 45: Структура файловой системы. Оптимальный выбор размер размера блока. Принципы отслеживания пустых блоков

### Выбор размера блока
Блок — минимальная единица обмена с диском и выделения места.
*   **Маленький блок** (0.5-1 КБ): Экономия места (малая внутренняя фрагментация для мелких файлов), но низкая скорость (много операций чтения/записи, большие таблицы размещения).
*   **Большой блок** (8-64 КБ): Высокая скорость (меньше операций для считывания объема данных), но большая потеря места (внутренняя фрагментация) для мелких файлов.
*   **Оптимум**: Обычно 4 КБ (компромисс + совпадает с размером страницы виртуальной памяти).

### Отслеживание пустых блоков
1.  **Связанный список свободных блоков**: В суперблоке ссылка на первый свободный, в нем — на следующий (или на группу свободных). Эффективно, если блоки не нужно искать подряд.
2.  **Битовая карта (Bitmap)**: Массив битов, где бит `i` равен 1, если блок занят, и 0, если свободен. Компактно, легко находить непрерывные группы блоков, легко загружать в процессорный кэш.

---

## Вопрос 46: Структура файловой системы. Поддержание непротиворечивости файловой системы. Увеличение производительности при работе с блоками файловой системы. Отображение файлов на оперативную память

### Непротиворечивость (Consistency)
Сбои питания могут нарушить целостность ФС (файл записан, а запись в каталоге нет).
1.  **Утилиты проверки (fsck)**: Сканируют весь диск, сверяют списки блоков и ссылки, исправляют ошибки. Очень медленно.
2.  **Журналирование (Journaling)**: Перед изменением ФС запись о намерении ("транзакция") пишется в журнал. После сбоя достаточно повторить операции из журнала. Быстрое восстановление.

### Увеличение производительности
1.  **Блочный кэш (Buffer Cache)**: Хранение часто используемых блоков диска в оперативной памяти.
2.  **Упреждающее чтение (Read-ahead)**: При последовательном чтении ОС заранее грузит следующие блоки в кэш.
3.  **Отложенная запись**: Данные пишутся в кэш, а на диск сбрасываются позже (группами), что снижает количество обращений к диску.

### Отображение файлов (Memory Mapping, mmap)
Механизм, позволяющий отобразить файл (или его часть) в виртуальное адресное пространство процесса.
*   Файл становится доступен как массив байтов в памяти.
*   ОС подгружает страницы файла по требованию (page fault).
*   Исключает лишнее копирование данных (buffer cache -> user space).

---

## Вопрос 47: Как работает Copy-On-Write

### Copy-On-Write (Копирование при записи)
Оптимизационная стратегия управления ресурсами.
*   **Суть**: При запросе на копирование данных (например, `fork()` процесса) реального физического копирования не происходит. Оба потребителя (родитель и потомок) получают ссылки на одни и те же страницы памяти, помеченные как "только для чтения".
*   **Срабатывание**: Если кто-то пытается **записать** данные, возникает исключение процессора (page fault). ОС перехватывает его, выделяет новую физическую страницу, копирует туда данные и разрешает запись для инициатора.
*   **Выгода**: Экономия памяти и времени, если данные не изменяются (или изменяются редко).
```c
// Родительский процесс
int fd = open("file.txt", O_RDWR);
void* addr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
// Fork создает CoW-копию адресного пространства
// Оба процесса изначально ссылаются на общие страницы файла
pid_t pid = fork();
// При записи в дочернем процессе:
if (pid == 0) {
    *(char*)addr = 'X'; // CoW: создается частная копия страницы и файл на диске НЕ изменяется
}
```
