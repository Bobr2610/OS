# Метрики параллельных алгоритмов

---

## Вопрос 19: Верхние оценки ускорения. Закон Мура. Закон Амдала. Расчет ускорения и эффективности

---

## 1. Введение в метрики параллельных алгоритмов

Для оценки эффективности параллельных алгоритмов используются ключевые метрики, которые позволяют количественно измерить улучшение производительности при использовании нескольких процессоров/ядер. К этим метрикам относятся **ускорение (speedup)** и **эффективность (efficiency)**.

### Основные обозначения:
- **T_s** — время выполнения алгоритма на одном процессоре (последовательное время)
- **T_p** — время выполнения алгоритма на p процессорах (параллельное время)
- **p** — количество процессоров/ядер
- **S_p** — ускорение (speedup) на p процессорах
- **E_p** — эффективность (efficiency) на p процессорах

---

## 2. Ускорение (Speedup)

### Определение

**Ускорение** — это отношение времени выполнения последовательного алгоритма к времени выполнения параллельного алгоритма:

```
S_p = T_s / T_p
```

### Интерпретация

- **S_p = 1**: параллелизм не дает улучшения
- **S_p = p**: **идеальное линейное ускорение** (ускорение равно количеству процессоров)
- **S_p < p**: сублинейное ускорение (более реалистичный случай)
- **S_p > p**: суперлинейное ускорение (очень редко, возможно благодаря эффектам кэширования)

### Пример расчета

Пусть последовательный алгоритм выполняется за 100 секунд, а параллельный алгоритм на 4 процессорах — за 30 секунд. Тогда:

```
S_4 = 100 / 30 ≈ 3.33
```

Это означает, что параллельная версия работает в 3.33 раза быстрее.

---

## 3. Эффективность (Efficiency)

### Определение

**Эффективность** — это отношение ускорения к количеству процессоров:

```
E_p = S_p / p = (T_s / T_p) / p = T_s / (p * T_p)
```

### Интерпретация

- **E_p = 1** (или 100%): идеальное использование всех процессоров
- **0 < E_p < 1**: неидеальное использование процессоров (типичный случай)
- **E_p ≈ 0**: процессоры используются неэффективно

Эффективность показывает, в какой степени каждый процессор загружен полезной работой. Чем ближе E_p к 1, тем лучше распределение нагрузки.

### Пример расчета

Используя данные из предыдущего примера:

```
E_4 = 3.33 / 4 ≈ 0.83 (или 83%)
```

Это означает, что каждый процессор используется приблизительно на 83% от его максимальной производительности.

---

## 4. Закон Мура (Moore's Law)

### Определение

**Закон Мура** — эмпирическое наблюдение, сформулированное Гордоном Муром в 1965 году:

> *Количество транзисторов на кристалле кремния удваивается примерно каждые 18-24 месяца (классически часто говорят о 2 годах).*

### Современная интерпретация

В контексте современных вычислительных систем закон Мура часто переформулируют как:

```
P(t) = P_0 * 2^(t / τ)
```

Где:
- **P(t)** — производительность процессора в момент времени t
- **P_0** — начальная производительность
- **τ** — период удвоения (18-24 месяца)
- **t** — прошедшее время

### Практическое значение

1. **Экспоненциальный рост производительности**: Если закон Мура сохранится, то через 10 лет производительность увеличится примерно в 100-1000 раз.

2. **Ограничения**:
   - Физические границы: достижение размеров атомов (примерно 7 нм в 2024 году)
   - Рассеивание тепла (thermal limits)
   - Экономическая нецелесообразность дальнейшего уменьшения размера

3. **Смещение фокуса**: Вместо увеличения частоты одного ядра, современные процессоры добавляют **множество ядер** (многоядерность).

### Практический пример

Если в 2024 году типичный процессор имеет 10 млрд транзисторов, то:
- 2026 год: 20 млрд транзисторов
- 2028 год: 40 млрд транзисторов
- 2030 год: 80 млрд транзисторов

---

## 5. Закон Амдала (Amdahl's Law)

### Определение

**Закон Амдала** — фундаментальный принцип, описывающий верхний предел ускорения параллельной программы, который зависит от доли **последовательного кода** в программе.

Сформулирован Джином Амдалом в 1967 году.

### Математическая формулировка

```
S_p = 1 / (f + (1 - f) / p)
```

Где:
- **S_p** — ускорение на p процессорах
- **f** — доля **последовательного** кода (0 ≤ f ≤ 1)
- **1 - f** — доля **параллелизуемого** кода
- **p** — количество процессоров

### Преобразованная форма

Закон Амдала часто записывают как:

```
S_p = 1 / (f + (1 - f) / p) = p / (f * p + (1 - f))
```

Или в предельном случае при p → ∞:

```
S_∞ = 1 / f
```

### Интерпретация

**S_∞ = 1 / f** показывает максимально возможное ускорение, которое может быть достигнуто, независимо от количества процессоров. Оно **полностью определяется долей последовательного кода**.

### Практические примеры

#### Пример 1: Программа с 10% последовательного кода

```
f = 0.1 (10% последовательного)
S_∞ = 1 / 0.1 = 10
```

**Вывод**: Максимальное ускорение не может превышать 10x, даже если у нас будет бесконечное количество процессоров.

Расчет ускорения для разного количества процессоров:

| p   | S_p = 1 / (0.1 + 0.9/p) | Значение |
|-----|------------------------|----------|
| 2   | 1 / (0.1 + 0.45)       | 1.82x    |
| 4   | 1 / (0.1 + 0.225)      | 3.08x    |
| 8   | 1 / (0.1 + 0.1125)     | 4.71x    |
| 16  | 1 / (0.1 + 0.05625)    | 6.40x    |
| 100 | 1 / (0.1 + 0.009)      | 9.17x    |

#### Пример 2: Программа с 50% последовательного кода

```
f = 0.5 (50% последовательного)
S_∞ = 1 / 0.5 = 2
```

**Вывод**: Максимальное ускорение составляет всего 2x, что сильно ограничивает масштабируемость.

#### Пример 3: Идеально параллелизуемая программа

```
f = 0 (0% последовательного, 100% параллельного)
S_∞ = 1 / 0 = ∞
```

**Вывод**: Теоретически возможно линейное ускорение с добавлением каждого процессора.

### Графическое представление

```
Ускорение S_p
    ^
    |     f=0 (идеально параллельное)
    |    /
    |   / S_p = p (линейное)
    |  /
    | /_____ f=0.1 (10% последовательное)
    |/      S_∞ = 10
    |
    +-----------> Количество процессоров p
```

### Главный вывод закона Амдала

> **Общая производительность параллельной системы лимитируется её последовательной частью.**

Даже небольшой процент последовательного кода существенно ограничивает масштабируемость. Это является основной причиной, почему:

1. Очень сложно добиться линейного ускорения на большом количестве процессоров
2. Нужно минимизировать последовательные участки кода
3. Синхронизация и обмен данными между потоками должны быть минимальными

---

## 6. Расчет верхних оценок ускорения

### Теоретический максимум по закону Амдала

Верхняя граница (upper bound) ускорения при известной доле последовательного кода:

```
S_max = 1 / f
```

Это достигается при p → ∞.

### Практические верхние оценки

При конечном количестве процессоров p:

```
S_p ≤ p  (верхняя граница = линейное ускорение)
S_p ≤ 1/f  (верхняя граница по закону Амдала)
```

Реальное ускорение ограничено **более строгой из двух оценок**.

### Пример комплексного расчета

Дано:
- Последовательное время: T_s = 100 сек
- Доля последовательного кода: f = 0.2 (20%)
- Число процессоров: p = 8

**Расчет максимального ускорения по Амдалу:**

```
S_max = 1 / 0.2 = 5
```

**Расчет ускорения на 8 процессорах:**

```
S_8 = 1 / (0.2 + 0.8/8) = 1 / (0.2 + 0.1) = 1 / 0.3 ≈ 3.33
```

**Вывод**: 
- Максимальное ускорение может быть не более 5x
- На 8 процессорах мы достигнем ускорения 3.33x
- Это близко к половине максимально возможного

---

## 7. Влияние синхронизации на ускорение

На практике, реальное время T_p включает:

```
T_p = T_sequential + T_parallel / p + T_synchronization + T_communication
```

Где:
- **T_sequential** — истинно последовательная часть алгоритма
- **T_parallel / p** — распределённая параллельная часть
- **T_synchronization** — время на синхронизацию потоков (мьютексы, барьеры)
- **T_communication** — время на обмен данными между потоками

Это объясняет, почему реальное ускорение часто меньше теоретического.

---

## 8. Практические рекомендации

### Для достижения хорошего ускорения:

1. **Минимизировать последовательный код** — выделить максимум параллелизируемой работы

2. **Уменьшить синхронизацию** — использовать lock-free алгоритмы, где это возможно

3. **Оптимизировать обмен данными** — избежать false sharing, минимизировать обмен между потоками

4. **Профилирование** — измерить реальное ускорение и эффективность для выявления узких мест

5. **Масштабируемость** — убедиться, что алгоритм хорошо масштабируется с увеличением количества процессоров

### Типичные проблемы:

- Закон Амдала показывает, что даже 5% последовательного кода ограничивает ускорение до 20x
- Синхронизация создаёт накладные расходы
- Неправильное распределение нагрузки приводит к простою процессоров
- Конкуренция за ресурсы (кэш, память, I/O)

---

## 9. Связь между законом Мура и параллелизмом

С исчерпанием возможностей закона Мура (увеличение частоты одного ядра), индустрия перешла на многоядерные архитектуры. Однако, согласно закону Амдала, добавление ядер помогает только если:

1. Код хорошо параллелизируется (низкое f)
2. Синхронизация минимальна
3. Нагрузка равномерно распределена

**Парадокс**: Больше ядер без параллелизуемого кода = впустую потраченные ресурсы.

---

## 10. Заключение

**Ключевые формулы для экзамена:**

```
Ускорение (Speedup):           S_p = T_s / T_p
Эффективность (Efficiency):    E_p = S_p / p = T_s / (p * T_p)
Закон Амдала:                 S_p = 1 / (f + (1-f)/p)
Максимальное ускорение:       S_max = 1 / f
```

**Главные идеи:**

1. **Ускорение** измеряет улучшение времени выполнения
2. **Эффективность** показывает, насколько хорошо используются процессоры
3. **Закон Мура** объясняет экспоненциальный исторический рост производительности
4. **Закон Амдала** показывает, что последовательный код ограничивает возможное ускорение
5. **Верхняя граница** ускорения определяется долей последовательного кода

Для сдачи экзамена убедитесь, что вы можете:
- Рассчитать ускорение и эффективность по формулам
- Объяснить суть закона Амдала на примерах
- Интерпретировать результаты
- Объяснить, почему масштабируемость имеет границы
