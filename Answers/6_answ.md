# Понятие критической области

**Критическая область (Critical Section)** — это участок кода процесса/потока, в котором происходит доступ к общим разделяемым ресурсам (переменным, структурам данных, файлам). Для обеспечения корректности работы программы одновременное нахождение более чем одного потока в критической секции, связанной с одним и тем же ресурсом, должно быть запрещено (взаимоисключение).

---

## Вопрос 20: Взаимоисключение с активным ожиданием

### Критическая область (Critical Section)
Участок кода, в котором процесс обращается к общим ресурсам (переменным, таблицам, файлам), которые могут быть изменены другими процессами. Одновременно в критической секции может находиться только один процесс.

**Условия корректного решения:**
1.  **Взаимоисключение**: Если процесс $P_1$ находится в критической секции, никакой другой процесс не может в ней находиться.
2.  **Прогресс**: Если в критической секции никого нет, а какие-то процессы хотят войти, то выбор следующего не может откладываться бесконечно.
3.  **Ограниченное ожидание**: Должен быть предел времени ожидания входа в критическую секцию.

### Активное ожидание (Busy Waiting)
Способ реализации взаимоисключения, при котором процесс в цикле проверяет условие входа, непрерывно потребляя процессорное время («спин-блокировка»).

---

## Вопрос 21: Взаимоисключение с активным ожиданием (Аппаратная поддержка)

### Аппаратные инструкции
Для реализации блокировок процессоры предоставляют атомарные инструкции:

1.  **Test-and-Set (TSL)**: Атомарно читает значение переменной и устанавливает её в 1.
2.  **Compare-and-Swap (CAS)**: Атомарно сравнивает значение ячейки памяти с ожидаемым, и если они равны, записывает новое значение.

### Спин-мьютекс (Spinlock)
Простейший примитив синхронизации на основе активного ожидания:

```c
void lock(int *lock_var) {
    while (test_and_set(lock_var) == 1); // Крутимся в цикле
}
void unlock(int *lock_var) {
    *lock_var = 0;
}
```
*   **Плюс**: Эффективен, если ожидание очень короткое (меньше времени переключения контекста).
*   **Минус**: Тратит процессорное время впустую. Не подходит для однопроцессорных систем без вытеснения.

---

## Вопрос 22: Алгоритм Петерсона (мьютекс на N потоков)

### Алгоритм Петерсона (для 2 потоков)
Программное решение проблемы взаимного исключения без использования специальных атомарных инструкций. Использует две переменные: массив флагов готовности `flag[]` и переменную очереди `turn`.
Процесс сообщает о желании войти (`flag[i] = true`) и уступает очередь (`turn = j`), затем ждет, пока соперник либо не хочет войти, либо очередь вернется к нему.

### Расширение на N потоков (Фильтр Петерсона)
Обобщение алгоритма для N потоков. Представляет собой N-1 уровней ("комнат ожидания"). Чтобы пройти на следующий уровень, поток должен стать "последним пришедшим" на текущем уровне и ждать, пока кто-то другой не придет и не сменит его на посту "швейцара".
*   Поток входит в критическую секцию, только пройдя все N-1 уровней.
*   Гарантирует отсутствие голодания и взаимной блокировки.

---

## Вопрос 23: Приостановка и активизация. Семафор, мьютекс и условная переменная

### Примитивы без активного ожидания
Вместо траты циклов CPU процесс блокируется (переходит в состояние Waiting), и ОС пробуждает его, когда ресурс свободен.

### 1. Семафор (Дейкстра)
Целочисленная переменная, доступ к которой осуществляется только через две атомарные операции: `P` (wait/down) и `V` (signal/up).
*   **Счетный семафор**: Значение $N \ge 0$. Используется для управления доступом к пулу из N ресурсов.
*   **Бинарный семафор**: Значение 0 или 1. Аналог мьютекса.

### 2. Мьютекс (Mutex)
Объект синхронизации, который может находиться в двух состояниях: захвачен и свободен.
*   Имеет владельца (тот, кто захватил, должен и освободить).
*   Используется исключительно для защиты критических секций.

### 3. Условная переменная (Condition Variable)
Механизм, позволяющий потокам ждать наступления определенного события (условия). Всегда используется в связке с мьютексом (для защиты проверки условия).
*   `wait(cv, mutex)`: Атомарно отпускает мьютекс и блокирует поток.
*   `signal(cv)`: Разблокирует один ожидающий поток.

---

## Вопрос 24: Приостановка и активизация. Отличия условной переменной от семафора

1.  **Назначение**:
    *   *Семафор*: Управление доступом к ресурсам (счетчик). Сигнал не теряется (увеличивает счетчик), даже если никто не ждет.
    *   *Условная переменная*: Ожидание события (состояния данных). Сигнал теряется, если никто не ждет (потоки должны проверять условие сами).
2.  **Память о прошлом**: Семафор хранит состояние (счетчик), условная переменная — нет.
3.  **Использование**: CV всегда требует внешнего мьютекса для защиты данных условия, семафор самодостаточен.

---

## Вопрос 25: Атомарные переменные (атомики). CAS инструкция. Спин-мьютекс

### Атомарные переменные
Переменные (обычно целые числа или указатели), операции над которыми (чтение, запись, инкремент, сложение) выполняются неделимо на аппаратном уровне. Гарантируют целостность данных без использования тяжелых блокировок ОС.

### CAS (Compare-And-Swap)
Фундаментальная инструкция для построения lock-free алгоритмов.
`CAS(p, old, new)`:

1.  Читает значение по адресу `p`.
2.  Если оно равно `old`, записывает `new`.
3.  Возвращает true/false (успех/неудача) или старое значение.
Все это происходит атомарно.

### Спин-мьютекс (на основе CAS)
Циклическая попытка захватить блокировку через CAS.
`while (!CAS(&lock, 0, 1)) { pause(); }`
Эффективен для очень коротких критических секций на многоядерных системах, так как избегает дорогого переключения контекста в ядро.

---

## Вопрос 26: Передача сообщений. Барьеры

### Передача сообщений (Message Passing)
Способ взаимодействия процессов (особенно в распределенных системах), где нет общей памяти.
*   Операции: `send(dest, msg)` и `receive(src, msg)`.
*   Может быть блокирующей (синхронной) или неблокирующей (асинхронной).
*   Решает проблемы синхронизации (нет гонок данных), но медленнее общей памяти из-за копирования данных.

### Барьеры (Barriers)
Примитив синхронизации для группы потоков. Ни один поток не может продолжить выполнение, пока **все** потоки группы не достигнут точки барьера.
*   Используется в параллельных вычислениях, разбитых на фазы (шаги).
*   Пример: Все потоки должны закончить чтение данных, прежде чем начать обработку.
